package org.iets3.core.expr.temporal.runtime;

/*Generated by MPS */

import java.util.function.Predicate;
import java.util.Objects;
import java.util.ArrayList;
import java.util.Collection;
import java.util.function.Consumer;
import java.time.LocalDate;
import java.util.Collections;
import java.util.Comparator;
import org.iets3.core.expr.simpleTypes.runtime.EqualsHelper;
import java.util.List;
import org.iets3.core.expr.datetime.runtime.AbstractDateRangeValue;
import java.math.BigInteger;
import java.math.BigDecimal;
import java.math.RoundingMode;
import org.iets3.core.expr.simpleTypes.runtime.OH;

public class TemporalValue implements Comparable<TemporalValue> {
  private final Predicate<SliceValue> VALUE_IS_TRUE = new Predicate<SliceValue>() {
    @Override
    public boolean test(SliceValue p1) {
      return Objects.equals(p1.value(), true);
    }
  };

  private Object defaultValue = null;

  private SliceArray slices = new SliceArray();

  public class SliceArray extends ArrayList<SliceValue> {
    @Override
    public boolean add(SliceValue e) {
      if (e == null) {
        return false;
      }
      return super.add(e);
    }
    @Override
    public void add(final int index, final SliceValue element) {
      if (element == null) {
        return;
      }
      super.add(index, element);
    }
    @Override
    public boolean addAll(Collection<? extends SliceValue> c) {
      int oldsize = size();
      Consumer<SliceValue> cons = new Consumer<SliceValue>() {
        @Override
        public void accept(SliceValue p1) {
          add(p1);
        }
      };
      c.forEach(cons);
      return size() == oldsize + c.size();
    }
    @Override
    public boolean addAll(final int index, Collection<? extends SliceValue> c) {
      int oldsize = size();
      Consumer<SliceValue> cons = new Consumer<SliceValue>() {
        @Override
        public void accept(SliceValue p1) {
          add(index, p1);
        }
      };
      c.forEach(cons);
      return size() == oldsize + c.size();
    }
  }

  public TemporalValue() {
  }

  public TemporalValue(Object constantValue) {
    this(LocalDate.MIN, constantValue);
  }

  public TemporalValue(LocalDate time, Object constantValue) {
    slices.add(new SliceValue(this, time, constantValue));
  }


  public TemporalValue copy() {
    TemporalValue res = new TemporalValue();
    for (SliceValue slice : this.slices) {
      res.slices.add(slice.copy(res));
    }
    return res;
  }


  public TemporalValue slice(LocalDate time, Object value) {
    TemporalValue res = this.copy();
    res.slices.add(new SliceValue(res, time, value));
    Collections.sort(res.slices, new Comparator<SliceValue>() {
      @Override
      public int compare(SliceValue p1, SliceValue p2) {
        return p1.time().compareTo(p2.time());
      }
    });
    return res;
  }

  public TemporalValue slice(SliceValue slice) {
    return this.slice(slice.time(), slice.value());
  }

  @Override
  public boolean equals(Object object) {
    if (object == null) {
      return false;
    }
    if (!(object instanceof TemporalValue)) {
      return false;
    }
    TemporalValue tv = (TemporalValue) object;
    if (tv.slices.size() != this.slices.size()) {
      return false;
    }
    for (SliceValue s : this.slices) {
      LocalDate t2 = s.time();
      SliceValue otherSlice = tv.findSliceAt(t2);
      if (otherSlice == null) {
        return false;
      }
      if (!(s.value() == null && (otherSlice.value() == null))) {
        if (!(EqualsHelper.equals(s.value(), otherSlice.value()))) {
          return false;
        }
      }
    }
    if (EqualsHelper.notEquals(this.defaultValue, tv.defaultValue)) {
      return false;
    }
    return true;
  }

  @Override
  public int hashCode() {
    return Objects.hash(this.slices, this.defaultValue);
  }

  private SliceValue findSliceAt(LocalDate at) {
    for (SliceValue slice : slices) {
      if (slice.time().isEqual(at)) {
        return slice;
      }
    }

    return null;
  }

  @Override
  public String toString() {
    return "TT" + this.slices;
  }

  public int numberOfSlices() {
    return this.slices.size();
  }

  public List<LocalDate> intervals() {
    ArrayList<LocalDate> result = new ArrayList<LocalDate>(slices.size());
    for (SliceValue slice : slices) {
      result.add(slice.time());
    }
    return result;
  }

  public Object valueAt(LocalDate time) {
    if (this.slices.size() == 0) {
      return null;
    }

    SliceValue lastSlice = lastSlice();
    if (lastSlice.beginsAtOrBeforeThan(time)) {
      return lastSlice.value();
    }

    SliceValue lastFoundSlice = slices.get(0);
    for (int i = 1; i < slices.size(); i++) {
      SliceValue s = slices.get(i);
      if (s.beginsLaterThan(time)) {
        return lastFoundSlice.value();
      }
      lastFoundSlice = s;
    }

    return null;
  }

  public TemporalValue after(LocalDate time) {
    if (this.slices.size() == 0) {
      return new TemporalValue();
    }
    if (this.slices.size() == 1) {
      SliceValue firstSlice = firstSlice();
      if (firstSlice.beginsAtOrLaterThan(time)) {
        return new TemporalValue(firstSlice.value());
      } else {
        return new TemporalValue(time, firstSlice.value());
      }
    } else {
      TemporalValue tv = new TemporalValue();
      for (int i = slices.size() - 1; i >= 0; i--) {
        SliceValue s = slices.get(i);
        if (s.beginsLaterThan(time)) {
          tv = tv.slice(s);
        } else {
          tv = tv.slice(time, s.value());
          break;
        }
      }
      return tv;
    }
  }

  public TemporalValue before(LocalDate time) {
    final int size = this.slices.size();
    if (size == 0) {
      return new TemporalValue();
    }

    if (size == 1) {
      SliceValue first = this.slices.get(0);
      if (first.beginsAtOrLaterThan(time)) {
        return new TemporalValue();
      } else {
        return new TemporalValue(time, first.value());
      }
    } else {
      TemporalValue tv = new TemporalValue();
      for (SliceValue s : this.slices) {
        if (s.beginsAtOrBeforeThan(time)) {
          tv = tv.slice(s);
        }
      }
      return tv;
    }
  }

  public TemporalValue between(LocalDate from, LocalDate to) {
    return this.before(to).after(from);
  }

  public SliceArray slices() {
    return this.slices;
  }

  public SliceValue lastSlice() {
    if (this.slices.isEmpty()) {
      return null;
    }
    return this.slices.get(this.slices.size() - 1);
  }

  public SliceValue firstSlice() {
    if (this.slices.isEmpty()) {
      return null;
    }
    return this.slices.get(0);
  }

  public Object reduce(ReduceStrategy strategy, AbstractDateRangeValue range) {
    TemporalValue between = this.between(range.begin(), range.end());
    if (between.slices().isEmpty()) {
      return defaultValue;
    }
    if (Objects.equals(strategy, ReduceStrategy.LAST)) {
      Object vv = between.lastSlice().value();
      return vv;
    } else if (Objects.equals(strategy, ReduceStrategy.FIRST)) {
      return between.firstSlice().value();
    } else if (Objects.equals(strategy, ReduceStrategy.WEIGHTED)) {
      BigInteger rangeDur = new BigInteger(range.countDays() + "");
      Number res = BigInteger.ZERO;
      for (SliceValue s : between.slices()) {
        BigInteger thisDuration = BigInteger.valueOf(s.durationInDays(range.end()));
        BigDecimal percentage = new BigDecimal(thisDuration).divide(new BigDecimal(rangeDur), 2, RoundingMode.HALF_UP);
        Number val = (Number) s.value();
        res = TemporalOps.plus(res, TemporalOps.mul(percentage, val));
      }
      return res;
    } else if (Objects.equals(strategy, ReduceStrategy.SUM)) {
      Number res = BigInteger.ZERO;
      for (SliceValue s : between.slices()) {
        res = TemporalOps.plus(res, (Number) s.value());
      }
      return res;
    }
    return null;
  }

  public boolean all() {
    return this.slices().stream().allMatch(this.VALUE_IS_TRUE);
  }

  public boolean any() {
    return this.slices().stream().anyMatch(new Predicate<SliceValue>() {
      @Override
      public boolean test(SliceValue p1) {
        return Objects.equals(p1.value(), true);
      }
    });
  }
  public boolean none() {
    return this.slices().stream().noneMatch(new Predicate<SliceValue>() {
      @Override
      public boolean test(SliceValue p1) {
        return Objects.equals(p1.value(), true);
      }
    });
  }

  public void setDefaultValue(Object defaultValue) {
    this.defaultValue = defaultValue;
  }

  public Object getDefaultValue() {
    return this.defaultValue;
  }

  @Override
  public int compareTo(TemporalValue other) {
    return OH.compare(this.intervals(), other.intervals());
  }
}
