package org.iets3.core.expr.temporal.runtime;

/*Generated by MPS */

import org.jetbrains.annotations.Nullable;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.Objects;

public class SliceValue {

  @Nullable
  private Object myValue;
  private LocalDate myTime;
  private TemporalValue owner;

  public SliceValue(TemporalValue owner, LocalDate time, @Nullable Object value) {
    myValue = value;
    myTime = time;
    this.owner = owner;
  }

  public SliceValue copy(TemporalValue newOwner) {
    return new SliceValue(newOwner, this.myTime, this.myValue);
  }

  public boolean isLast() {
    return this.owner.lastSlice() == this;
  }

  public boolean isFirst() {
    return this.owner.firstSlice() == this;
  }

  public SliceValue next() {
    if (isLast()) {
      return null;
    }
    int idx = this.owner.slices().indexOf(this);
    return this.owner.slices().get(idx + 1);
  }

  public SliceValue previous() {
    if (isFirst()) {
      return null;
    }
    int idx = this.owner.slices().indexOf(this);
    return this.owner.slices().get(idx - 1);
  }

  public long durationInDays(LocalDate defaultEnd) {
    if (isLast()) {
      return ChronoUnit.DAYS.between(myTime, defaultEnd);
    } else {
      LocalDate next = this.next().time();
      return ChronoUnit.DAYS.between(myTime, next);
    }
  }

  public LocalDate time() {
    return this.myTime;
  }

  @Nullable
  public Object value() {
    return this.myValue;
  }

  @Override
  public String toString() {
    return myTime.toString() + ":" + this.myValue;
  }

  public boolean beginsLaterThan(LocalDate time) {
    return this.time().compareTo(time) > 0;
  }

  public boolean beginsAtOrLaterThan(LocalDate time) {
    return this.time().compareTo(time) >= 0;
  }

  public boolean beginsAtOrBeforeThan(LocalDate time) {
    return time.compareTo(this.time()) >= 0;
  }

  /*package*/ void setTime(LocalDate time) {
    this.myTime = time;
  }

  @Override
  public boolean equals(Object obj) {
    if (obj == null) {
      return false;
    }
    if (!(obj instanceof SliceValue)) {
      return false;
    }
    SliceValue other = (SliceValue) obj;
    return Objects.equals(this.myTime, other.myTime) && Objects.equals(this.myValue, other.myValue);
  }

  @Override
  public int hashCode() {
    return Objects.hash(myTime, myValue);
  }
}
