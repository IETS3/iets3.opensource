package org.iets3.core.expr.genjava.temporal.rt.runtime;

/*Generated by MPS */

import org.iets3.core.expr.temporal.runtime.TemporalValue;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.Set;
import java.time.LocalDate;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.iets3.core.expr.temporal.runtime.TemporalOps;

public class TemporalValueHelper {

  public static TemporalValue perform(Object left, Object right, _FunctionTypes._return_P2_E0<? extends Object, ? super Object, ? super Object> binop, Object def) {
    if (left instanceof TemporalValue && right instanceof TemporalValue) {
      return ((TemporalValue) doWithTwoTemporals(((TemporalValue) left), ((TemporalValue) right), binop, def));
    } else if (left instanceof TemporalValue && !(right instanceof TemporalValue)) {
      return ((TemporalValue) doWithOneTemporal(((TemporalValue) left), right, binop, def));
    } else {
      throw new IllegalArgumentException("Arguments " + left + " and " + right + " are not applicable for this Operation.");
    }
  }

  public static Object doWithTwoTemporals(TemporalValue leftValue, TemporalValue rightValue, _FunctionTypes._return_P2_E0<? extends Object, ? super Object, ? super Object> binop, Object def) {
    Set<LocalDate> allIntervals = SetSequence.fromSet(new HashSet<LocalDate>());
    SetSequence.fromSet(allIntervals).addSequence(ListSequence.fromList(leftValue.intervals()));
    SetSequence.fromSet(allIntervals).addSequence(ListSequence.fromList(rightValue.intervals()));
    TemporalValue res = new TemporalValue();
    for (LocalDate i : ListSequence.fromList(SetSequence.fromSet(allIntervals).toList()).sort((it) -> it, true)) {
      Object leftSlice = leftValue.valueAt(i);
      Object rightSlice = rightValue.valueAt(i);
      if (leftSlice == null) {
        if (def != null) {
          leftSlice = def;
        } else {
          throw new InvalidSlicingException("No value for left arg at " + i + " (for " + leftValue + ")");
        }
      }
      if (rightSlice == null) {
        if (def != null) {
          rightSlice = def;
        } else {
          throw new InvalidSlicingException("No value for right arg at " + i + " (for " + rightValue + ")");
        }
      }
      res = res.slice(i, binop.invoke(leftSlice, rightSlice));
    }
    return TemporalOps.joinSlices(res);
  }

  public static Object doWithOneTemporal(TemporalValue leftValue, Object rightValue, _FunctionTypes._return_P2_E0<? extends Object, ? super Object, ? super Object> binop, Object def) {
    Set<LocalDate> allIntervals = SetSequence.fromSet(new HashSet<LocalDate>());
    SetSequence.fromSet(allIntervals).addSequence(ListSequence.fromList(leftValue.intervals()));
    TemporalValue res = new TemporalValue();
    for (LocalDate i : ListSequence.fromList(SetSequence.fromSet(allIntervals).toList()).sort((it) -> it, true)) {
      Object leftSliceVal = leftValue.valueAt(i);
      if (leftSliceVal == null) {
        if (def != null) {
          leftSliceVal = def;
        } else {
          throw new InvalidSlicingException("No value for left arg at " + i + " (for " + leftValue + ")");
        }
      }
      res = res.slice(i, binop.invoke(leftSliceVal, rightValue));
    }
    return res;
  }


}
