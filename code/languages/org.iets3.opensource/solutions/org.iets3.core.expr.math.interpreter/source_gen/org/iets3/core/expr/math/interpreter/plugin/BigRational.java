package org.iets3.core.expr.math.interpreter.plugin;

/*Generated by MPS */

import java.math.BigInteger;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Objects;
import org.iets3.core.expr.base.plugin.InfHelper;
import java.util.Arrays;

public final class BigRational extends Number implements Comparable<BigRational> {
  public static final BigRational ZERO = new BigRational(BigInteger.ZERO);
  public static final BigRational ONE = new BigRational(BigInteger.ONE);
  public static final BigRational HUNDRED = new BigRational(100);
  public static final int FLOAT_PRECISION = 8;
  public static final int DOUBLE_PRECISION = 16;
  private BigInteger num;
  private BigInteger den;
  public BigRational(final String val) {
    final String[] parts = val.split("_", 3);
    if (parts.length == 2) {
      final String[] tokens = parts[1].split("/", 3);
      if (tokens.length == 2) {
        final BigInteger den = new BigInteger(tokens[1]);
        final BigInteger x = new BigInteger(parts[0]);
        if (x.signum() < 0) {
          normalize(x.multiply(den).subtract(new BigInteger(tokens[0])), den);
        } else {
          normalize(x.multiply(den).add(new BigInteger(tokens[0])), den);
        }
      } else {
        throw new NumberFormatException(val);
      }
    } else
    if (parts.length == 1) {
      final String[] tokens = parts[0].split("/", 3);
      if (tokens.length == 2) {
        normalize(new BigInteger(tokens[0]), new BigInteger(tokens[1]));
      } else
      if (tokens.length == 1) {
        normalize(new BigDecimal(tokens[0]));
      } else {
        throw new NumberFormatException(val);
      }
    } else {
      throw new NumberFormatException(val);
    }
  }
  public BigRational(final BigDecimal decimal) {
    normalize(decimal);
  }
  public BigRational(final BigInteger numerator) {
    this(numerator, BigInteger.ONE);
  }
  public BigRational(final long i) {
    this(BigInteger.valueOf(i), BigInteger.ONE);
  }
  private BigRational(final BigInteger numerator, final BigInteger denominator) {
    this.num = numerator;
    this.den = denominator;
  }
  public static BigRational valueOf(final String val) {
    return new BigRational(val);
  }
  public static BigRational valueOf(final BigRational b) {
    return b;
  }
  public static BigRational valueOf(final BigInteger b) {
    return new BigRational(b.longValue());
  }
  public static BigRational valueOf(final BigDecimal x) {
    return new BigRational(x);
  }
  public static BigRational valueOf(final long x) {
    return new BigRational(x);
  }
  public static BigRational valueOf(final long n, final long d) {
    return new BigRational(BigInteger.valueOf(n), BigInteger.valueOf(d));
  }
  public static BigRational valueOf(final BigInteger n, final BigInteger d) {
    return new BigRational(n, d);
  }
  public static BigRational valueOf(final double x) {
    return new BigRational(BigDecimal.valueOf(x));
  }
  /**
   *  "x instanceof BigRational" betekent feitelijk "{@code known}" in Blaze-termen,
   *  en is het omgekeerde van ({@code null} of "{@code unknown}").
   * 
   *  Merk op: {@code null} en {@code unknown} zijn verschillende dingen in Blaze!
   *  In Blaze wordt {@code unknown} gerepresenteerd middels een (unchecked) exceptie (of een {@link Throwable}).
   * 
   *  E.e.a. ook het code-patroon (en variaties daarop):
   *  <pre>
   *      if (x instanceof BigRational) {
   *          if (y instanceof BigRational) {
   *              return ...;  // zowel x als y zijn known <==> main case
   *          } else {
   *              return ...;  // x is known, y is unknown
   *          }
   *      } else { // x is unknown
   *          if (y instanceof BigRational) {
   *              return ...;  // x is unknown, y is known
   *          } else {
   *              return ...;  // zowel x als y zijn unknown
   *          }
   *      }
   *  </pre>
   */
  public static BigRational plus(final Object x, final Object y) {
    if (x instanceof BigRational) {
      if (y instanceof BigRational) {
        return ((BigRational) x).add((BigRational) y);
      } else {
        return (BigRational) x;
      }
    } else {
      if (y instanceof BigRational) {
        return (BigRational) y;
      } else {
        return BigRational.ZERO;
      }
    }
  }
  public static BigRational minus(final Object x, final Object y) {
    if (x instanceof BigRational) {
      if (y instanceof BigRational) {
        return ((BigRational) x).subtract((BigRational) y);
      } else {
        return (BigRational) x;
      }
    } else {
      if (y instanceof BigRational) {
        return ((BigRational) y).negate();
      } else {
        return BigRational.ZERO;
      }
    }
  }
  public static BigRational times(final Object x, final Object y) {
    if (x instanceof BigRational && y instanceof BigRational) {
      return ((BigRational) x).multiply((BigRational) y);
    } else {
      return BigRational.ZERO;
    }
  }
  public static BigRational divided(final Object x, final Object y) {
    if (!(x instanceof BigRational)) {
      return BigRational.ZERO;
    }
    if (!(y instanceof BigRational) || ((BigRational) y).signum() == 0) {
      throw new ArithmeticException("Deling door 0");
    }
    return ((BigRational) x).divide((BigRational) y);
  }
  /**
   * @return of de gegeven waarden beiden BigRationals en aan elkaar gelijk zijn.
   * Wordt alleen gebruikt binnen asserts in Blaze-testcode!
   * Zie ook: http://127.0.0.1:63320/node?ref=r%3A16411437-d32f-44a1-bd92-eea909218b97%28validatie.generator.template.blazegen%40generator%29%2F7229391761713223042
   *  en http://127.0.0.1:63320/node?ref=r%3A38ca74ac-b52c-4618-ac01-8d15739d040f%28regelspraak.generator.template.blazegen%40generator%29%2F6383658820963478982
   *  en merk op dat de enum Vergelijkingsoperator geen literal "IS" heeft.
   */
  public static boolean IS(final Object x, final Object y) {
    return x instanceof BigRational && x.equals(y);
  }
  public static boolean LT(final Object x, final Object y) {
    return bothBigRationals(x, y) && ((BigRational) x).compareTo((BigRational) y) < 0;
  }
  public static boolean LE(final Object x, final Object y) {
    return bothBigRationals(x, y) && ((BigRational) x).compareTo((BigRational) y) <= 0;
  }
  public static boolean GT(final Object x, final Object y) {
    return bothBigRationals(x, y) && ((BigRational) x).compareTo((BigRational) y) > 0;
  }
  public static boolean GE(final Object x, final Object y) {
    return bothBigRationals(x, y) && ((BigRational) x).compareTo((BigRational) y) >= 0;
  }
  public static boolean EQ(final Object x, final Object y) {
    return bothNotBigRationals(x, y) || (bothBigRationals(x, y) && ((BigRational) x).compareTo((BigRational) y) == 0);
    // unknown EQ unknown ==> true
    // unknown EQ known   ==> false
    // known   EQ unknown ==> false
    // known   EQ known   ==> x.compareTo(y) == 0
  }
  public static boolean NE(final Object x, final Object y) {
    return !(EQ(x, y));
    // unknown NE unknown ==> false
    // unknown NE known   ==> true
    // known   NE unknown ==> true
    // known   NE known   ==> x.compare(y) != 0
  }
  private static boolean bothBigRationals(final Object x, final Object y) {
    return (x instanceof BigRational) && (y instanceof BigRational);
  }
  private static boolean bothNotBigRationals(final Object x, final Object y) {
    return (!(x instanceof BigRational)) && (!(y instanceof BigRational));
  }
  public static BigRational floor(final Object x, final int d) throws Throwable {
    return BigRational.decimals(x, d, RoundingMode.FLOOR);
  }
  public static BigRational ceiling(final Object x, final int d) throws Throwable {
    return BigRational.decimals(x, d, RoundingMode.CEILING);
  }
  public static BigRational half_up(final Object x, final int d) throws Throwable {
    return BigRational.decimals(x, d, RoundingMode.HALF_UP);
  }
  public static BigRational up(final Object x, final int d) throws Throwable {
    return BigRational.decimals(x, d, RoundingMode.UP);
  }
  public static BigRational down(final Object x, final int d) throws Throwable {
    return BigRational.decimals(x, d, RoundingMode.DOWN);
  }
  private static BigRational decimals(final Object x, final int decimals, final RoundingMode mode) throws Throwable {
    if (x instanceof BigRational) {
      return ((BigRational) x).round(decimals, mode);
    } else {
      throw (Throwable) x;
    }
  }
  public boolean fitsInLong(final long[] out) {
    try {
      out[0] = this.num.longValueExact();
      out[1] = this.den.longValueExact();
      return true;
    } catch (ArithmeticException outOfLongRange) {
      return false;
    }
  }
  private void normalize(final BigInteger numerator, final BigInteger denominator) {
    final int sign = denominator.signum();
    if (sign == 0) {
      throw new ArithmeticException("Deling door 0");
    }
    BigInteger d = numerator.gcd(denominator);
    // Reduce fraction (returns 0 iff num==0 && den==0).
    if (sign < 0) {
      d = d.negate();
      // Ensure invariant that denominator is positive.
    }
    this.num = numerator.divide(d);
    this.den = denominator.divide(d);
  }
  private void normalize(final BigDecimal decimal) {
    final int scale = decimal.scale();
    final BigInteger n = decimal.unscaledValue();
    if (scale > 0) {
      normalize(n, BigInteger.TEN.pow(scale));
    } else
    if (scale < 0) {
      this.num = n.multiply(BigInteger.TEN.pow(-scale));
      this.den = BigInteger.ONE;
    } else {
      this.num = n;
      this.den = BigInteger.ONE;
    }
  }

  public String toString() {
    return this.num + "/" + this.den;
  }

  public String toStringOld() {
    try {
      if (this.den.equals(BigInteger.ONE)) {
        return this.num.toString() + "/1";
      } else {
        return new BigDecimal(this.num).divide(new BigDecimal(this.den)).toPlainString();
      }
    } catch (ArithmeticException e) {
      final boolean negative = this.num.signum() < 0;
      final BigInteger n = ((negative ? this.num.negate() : this.num));
      if (this.den.compareTo(n) < 0) {
        final BigInteger[] divRem = n.divideAndRemainder(this.den);
        if (divRem[0].signum() != 0) {
          return ((negative ? "-" : "")) + divRem[0] + "_" + divRem[1] + "/" + this.den;
        }
      }
      return this.num + "/" + this.den;
    }
  }
  public String toString(int scale, RoundingMode mode) {
    return new BigDecimal(this.num).divide(new BigDecimal(this.den), scale, mode).toPlainString();
  }
  public int compareTo(BigRational that) {
    return this.num.multiply(that.den).compareTo(this.den.multiply(that.num));
  }
  public int signum() {
    return this.num.signum();
  }
  public boolean equals(Object that) {
    return that instanceof BigRational && this.compareTo((BigRational) that) == 0;
  }
  public int hashCode() {
    return Objects.hash(this.num, this.den);
  }
  public BigRational multiply(BigRational that) {
    final BigRational product = new BigRational(this.num.multiply(that.num), this.den.multiply(that.den));
    product.normalize(product.num, product.den);
    return product;
  }
  public BigDecimal multiply(BigDecimal that) {
    BigDecimal num = new BigDecimal(this.num);
    BigDecimal den = new BigDecimal(this.den);
    return num.multiply(that).divide(den, InfHelper.INF_PREC, InfHelper.DEFAULT_ROUNDING);
  }
  public BigRational add(BigRational that) {
    final BigRational sum = new BigRational(this.num.multiply(that.den).add(that.num.multiply(this.den)), this.den.multiply(that.den));
    sum.normalize(sum.num, sum.den);
    return sum;
  }
  public BigRational negate() {
    return new BigRational(this.num.negate(), this.den);
  }
  public BigRational abs() {
    return new BigRational(this.num.abs(), this.den);
  }
  public BigRational reciprocal() {
    final int sign = this.signum();
    if (sign > 0) {
      return new BigRational(this.den, this.num);
    } else
    if (sign < 0) {
      return new BigRational(this.den.negate(), this.num.negate());
    } else {
      throw new ArithmeticException("Deling door 0");
    }
  }
  public BigRational subtract(BigRational that) {
    return this.add(that.negate());
  }
  public BigRational divide(BigRational that) {
    return this.multiply(that.reciprocal());
  }
  public BigDecimal divide(BigDecimal that) {
    BigDecimal num = new BigDecimal(this.num);
    BigDecimal den = new BigDecimal(this.den);
    return num.divide(den.multiply(that), InfHelper.INF_PREC, InfHelper.DEFAULT_ROUNDING);
  }
  public BigRational pow(final int exponent) {
    final int e = Math.abs(exponent);
    final BigRational product = new BigRational(this.num.pow(e), this.den.pow(e));
    if (exponent < 0) {
      product.normalize(product.den, product.num);
    } else {
      product.normalize(product.num, product.den);
    }
    return product;
  }
  public BigRational round(final int digits, final RoundingMode mode) {
    return new BigRational(this.decimalValue(digits, mode));
  }
  public BigDecimal decimalValue(final int digits, final RoundingMode mode) {
    return new BigDecimal(this.num).divide(new BigDecimal(this.den), digits, mode);
  }
  public BigDecimal decimalValue(final int digits) {
    return this.decimalValue(digits, RoundingMode.HALF_UP);
  }
  /**
   * Converts to BigDecimal (real type value) with framework default precision, using framework default rounding (s. InfHelper).
   * 
   * Trailing zeros will be stripped if necessary.
   * 
   * @return decimal value for real type computation
   */
  public BigDecimal realValue() {
    return this.decimalValue(InfHelper.INF_PREC, InfHelper.DEFAULT_ROUNDING).stripTrailingZeros();
  }
  public double doubleValue() {
    return this.decimalValue(DOUBLE_PRECISION, RoundingMode.DOWN).doubleValue();
  }
  public float floatValue() {
    return this.decimalValue(FLOAT_PRECISION, RoundingMode.DOWN).floatValue();
  }
  public long longValue() {
    return this.decimalValue(0).longValue();
  }
  public int intValue() {
    return this.decimalValue(0).intValue();
  }
  /**
   * @return an array of values indices in the ascending order of those values.
   */
  public static Integer[] ascendingStableMergeSort(final BigRational[] values) {
    return stableMergeSort(values, true);
  }
  /**
   * Returns an array of values indices in the descending order of those values.
   */
  public static Integer[] descendingStableMergeSort(final BigRational[] values) {
    return stableMergeSort(values, false);
  }
  /**
   * @return an array of values indices in the ascending order of those values if ascending is true.
   * The order is descending if {@code ascending == false}.
   */
  private static Integer[] stableMergeSort(final BigRational[] values, final boolean ascending) {
    BigRationalArrayIndexComparator comparator = new BigRationalArrayIndexComparator(values, ascending);
    Integer[] indices = comparator.createIndexArray();
    // stable sort according to java.util.Arrays.sort documentation for used signature:
    Arrays.sort(indices, comparator);
    return indices;
  }
  public BigInteger numerator() {
    return this.num;
  }
  public BigInteger denominator() {
    return this.den;
  }
}
