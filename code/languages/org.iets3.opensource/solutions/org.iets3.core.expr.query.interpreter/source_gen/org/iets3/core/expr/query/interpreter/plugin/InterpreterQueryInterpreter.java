package org.iets3.core.expr.query.interpreter.plugin;

/*Generated by MPS */

import com.mbeddr.mpsutil.interpreter.rt.InterpreterBase;
import java.util.List;
import com.mbeddr.mpsutil.interpreter.rt.IEvaluator;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.mbeddr.mpsutil.interpreter.rt.ConceptEvaluatorBase;
import org.jetbrains.mps.openapi.model.SNode;
import com.mbeddr.mpsutil.interpreter.rt.IContext;
import com.mbeddr.mpsutil.interpreter.rt.ICoverageAnalyzer;
import com.mbeddr.mpsutil.interpreter.rt.ComputationTrace;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.pcollections.PVector;
import org.pcollections.Empty;
import java.util.Iterator;
import org.iets3.core.expr.metafunction.plugin.MFI;
import org.iets3.core.expr.base.behavior.IETS3ExprContext;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.mbeddr.mpsutil.interpreter.rt.DummyComputationTrace;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import com.mbeddr.mpsutil.interpreter.rt.StopAndReturnException;
import com.mbeddr.mpsutil.interpreter.rt.InterpreterEscapeException;
import com.mbeddr.mpsutil.interpreter.rt.InterpreterRuntimeException;
import com.mbeddr.mpsutil.interpreter.rt.EvaluatorInfo;
import com.mbeddr.mpsutil.interpreter.rt.ITypeMapper;
import com.mbeddr.mpsutil.interpreter.rt.IRelationship;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;

public class InterpreterQueryInterpreter extends InterpreterBase {
  public InterpreterQueryInterpreter() {
    init();
  }

  @Override
  public String getCategory() {
    return "arithmetic";
  }

  protected void populateEvaluators(List<? extends IEvaluator> evaluators) {
    ListSequence.fromList(((List<IEvaluator>) evaluators)).addElement(new ConceptEvaluatorBase(CONCEPTS.QueryExpr$TY, "r:18f3547a-68a5-47f3-9c76-69174048a29d(org.iets3.core.expr.query.interpreter.plugin)/6749162445851522994", true) {
      public Object evaluateEvaluator(final SNode node, IContext context, ICoverageAnalyzer coverage, final ComputationTrace trace) {
        try {
          coverage.visitedEvaluator(this);
          coverage.visitedConcept(this.concept);
          coverage.visitedConcept(SNodeOperations.getConcept(node));
          Object source = context.getRootInterpreter().evaluate(SLinkOperations.getTarget(SLinkOperations.getTarget(node, LINKS.source$IlS6), LINKS.expr$CW3E), context, coverage, trace, false);
          if (!(source instanceof PVector)) {
            return source;
          }
          PVector coll = (PVector) source;
          PVector res = coll;

          if (SLinkOperations.getTarget(node, LINKS.filter$MIJ3) != null) {
            PVector filtered = Empty.vector();
            Iterator<Object> it = coll.iterator();
            while (it.hasNext()) {
              Object next = it.next();
              Object isTrue = new MFI((IETS3ExprContext) context, SLinkOperations.getTarget(SLinkOperations.getTarget(node, LINKS.filter$MIJ3), LINKS.function$1smc)).run(next, ((_FunctionTypes._return_P0_E0<ComputationTrace>) () -> {
                if (trace != null) {
                  return trace;
                } else {
                  return new DummyComputationTrace(node);
                }
              }).invoke());
              if (isTrue instanceof Boolean && ((boolean) isTrue)) {
                filtered = filtered.plus(next);
              }
            }
            res = filtered;
          }

          if (SLinkOperations.getTarget(node, LINKS.transform$4t51) != null) {
            PVector transformed = Empty.vector();
            Iterator<Object> it = res.iterator();
            while (it.hasNext()) {
              Object next = it.next();
              Object t = new MFI((IETS3ExprContext) context, SLinkOperations.getTarget(SLinkOperations.getTarget(node, LINKS.transform$4t51), LINKS.function$1smc)).run(next, ((_FunctionTypes._return_P0_E0<ComputationTrace>) () -> {
                if (trace != null) {
                  return trace;
                } else {
                  return new DummyComputationTrace(node);
                }
              }).invoke());
              transformed = transformed.plus(t);
            }
            res = transformed;
          } else if (SLinkOperations.getTarget(node, LINKS.group$XKMp) != null) {

            // find groups
            Map<Object, PVector> grouped = MapSequence.fromMap(new HashMap<Object, PVector>());
            Iterator<Object> it = res.iterator();
            while (it.hasNext()) {
              Object next = it.next();
              Object key = new MFI((IETS3ExprContext) context, SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(node, LINKS.group$XKMp), LINKS.by$mRBH), LINKS.function$1smc)).run(next, ((_FunctionTypes._return_P0_E0<ComputationTrace>) () -> {
                if (trace != null) {
                  return trace;
                } else {
                  return new DummyComputationTrace(node);
                }
              }).invoke());
              PVector membersForKey = MapSequence.fromMap(grouped).get(key);
              if (membersForKey == null) {
                membersForKey = Empty.vector();
              }
              MapSequence.fromMap(grouped).put(key, membersForKey.plus(next));
            }

            PVector groups = Empty.vector();
            for (Object key : MapSequence.fromMap(grouped).keySet()) {
              Object built = new MFI((IETS3ExprContext) context, SLinkOperations.getTarget(SLinkOperations.getTarget(SLinkOperations.getTarget(node, LINKS.group$XKMp), LINKS.build$h0A0), LINKS.function$1smc)).setEvaluatedArgValue("key", key).setEvaluatedArgValue("members", MapSequence.fromMap(grouped).get(key)).run(((_FunctionTypes._return_P0_E0<ComputationTrace>) () -> {
                if (trace != null) {
                  return trace;
                } else {
                  return new DummyComputationTrace(node);
                }
              }).invoke());
              groups = groups.plus(built);
            }


            res = groups;
          }
          return res;
        } catch (StopAndReturnException stop) {
          return stop.value();
        } catch (InterpreterEscapeException ex) {
          throw ex;
        } catch (RuntimeException ex) {
          throw new InterpreterRuntimeException("query()", node, ex, trace);
        }
      }
      public EvaluatorInfo getInfo() {
        return new EvaluatorInfo("QueryExpr", "http://127.0.0.1:63320/node?ref=a2467ad3-f3ec-4eaa-bb9e-3f297621f39d%2Fi%3A10000001%28org.iets3.core.expr.query.interpreter%40transient60%2Forg.iets3.core.expr.query.interpreter.plugin%400%29%2F6749162445851522994");
      }

      @Override
      public String toString() {
        return "QueryExpr";
      }

      @Override
      public boolean canLookupBeCached() {
        return true;
      }
    });
  }


  protected void populateTypeMappers(List<? extends ITypeMapper> typeMappers) {
  }



  protected void populateRelationships(List<? extends IRelationship> relationships) {
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink source$IlS6 = MetaAdapterFactory.getContainmentLink(0x10e056b249fd40caL, 0x8b64de69c81163acL, 0x5da9d77c64611b63L, 0x5da9d77c6461211fL, "source");
    /*package*/ static final SContainmentLink expr$CW3E = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x3b256bb6ae8048d8L, 0x3b256bb6ae8048d9L, "expr");
    /*package*/ static final SContainmentLink filter$MIJ3 = MetaAdapterFactory.getContainmentLink(0x10e056b249fd40caL, 0x8b64de69c81163acL, 0x5da9d77c64611b63L, 0x5da9d77c6464d962L, "filter");
    /*package*/ static final SContainmentLink function$1smc = MetaAdapterFactory.getContainmentLink(0x711a16d799e84e1dL, 0xb20c99c0b7309cd8L, 0x53300f6d0c25a72bL, 0x53300f6d0c260151L, "function");
    /*package*/ static final SContainmentLink transform$4t51 = MetaAdapterFactory.getContainmentLink(0x10e056b249fd40caL, 0x8b64de69c81163acL, 0x5da9d77c64611b63L, 0x5da9d77c64696c04L, "transform");
    /*package*/ static final SContainmentLink group$XKMp = MetaAdapterFactory.getContainmentLink(0x10e056b249fd40caL, 0x8b64de69c81163acL, 0x5da9d77c64611b63L, 0x5da9d77c648455e5L, "group");
    /*package*/ static final SContainmentLink by$mRBH = MetaAdapterFactory.getContainmentLink(0x10e056b249fd40caL, 0x8b64de69c81163acL, 0x5da9d77c6484263fL, 0x5da9d77c64843ffeL, "by");
    /*package*/ static final SContainmentLink build$h0A0 = MetaAdapterFactory.getContainmentLink(0x10e056b249fd40caL, 0x8b64de69c81163acL, 0x5da9d77c6484263fL, 0x5da9d77c64862d2dL, "build");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept QueryExpr$TY = MetaAdapterFactory.getConcept(0x10e056b249fd40caL, 0x8b64de69c81163acL, 0x5da9d77c64611b63L, "org.iets3.core.expr.query.structure.QueryExpr");
  }
}
