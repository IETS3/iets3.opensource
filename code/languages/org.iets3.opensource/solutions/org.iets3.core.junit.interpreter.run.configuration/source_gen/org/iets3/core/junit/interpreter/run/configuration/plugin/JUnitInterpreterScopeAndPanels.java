package org.iets3.core.junit.interpreter.run.configuration.plugin;

/*Generated by MPS */

import com.intellij.openapi.ui.ComboBox;
import jetbrains.mps.project.Project;
import jetbrains.mps.baseLanguage.unitTest.execution.settings.ModuleChooser;
import jetbrains.mps.baseLanguage.unitTest.execution.settings.ModelChooser;
import jetbrains.mps.baseLanguage.unitTest.execution.settings.TestListPanel;
import com.intellij.ui.components.JBPanel;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.baseLanguage.unitTest.execution.settings.InProcessJBCheckBox;
import java.awt.GridBagConstraints;
import com.intellij.util.ui.JBInsets;
import com.intellij.util.ui.JBUI;
import java.awt.GridBagLayout;
import com.intellij.ui.components.JBLabel;
import com.intellij.ui.components.JBTextField;
import javax.swing.BoxLayout;
import javax.swing.Box;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import com.intellij.ui.SideBorder;
import com.intellij.ui.JBColor;
import javax.swing.border.CompoundBorder;
import javax.swing.DefaultListCellRenderer;
import java.awt.event.ItemListener;
import java.awt.event.ItemEvent;
import jetbrains.mps.internal.collections.runtime.Sequence;
import javax.swing.JComponent;
import jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.execution.lib.ClonableList;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.execution.lib.PointerUtils;
import org.jetbrains.mps.openapi.model.SModelReference;
import jetbrains.mps.persistence.PersistenceRegistry;
import org.jetbrains.mps.openapi.module.SModuleReference;
import jetbrains.mps.baseLanguage.unitTest.execution.settings.TestUtils;
import java.awt.Component;

public final class JUnitInterpreterScopeAndPanels {
  private ComboBox<JUnitInterpreterRunType> myRunTypeBox;
  private final Project myProject;
  private final ModuleChooser myModuleChooser;
  private final ModelChooser myModelChooser;
  private final TestListPanel myClassesChooser;
  private final TestListPanel myMethodsChooser;
  private final JBPanel myPanel;

  private JUnitInterpreterRunType myRunType = JUnitInterpreterRunTypes.PROJECT;

  private final List<SelectionChangeListener> mySelectionChangeListeners = new ArrayList<SelectionChangeListener>();

  private final Map<JUnitInterpreterRunType, PanelPerScope> myScopePanels = MapSequence.fromMap(new HashMap<JUnitInterpreterRunType, PanelPerScope>());

  public JUnitInterpreterScopeAndPanels(@NotNull com.intellij.openapi.project.Project project) {
    myProject = ProjectHelper.fromIdeaProject(project);
    myModelChooser = new ModelChooser(myProject);
    myModuleChooser = new ModuleChooser(myProject);
    JBPanel projectPanel = createProjectPanel(project);
    JBPanel modulePanel = createModulePanel();
    JBPanel modelPanel = createModelPanel();

    myClassesChooser = new TestListPanel(project, false);
    myMethodsChooser = new TestListPanel(project, true);

    MapSequence.fromMap(myScopePanels).put(JUnitInterpreterRunTypes.PROJECT, new PanelPerScope(projectPanel));
    MapSequence.fromMap(myScopePanels).put(JUnitInterpreterRunTypes.MODULE, new PanelPerScope(modulePanel));
    MapSequence.fromMap(myScopePanels).put(JUnitInterpreterRunTypes.MODEL, new PanelPerScope(modelPanel));
    MapSequence.fromMap(myScopePanels).put(JUnitInterpreterRunTypes.NODE, new PanelPerScope(myClassesChooser));
    MapSequence.fromMap(myScopePanels).put(JUnitInterpreterRunTypes.METHOD, new PanelPerScope(myMethodsChooser));
    myPanel = createPanelWithTestScope();
  }

  public JBPanel getPanel() {
    return myPanel;
  }

  public List<InProcessJBCheckBox> getInProcessCheckBoxes() {
    List<InProcessJBCheckBox> res = new ArrayList<InProcessJBCheckBox>();
    return res;
  }

  private static GridBagConstraints createStandardConstraints() {
    JBInsets insets = JBUI.emptyInsets();
    GridBagConstraints gc = new GridBagConstraints(0, 0, 1, 1, 1, 1, GridBagConstraints.WEST, GridBagConstraints.BOTH, insets, 0, 0);
    return gc;
  }

  private JBPanel createProjectPanel(com.intellij.openapi.project.Project project) {
    JBPanel projectPanel = new JBPanel(new GridBagLayout());
    GridBagConstraints gc = createStandardConstraints();
    gc.insets = JBUI.emptyInsets();
    projectPanel.add(new JBLabel("Project Name:"), gc);
    JBTextField projectNameField = new JBTextField(project.getName());
    projectNameField.setEditable(false);
    projectNameField.setEnabled(false);
    gc.gridx++;
    gc.anchor = GridBagConstraints.WEST;
    gc.fill = GridBagConstraints.NONE;
    projectPanel.add(projectNameField, gc);
    return projectPanel;
  }

  private JBPanel createModulePanel() {
    GridBagConstraints gc = createStandardConstraints();
    gc.insets = JBUI.emptyInsets();
    JBPanel modulePanel = new JBPanel(new GridBagLayout());
    gc.fill = GridBagConstraints.NONE;
    gc.weightx = 0.1;
    JBLabel label = new JBLabel("Module:");
    modulePanel.add(label, gc);
    gc.gridx++;
    gc.fill = GridBagConstraints.HORIZONTAL;
    gc.anchor = GridBagConstraints.EAST;
    gc.gridwidth = 1;
    gc.weightx = 1;
    modulePanel.add(myModuleChooser, gc);

    return modulePanel;
  }

  private JBPanel createModelPanel() {
    GridBagConstraints gc = createStandardConstraints();
    gc.insets = JBUI.emptyInsets();
    gc.fill = GridBagConstraints.HORIZONTAL;

    JBPanel modelPanel = new JBPanel(new GridBagLayout());
    gc.weightx = 0.1;
    JBLabel label = new JBLabel("Model:");
    modelPanel.add(label, gc);

    gc.gridx++;
    gc.weightx = 1;
    gc.fill = GridBagConstraints.HORIZONTAL;
    gc.anchor = GridBagConstraints.EAST;
    gc.gridwidth = 1;
    modelPanel.add(myModelChooser, gc);

    return modelPanel;
  }

  private JBPanel createPanelWithTestScope() {
    JBPanel res = new JBPanel();
    res.setLayout(new BoxLayout(res, BoxLayout.Y_AXIS));
    JBLabel label = new JBLabel("Test scope:");
    myRunTypeBox = createRunTypeBox();
    JBPanel runTypePanel = new JBPanel();
    runTypePanel.setLayout(new BoxLayout(runTypePanel, BoxLayout.X_AXIS));
    runTypePanel.add(label);
    runTypePanel.add(Box.createHorizontalStrut(JBUI.scale(20)));
    runTypePanel.add(myRunTypeBox);
    runTypePanel.add(Box.createHorizontalGlue());
    res.add(runTypePanel);
    res.add(Box.createVerticalStrut(JBUI.scale(10)));
    final JBPanel borderedPanelForScopes = new JBPanel(new GridBagLayout());
    GridBagConstraints gc = createStandardConstraints();
    final JBPanel panelForScopes = new JBPanel(new GridBagLayout());

    for (final JUnitInterpreterRunType runType : MapSequence.fromMap(myScopePanels).keySet()) {
      GridBagConstraints gc0 = createStandardConstraints();
      PanelPerScope scopePanel = MapSequence.fromMap(myScopePanels).get(runType);
      JBPanel panel = scopePanel.getPanel();
      panelForScopes.add(panel, gc0);
      gc0.fill = GridBagConstraints.NONE;
    }
    borderedPanelForScopes.add(panelForScopes, gc);
    gc.gridx++;
    gc.weightx = 1;
    borderedPanelForScopes.add(new JPanel(), gc);
    JBPanel label1Panel = new JBPanel(new BorderLayout());
    JBLabel label1 = new JBLabel("Per-scope settings:");
    label1Panel.add(label1, BorderLayout.WEST);
    res.add(label1Panel);
    res.add(Box.createVerticalStrut(JBUI.scale(3)));
    SideBorder border = new SideBorder(JBColor.border(), SideBorder.ALL);
    int scaledSz = JBUI.scale(5);
    borderedPanelForScopes.setBorder(new CompoundBorder(border, JBUI.Borders.empty(scaledSz, scaledSz, scaledSz, scaledSz)));
    res.add(borderedPanelForScopes);
    res.add(Box.createVerticalStrut(JBUI.scale(15)));

    return res;
  }

  private ComboBox<JUnitInterpreterRunType> createRunTypeBox() {
    ComboBox<JUnitInterpreterRunType> res;
    res = new ComboBox<JUnitInterpreterRunType>(JUnitInterpreterRunTypes.values());
    addKindActionListeners(res);
    res.setSelectedItem(myRunType);
    res.setRenderer(new DefaultListCellRenderer());
    res.setMaximumSize(res.getPreferredSize());
    return res;
  }

  public interface SelectionChangeListener {
    void selectionChanged();
  }

  public void addSelectionChangeListener(final SelectionChangeListener listener) {
    mySelectionChangeListeners.add(listener);
  }

  private void addKindActionListeners(ComboBox<JUnitInterpreterRunType> box) {
    box.addItemListener(new ItemListener() {
      @Override
      public void itemStateChanged(ItemEvent p1) {
        if (p1.getStateChange() == ItemEvent.SELECTED) {
          myRunType = (JUnitInterpreterRunType) p1.getItem();
          updatePanels();
          for (SelectionChangeListener listener : mySelectionChangeListeners) {
            listener.selectionChanged();
          }
        }
      }
    });
  }

  public JUnitInterpreterRunType getRunType() {
    return myRunType;
  }

  public void updatePanels() {
    myRunTypeBox.setSelectedItem(myRunType);
    for (PanelPerScope panel : Sequence.fromIterable(MapSequence.fromMap(myScopePanels).values())) {
      panel.getPanel().setVisible(false);
    }
    JComponent component = MapSequence.fromMap(myScopePanels).get(myRunType).getPanel();
    component.setVisible(true);
  }


  public void dispose() {
    myModuleChooser.dispose();
    myModelChooser.dispose();
  }

  public void apply(final JUnitInterpreterSettings_Configuration configuration) {
    final List<ITestNodeWrapper> classes = ListSequence.fromList(new ArrayList<ITestNodeWrapper>());
    ListSequence.fromList(classes).addSequence(ListSequence.fromList(myClassesChooser.getItems()));
    final List<ITestNodeWrapper> methods = ListSequence.fromList(new ArrayList<ITestNodeWrapper>());
    ListSequence.fromList(methods).addSequence(ListSequence.fromList(myMethodsChooser.getItems()));
    final ClonableList<String> testMethods = new ClonableList<String>();
    final ClonableList<String> testCases = new ClonableList<String>();
    final Wrappers._T<String> model = new Wrappers._T<String>();
    final Wrappers._T<String> module = new Wrappers._T<String>();
    if (myProject != null) {
      myProject.getModelAccess().runReadAction(() -> {
        for (ITestNodeWrapper testMethod : methods) {
          testMethods.add(PointerUtils.pointerToString(testMethod.getNodePointer()));
        }

        for (ITestNodeWrapper testCase : classes) {
          testCases.add(PointerUtils.pointerToString(testCase.getNodePointer()));
        }

        SModelReference modelRef = myModelChooser.getReference();
        if (modelRef != null) {
          model.value = PersistenceRegistry.getInstance().asString(modelRef);
        }
        SModuleReference moduleRef = myModuleChooser.getReference();
        if (moduleRef != null) {
          module.value = moduleRef.toString();
        }
      });
    }
    configuration.setJUnitRunType(getRunType());

    configuration.setTestMethods(testMethods);
    configuration.setTestCases(testCases);
    configuration.setModelRef(model.value);
    configuration.setModuleRef(module.value);

  }

  public void reset(JUnitInterpreterSettings_Configuration settings) {
    myRunType = settings.getJUnitRunType();

    List<ITestNodeWrapper> classes = loadTestCasesFromPersistence(settings);
    myClassesChooser.setData(classes);

    List<ITestNodeWrapper> methods = loadMethodsFromPersistence(settings);
    myMethodsChooser.setData(methods);

    if (settings.getModelReference() != null) {
      myModelChooser.setModel(settings.getModelReference());
    }

    if (settings.getModuleReference() != null) {
      myModuleChooser.setModule(settings.getModuleReference());
    }

    updatePanels();
  }

  private List<ITestNodeWrapper> loadMethodsFromPersistence(final JUnitInterpreterSettings_Configuration settings) {
    final List<ITestNodeWrapper> methods = ListSequence.fromList(new ArrayList<ITestNodeWrapper>());
    if (myProject != null) {
      myProject.getModelAccess().runReadAction(() -> ListSequence.fromList(TestUtils.wrapPointerStrings(myProject, settings.getTestMethods())).visitAll((it) -> ListSequence.fromList(methods).addElement(it)));
    }
    return methods;
  }

  private List<ITestNodeWrapper> loadTestCasesFromPersistence(final JUnitInterpreterSettings_Configuration settings) {
    final List<ITestNodeWrapper> classes = ListSequence.fromList(new ArrayList<ITestNodeWrapper>());
    if (myProject != null) {
      myProject.getModelAccess().runReadAction(() -> ListSequence.fromList(TestUtils.wrapPointerStrings(myProject, settings.getTestCases())).visitAll((it) -> ListSequence.fromList(classes).addElement(it)));
    }
    return classes;
  }

  public static final class PanelPerScope {
    private static InProcessJBCheckBox createInProcessCheckBox() {
      return new InProcessJBCheckBox("Execute in the same process ");
    }

    private final JBPanel myPanel = new JBPanel();

    public PanelPerScope(JBPanel scopeSourcePanel) {
      BoxLayout layout = new BoxLayout(myPanel, BoxLayout.Y_AXIS);
      myPanel.setLayout(layout);
      int scaled = JBUI.scale(4);
      scopeSourcePanel.setBorder(JBUI.Borders.empty(0, scaled, 0, scaled));
      myPanel.add(Box.createVerticalStrut(scaled));
      myPanel.add(scopeSourcePanel);
      scopeSourcePanel.setAlignmentX(Component.LEFT_ALIGNMENT);
    }


    public JBPanel getPanel() {
      return myPanel;
    }

    public void setShowFunction(Runnable runnable) {
    }
  }
}
