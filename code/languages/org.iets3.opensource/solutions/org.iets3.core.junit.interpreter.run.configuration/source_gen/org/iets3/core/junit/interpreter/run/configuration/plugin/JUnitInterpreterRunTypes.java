package org.iets3.core.junit.interpreter.run.configuration.plugin;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper;
import jetbrains.mps.project.MPSProject;
import org.jetbrains.mps.openapi.util.ProgressMonitor;
import jetbrains.mps.baseLanguage.unitTest.execution.settings.ProjectTestCollector;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.module.SModule;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.unitTest.execution.settings.ModuleTestCollector;
import jetbrains.mps.project.SModuleOperations;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.baseLanguage.unitTest.execution.settings.ModelTestCollector;
import jetbrains.mps.baseLanguage.unitTest.execution.settings.TestUtils;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.execution.lib.PointerUtils;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestNodeWrapperFactory;
import jetbrains.mps.progress.EmptyProgressMonitor;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.Task;
import org.jetbrains.annotations.NotNull;
import com.intellij.openapi.progress.ProgressIndicator;
import jetbrains.mps.progress.ProgressMonitorAdapter;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.model.SModelReference;
import org.jetbrains.mps.openapi.module.SModuleReference;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public enum JUnitInterpreterRunTypes implements JUnitInterpreterRunType {
  PROJECT() {
    @Override
    public List<ITestNodeWrapper> doCollect(JUnitInterpreterSettings_Configuration configuration, MPSProject project, ProgressMonitor monitor) {
      return new ProjectTestCollector(project, monitor, false).collect();
    }
    @Override
    public String check(JUnitInterpreterSettings_Configuration configuration, MPSProject project) {
      // #check is used nowhere
      // TODO: use it
      if (!(this.hasTests(configuration, project))) {
        return "Project does not contain tests.";
      }
      return null;
    }
    public boolean hasTests(JUnitInterpreterSettings_Configuration configuration, MPSProject project) {
      return ListSequence.fromList(new ProjectTestCollector(project, null, true).collect()).isNotEmpty();
    }

  },
  MODULE() {
    @Override
    public List<ITestNodeWrapper> doCollect(JUnitInterpreterSettings_Configuration configuration, MPSProject project, ProgressMonitor monitor) {
      SModule module = getModule(project, configuration.getModuleReference());
      if (module == null) {
        return ListSequence.fromList(new ArrayList<ITestNodeWrapper>());
      }
      return new ModuleTestCollector(module, monitor, false).collect();
    }
    public String check(JUnitInterpreterSettings_Configuration configuration, MPSProject project) {
      if (configuration.getModuleReference() == null) {
        return "Module is not selected.";
      }
      SModule module = getModule(project, configuration.getModuleReference());
      if (module == null) {
        return "The module " + configuration.getModuleReference().getModuleName() + " does not exist in the project " + project;
      }
      if (!(SModuleOperations.isCompileInMps(module))) {
        return "The module's " + module + " compile output is not managed by MPS.";
      }
      if (!(this.hasTests(configuration, project))) {
        return "No tests found in module " + configuration.getModuleReference().getModuleName() + "";
      }
      return null;
    }
    public boolean hasTests(JUnitInterpreterSettings_Configuration configuration, MPSProject project) {
      SModule module = getModule(project, configuration.getModuleReference());
      if (module == null) {
        return false;
      }
      return ListSequence.fromList(new ModuleTestCollector(module, null, true).collect()).isNotEmpty();
    }

  },
  MODEL() {
    @Override
    public List<ITestNodeWrapper> doCollect(JUnitInterpreterSettings_Configuration configuration, MPSProject project, ProgressMonitor monitor) {
      SModel model = getModel(project, configuration.getModelReference());
      if (model == null) {
        return ListSequence.fromList(new ArrayList<ITestNodeWrapper>());
      }
      return new ModelTestCollector(model, monitor, false).collect();
    }
    @Override
    public String check(JUnitInterpreterSettings_Configuration configuration, MPSProject project) {
      if (configuration.getModelReference() == null) {
        return "Model is not selected.";
      }
      SModel model = getModel(project, configuration.getModelReference());
      if (model == null) {
        return "Could not find model " + configuration.getModelReference().getModelName();
      }
      SModule module = model.getModule();
      if (!(SModuleOperations.isCompileInMps(module))) {
        return "The module's " + module + " (which is hosting the model " + model.getName().getSimpleName() + ") compile output is not managed by MPS.";
      }
      if (!(this.hasTests(configuration, project))) {
        return "No tests found in model " + configuration.getModelReference().getName() + ".";
      }
      return null;
    }
    @Override
    public boolean hasTests(JUnitInterpreterSettings_Configuration configuration, MPSProject project) {
      SModel model = getModel(project, configuration.getModelReference());
      if (model == null) {
        return false;
      }
      return ListSequence.fromList(new ModelTestCollector(model, null, true).collect()).isNotEmpty();
    }

  },
  NODE() {
    @Override
    public List<ITestNodeWrapper> doCollect(JUnitInterpreterSettings_Configuration configuration, MPSProject project, ProgressMonitor monitor) {
      return TestUtils.wrapPointerStrings(project, configuration.getTestCases());
    }
    public String check(JUnitInterpreterSettings_Configuration configuration, MPSProject project) {
      if ((configuration.getTestCases() == null || configuration.getTestCases().isEmpty())) {
        return "Classes list is empty.";
      }
      if (configuration.getTestCases() != null) {
        for (String testCase : configuration.getTestCases()) {
          SNodeReference pointer = PointerUtils.stringToPointer(testCase);
          if (pointer != null) {
            SNode testNode = pointer.resolve(project.getRepository());
            if (testNode != null) {
              SModel model = testNode.getModel();
              SNode module = SModelOperations.getModuleStub(model);
              if (!(SPropertyOperations.getBoolean(module, PROPS.compileInMPS$2Q_X))) {
                return "The module's " + SNodeOperations.present(module) + " compile output is not managed by MPS.";
              }
            }
            if (testNode == null || TestNodeWrapperFactory.tryToWrap(testNode) == null) {
              return "Could not find test case for id " + testCase + ".";
            }
          }
        }
      }
      return null;
    }
    public boolean hasTests(JUnitInterpreterSettings_Configuration configuration, MPSProject project) {
      return ListSequence.fromList(this.doCollect(configuration, project, new EmptyProgressMonitor())).isNotEmpty();
    }

  },
  METHOD() {
    @Override
    public List<ITestNodeWrapper> doCollect(JUnitInterpreterSettings_Configuration configuration, MPSProject project, ProgressMonitor monitor) {
      return TestUtils.wrapPointerStrings(project, configuration.getTestMethods());
    }
    @Override
    public String check(JUnitInterpreterSettings_Configuration configuration, MPSProject project) {
      if ((configuration.getTestMethods() == null || configuration.getTestMethods().isEmpty())) {
        return "Methods list is empty.";
      }
      if (configuration.getTestMethods() != null) {
        for (String method : configuration.getTestMethods()) {
          SNodeReference pointer = PointerUtils.stringToPointer(method);
          if (pointer != null) {
            SNode testMethodNode = pointer.resolve(project.getRepository());
            if (testMethodNode != null) {
              SModel model = testMethodNode.getModel();
              SNode module = SModelOperations.getModuleStub(model);
              if (!(SPropertyOperations.getBoolean(module, PROPS.compileInMPS$2Q_X))) {
                return "The module's " + SNodeOperations.present(module) + " compile output is not managed by MPS.";
              }
            }
            if (testMethodNode == null || TestNodeWrapperFactory.tryToWrap(testMethodNode) == null) {
              return "Could not find test method for id " + method + ".";
            }
          }
        }
      }
      return null;
    }
    @Override
    public boolean hasTests(JUnitInterpreterSettings_Configuration configuration, MPSProject project) {
      return ListSequence.fromList(this.doCollect(configuration, project, new EmptyProgressMonitor())).isNotEmpty();
    }

  };

  private JUnitInterpreterRunTypes() {
  }

  @Override
  public final List<ITestNodeWrapper> collect(final JUnitInterpreterSettings_Configuration configuration, final MPSProject project) {
    final Wrappers._T<List<ITestNodeWrapper>> result = new Wrappers._T<List<ITestNodeWrapper>>();
    ProgressManager.getInstance().run(new Task.Modal(project.getProject(), "Collecting Tests to Run", true) {
      @Override
      public void run(@NotNull ProgressIndicator indicator) {
        final ProgressMonitor monitor = new ProgressMonitorAdapter(indicator);
        project.getModelAccess().runReadAction(() -> result.value = ListSequence.fromList(doCollect(configuration, project, monitor)).toList());
      }
    });
    return result.value;
  }

  @Nullable
  private static SModel getModel(Project mpsProject, SModelReference model) {
    if (model == null) {
      return null;
    }
    return model.resolve(mpsProject.getRepository());
  }

  @Nullable
  private static SModule getModule(Project mpsProject, SModuleReference module) {
    if (module == null) {
      return null;
    }
    return module.resolve(mpsProject.getRepository());
  }

  private static final class PROPS {
    /*package*/ static final SProperty compileInMPS$2Q_X = MetaAdapterFactory.getProperty(0x86ef829012bb4ca7L, 0x947f093788f263a9L, 0x5869770da61dfe1eL, 0x5869770da61dfe24L, "compileInMPS");
  }
}
