package org.iets3.core.junit.interpreter.run.configuration.plugin;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.unitTest.execution.server.CommandOutputStream;
import org.junit.runner.Description;
import jetbrains.mps.baseLanguage.unitTest.execution.TestEventMessage;
import org.junit.runner.Result;
import org.junit.runner.notification.Failure;
import org.iets3.core.expr.tests.behavior.EvalResult;
import org.jetbrains.annotations.NotNull;

/**
 * Note: This was simply copied and modified from DefaultRunListener
 * 
 * JUnit test listener that spits out control sequences into supplied stream. 
 * These control sequences are for external process to receive JUnit events.
 * 
 * for the explicit contract for the events
 * see https://junit.org/junit4/javadoc/4.12/org/junit/runner/notification/RunListener.html
 */
public class InterpreterRunListener implements IInterpreterRunListener {
  private CommandOutputStream myOutput;
  private Description descriptionOnStartRun;

  private void flush() {
    System.out.flush();
    System.err.flush();
  }

  @Override
  public void testRunStarted(Description description) {
    descriptionOnStartRun = description;
    printSyncToken(TestEventMessage.START_TESTRUN, description);
    flush();
  }

  @Override
  public void testRunFinished(@SuppressWarnings("unused") Result result) {
    printSyncToken(TestEventMessage.FINISH_TESTRUN, descriptionOnStartRun);
    flush();
  }

  @Override
  public void testFinished(Description description) {
    printSyncToken(TestEventMessage.FINISH_TEST, description);
    flush();
  }

  @Override
  public void testFailure(Failure failure) {
    printSyncToken(TestEventMessage.FAILURE_TEST_BEGIN, failure.getDescription());
    flush();
  }

  public void testFailureForEvalResult(Description description, EvalResult evalResult) {
    if (evalResult.getException() != null) {
      testFailure(new Failure(description, evalResult.getException()));
    } else {
      printSyncToken(TestEventMessage.FAILURE_TEST_BEGIN, description);
      System.out.println(evalResult.getErrorMessage());
    }
    flush();
  }

  @Override
  public void testAssumptionFailure(Failure failure) {
    printSyncToken(TestEventMessage.ASSUMPTION_FAILURE_TEST_PREFIX, failure.getDescription());
    flush();
  }

  @Override
  public void testIgnored(Description description) {
    printSyncToken(TestEventMessage.IGNORE_FAILURE_TEST_PREFIX, description);
    flush();
  }

  @Override
  public void testStarted(Description description) {
    if (descriptionOnStartRun == null) {
      descriptionOnStartRun = description;
      testRunStarted(descriptionOnStartRun);
    }
    printSyncToken(TestEventMessage.START_TEST, description);
    flush();
  }

  private void printSyncToken(@NotNull String tokenPrefix, @NotNull Description description) {
    StringBuilder builder = new StringBuilder();
    builder.append(tokenPrefix);
    // Beware, description.getTestClass may be null.
    builder.append(description.getClassName());
    String methodName = description.getMethodName();
    if (methodName != null) {
      builder.append(':').append(methodName);
    }
    Runtime runtime = Runtime.getRuntime();
    builder.append(":memory=").append(runtime.totalMemory() - runtime.freeMemory());
    builder.append(":time=").append(System.currentTimeMillis());
    synchronized (myOutput) {
      myOutput.writeCommand(builder.toString());
      myOutput.flushSafe();
    }
  }
  @Override
  public void Init(CommandOutputStream out) {
    myOutput = out;
  }
}
