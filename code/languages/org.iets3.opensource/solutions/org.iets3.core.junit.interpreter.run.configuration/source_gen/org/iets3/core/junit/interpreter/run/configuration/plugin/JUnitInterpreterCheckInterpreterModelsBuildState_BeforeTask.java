package org.iets3.core.junit.interpreter.run.configuration.plugin;

/*Generated by MPS */

import jetbrains.mps.execution.api.configurations.BaseMpsBeforeTaskProvider;
import jetbrains.mps.logging.Logger;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.project.Project;
import com.intellij.execution.runners.ExecutionEnvironment;
import jetbrains.mps.ide.project.ProjectHelper;
import jetbrains.mps.generator.ModelGenerationStatusManager;
import jetbrains.mps.smodel.ModelAccessHelper;
import jetbrains.mps.smodel.ModelDependencyResolver;
import jetbrains.mps.smodel.language.LanguageRegistry;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.jetbrains.mps.openapi.module.SModule;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.baseLanguage.logging.rt.LogContext;
import com.intellij.notification.Notification;
import com.intellij.notification.NotificationType;
import com.intellij.notification.Notifications;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class JUnitInterpreterCheckInterpreterModelsBuildState_BeforeTask extends BaseMpsBeforeTaskProvider<JUnitInterpreterCheckInterpreterModelsBuildState_BeforeTask.JUnitInterpreterCheckInterpreterModelsBuildState_BeforeTask_RunTask> {
  private static final Logger LOG = Logger.getLogger(JUnitInterpreterCheckInterpreterModelsBuildState_BeforeTask.class);
  public static final Key<JUnitInterpreterCheckInterpreterModelsBuildState_BeforeTask_RunTask> KEY = Key.create("org.iets3.core.junit.interpreter.run.configuration.plugin.JUnitInterpreterCheckInterpreterModelsBuildState_BeforeTask");

  public JUnitInterpreterCheckInterpreterModelsBuildState_BeforeTask() {
    super("JUnitInterpreterCheckInterpreterModelsBuildState", "Warn on non current Interpreter models");
  }

  protected JUnitInterpreterCheckInterpreterModelsBuildState_BeforeTask_RunTask createTaskImpl() {
    return new JUnitInterpreterCheckInterpreterModelsBuildState_BeforeTask_RunTask();
  }

  public Key<JUnitInterpreterCheckInterpreterModelsBuildState_BeforeTask_RunTask> getId() {
    return KEY;
  }

  public static class JUnitInterpreterCheckInterpreterModelsBuildState_BeforeTask_RunTask extends BaseMpsBeforeTaskProvider.BaseMpsBeforeRunTask<JUnitInterpreterCheckInterpreterModelsBuildState_BeforeTask_RunTask> {

    public JUnitInterpreterCheckInterpreterModelsBuildState_BeforeTask_RunTask() {
      super(KEY);
    }

    public boolean configure() {
      return true;
    }

    public boolean execute(Project project, ExecutionEnvironment environment) {
      final jetbrains.mps.project.Project mpsProject = ProjectHelper.fromIdeaProject(project);
      if (mpsProject == null) {
        if (LOG.isErrorLevel()) {
          LOG.error("No project given to evaluate tests.");
        }
        return false;
      }
      final ModelGenerationStatusManager statusManager = mpsProject.getComponent(ModelGenerationStatusManager.class);
      if (statusManager == null) {
        if (LOG.isErrorLevel()) {
          LOG.error("Could not load ModelGenerationStatusManager");
        }
        return false;
      }
      ModelAccessHelper helper = new ModelAccessHelper(mpsProject.getRepository());
      final ModelDependencyResolver dependencyResolver = new ModelDependencyResolver(LanguageRegistry.getInstance(mpsProject.getRepository()), mpsProject.getRepository());
      final Set<SModel> modelsToBeGenerated = SetSequence.fromSet(new HashSet<SModel>());
      helper.runReadAction(() -> {
        for (SModule module : ListSequence.fromList(mpsProject.getProjectModules())) {
          Iterable<SModel> models = (Iterable<SModel>) module.getModels();
          for (SModel model : Sequence.fromIterable(models).toList()) {
            if (ListSequence.fromList(SModelOperations.roots(model, CONCEPTS.Interpreter$pR)).isNotEmpty()) {
              if (statusManager.generationRequired(model)) {
                SetSequence.fromSet(modelsToBeGenerated).addElement(model);
              }
              Iterable<SModel> directImports = dependencyResolver.directImports(model);
              SetSequence.fromSet(modelsToBeGenerated).addSequence(Sequence.fromIterable(directImports).where((importedModel) -> !(importedModel.isReadOnly()) && statusManager.generationRequired(importedModel)));
            }
          }
        }
      });
      if (SetSequence.fromSet(modelsToBeGenerated).count() > 0) {
        SetSequence.fromSet(modelsToBeGenerated).visitAll((it) -> LogContext.with(JUnitInterpreterCheckInterpreterModelsBuildState_BeforeTask.class, null, null, it).warning("Model for interpreter : '" + SModelOperations.getModelName(it) + "' was changed but not build."));
        Notification notification = new Notification("", "JUnit Interpreter Tests", "Interpreter models were changed but not build! See Messages Tool Window for details.", NotificationType.WARNING);
        Notifications.Bus.notify(notification);
      }
      return true;
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Interpreter$pR = MetaAdapterFactory.getConcept(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x778ee47a6de672eaL, "com.mbeddr.mpsutil.interpreter.structure.Interpreter");
  }
}
