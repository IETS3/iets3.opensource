package org.iets3.core.junit.interpreter.run.configuration.plugin;

/*Generated by MPS */

import jetbrains.mps.execution.configurations.implementation.plugin.plugin.JUnitProcessStarter;
import jetbrains.mps.logging.Logger;
import java.util.concurrent.TimeUnit;
import java.util.List;
import jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper;
import jetbrains.mps.execution.configurations.implementation.plugin.plugin.FakeProcess;
import jetbrains.mps.execution.configurations.implementation.plugin.plugin.TestInProcessRunState;
import jetbrains.mps.project.MPSProject;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.execution.configurations.implementation.plugin.plugin.RunStateEnum;
import com.intellij.execution.process.ProcessHandler;
import com.intellij.execution.ExecutionException;
import xml4JUnit.TestExecutorConfigForIDE;
import java.util.concurrent.Future;
import jetbrains.mps.execution.configurations.implementation.plugin.plugin.FakeProcessHandler;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.TestMode;
import jetbrains.mps.RuntimeFlags;
import jetbrains.mps.baselanguage.unitTest.execution.launcher.DefaultTestExecutor;
import com.intellij.util.WaitFor;
import org.jetbrains.annotations.Nullable;
import java.io.OutputStream;
import com.intellij.execution.process.ProcessOutputTypes;

public class JUnitInterpreterProcessRunStarter implements JUnitProcessStarter {
  private static final Logger LOG = Logger.getLogger(JUnitInterpreterProcessRunStarter.class);
  private static final int MSECS_TO_WAIT_FOR_START = (int) TimeUnit.SECONDS.toMillis(500);
  private final List<ITestNodeWrapper> wrapper;
  private final FakeProcess myFakeProcess = new FakeProcess();
  private final TestInProcessRunState myTestProcessRunState;
  private final MPSProject myMPSProject;

  public JUnitInterpreterProcessRunStarter(@NotNull MPSProject mpsProject, @NotNull JUnitInterpreterTest_Configuration runConfiguration, @NotNull Iterable<ITestNodeWrapper> testNodeWrappers) {
    myMPSProject = mpsProject;
    wrapper = Sequence.fromIterable(testNodeWrappers).toList();
    myTestProcessRunState = TestInProcessRunState.getInstance((mpsProject).getProject());
  }

  private synchronized boolean checkExecutionIsPossible() {
    boolean isPossible = myTestProcessRunState.advance(RunStateEnum.IDLE, RunStateEnum.INITIALIZED);
    return isPossible;
  }

  @Override
  public ProcessHandler execute() throws ExecutionException {
    if (!(checkExecutionIsPossible())) {
      return new EmptyProcessHandler();
    }
    final JUnitInterpreterExecutor executor = new JUnitInterpreterExecutor(myMPSProject.getRepository(), wrapper, new TestExecutorConfigForIDE(() -> myTestProcessRunState.isTerminating()));
    final Future<?> future = doExecute(executor);

    // can use TestInProcessRunState instead of both process and future parameter, isDone == TERMINATED, startNotify() == INITIALIZED -> READYTOEXECUTE
    // Alternatively, FakeProcess.init may do INITIALIZED -> READYTOEXECUTE, and rely on default ProcessHandler.isProcessTerminated implementation instead of Future.isDone
    final FakeProcessHandler process = new FakeProcessHandler(myFakeProcess, future) {
      @Override
      public void startNotify() {
        super.startNotify();
        setReady();
      }

      @Override
      protected void requestTerminate() {
        if (!(myTestProcessRunState.isTerminated())) {
          myTestProcessRunState.advance(RunStateEnum.RUNNING, RunStateEnum.TERMINATING);
        }
      }
    };
    return process;
  }

  private Future<?> doExecute(final JUnitInterpreterExecutor executor) {
    return ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {
      @Override
      public void run() {
        TestMode oldTestMode = RuntimeFlags.getTestMode();
        // Though there's dedicated JUnit runner in NodeWrappersTestsContributor that provides proper in-process TestRunner runner for BaseTransformationTest instances,
        // it doesn't hurt to have this flag set anyway, just in case anyone asks if we are TestMode.isInsideTestEnvironment
        RuntimeFlags.setTestMode(TestMode.IN_PROCESS);
        try {
          waitUnlessProcessIsReady();
          assert myTestProcessRunState.isReady();
          executor.init();
          if (LOG.isWarningLevel()) {
            LOG.warning("Be aware of the execution of your own test code and its consequences when running tests in-process. " + "The code is being executed within the current MPS environment and might do a lot of damage if written without caution.");
          }
          if (LOG.isInfoLevel()) {
            LOG.info("Executing tests in-process");
          }
          myTestProcessRunState.advance(RunStateEnum.READYTOEXECUTE, RunStateEnum.RUNNING);
          executor.execute();
          // regular test execution ends in RUNNING state. If we are in TERMINATING state here already, it means PH.requestTerminate triggered execution stop.
          boolean cancelled = myTestProcessRunState.isTerminating();
          myTestProcessRunState.advance(RunStateEnum.RUNNING, RunStateEnum.TERMINATING);
          if (executor.getExecutionError() != null) {
            myFakeProcess.setExitCode(DefaultTestExecutor.EXIT_CODE_FOR_EXCEPTION);
          } else if (cancelled) {
            myFakeProcess.setExitCode(FakeProcess.TERMINATION_CODE);
          } else {
            myFakeProcess.setExitCode(executor.getFailureCount());
          }
          // copied from TestInProcessExecutor#terminateProcess(int), though not sure I see the point in TestEventsDispatcher use
          String terminateMessage = "in-process test execution finished with exit code " + myFakeProcess.exitValue();
          if (LOG.isInfoLevel()) {
            LOG.info(terminateMessage);
          }
          // once this Future is completed (isDone() == true), FakeProcessHandler terminates and process listeners
          // have a change to notify others (e.g. TestRunState though UnitTestProcessListener with TestEventsDispatcher)
        } finally {
          RuntimeFlags.setTestMode(oldTestMode);
          myTestProcessRunState.set(RunStateEnum.TERMINATED);
          JUnitInterpreterProcessRunStarter.this.dispose();
        }
      }
    });
  }

  /*package*/ void setReady() {
    myTestProcessRunState.advance(RunStateEnum.INITIALIZED, RunStateEnum.READYTOEXECUTE);
  }

  /*package*/ void waitUnlessProcessIsReady() {
    // pooled thread waits for IDEA to fire off execution via ProcessHandler.startNotify
    new WaitFor(MSECS_TO_WAIT_FOR_START) {
      @Override
      protected boolean condition() {
        return myTestProcessRunState.isReady();
      }
    };
    if (!(myTestProcessRunState.isReady())) {
      throw new IllegalStateException("Process is not ready");
    }
  }

  private void dispose() {
    // BaseOSProcessHandler waits for the process to be destroyed (FakeProcess.waitFor), and then dispatches ProcessHandler.notifyProcessTerminated
    myFakeProcess.destroy();
    myTestProcessRunState.reset();
  }

  private class EmptyProcessHandler extends ProcessHandler {
    protected void destroyProcessImpl() {
      //  shall never get here as the process is terminated from the very start
    }

    protected void detachProcessImpl() {
      //  shall never get here as the process is terminated from the very start
    }

    public boolean detachIsDefault() {
      return false;
    }

    @Nullable
    public OutputStream getProcessInput() {
      return null;
    }

    @Override
    public boolean isProcessTerminated() {
      return true;
    }

    @Override
    public void startNotify() {
      super.startNotify();
      String terminateMessage = "Only one test instance is allowed to run in process.\n" + "To run in the outer process change the corresponding property in the junit run configuration.\n" + "Process finished with exit code " + -1 + ".\n";
      notifyTextAvailable(terminateMessage, ProcessOutputTypes.STDERR);
      this.notifyProcessTerminated(-1);
    }
  }
}
