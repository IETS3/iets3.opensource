package xml4JUnit;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import jetbrains.mps.core.platform.Platform;
import jetbrains.mps.smodel.MPSModuleRepository;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.project.PathMacros;
import java.util.Set;
import jetbrains.mps.baseLanguage.unitTest.execution.client.ITestNodeWrapper;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.baseLanguage.unitTest.execution.client.TestNodeWrapperFactory;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.iets3.core.junit.interpreter.run.configuration.plugin.JUnitInterpreterExecutor;
import java.util.HashSet;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class TestModelExecutor {
  private static final Logger LOG = Logger.getLogger(TestModelExecutor.class);

  private TestExecutorConfigForCommandLine config;
  private Platform platform;
  private MPSModuleRepository repo;
  private String evaluationOutputPath;

  public TestModelExecutor(@NotNull Platform platform, @NotNull TestExecutorConfigForCommandLine config) {
    this.config = config;
    this.platform = platform;
  }

  public boolean checkExecutionPossible() {
    repo = platform.findComponent(MPSModuleRepository.class);
    if (repo == null) {
      if (LOG.isErrorLevel()) {
        LOG.error("Repository not found!");
      }
      return false;
    }
    PathMacros pathMacros = platform.findComponent(PathMacros.class);
    if (pathMacros == null) {
      if (LOG.isErrorLevel()) {
        LOG.error("Could not get required path macros!");
      }
      return false;
    }
    Set<String> macroNames = pathMacros.getNames();
    if (!(macroNames.contains(config.getOutputPathMacroName()))) {
      if (LOG.isErrorLevel()) {
        LOG.error("1. You need to specify '" + config.getOutputPathMacroName() + "' in the macros of your build script.", new IllegalArgumentException());
      }
      if (LOG.isErrorLevel()) {
        LOG.error("2. You need to refer the macro '" + config.getOutputPathMacroName() + "' in the " + config.get(config.keyBuildMacroRef) + " within " + config.get(config.keyCustomRunnerAspect), new IllegalArgumentException());
      }
      if (LOG.isErrorLevel()) {
        LOG.error("\tCurrently found macros:");
      }
      macroNames.forEach((name) -> {
        if (LOG.isErrorLevel()) {
          LOG.error("\t" + name);
        }
      });
      return false;
    }
    evaluationOutputPath = pathMacros.getValue(config.getOutputPathMacroName());
    if (((evaluationOutputPath == null ? null : evaluationOutputPath.trim())).length() == 0) {
      if (LOG.isErrorLevel()) {
        LOG.error("The path variable'" + config.getOutputPathMacroName() + " must contain a legal path");
      }
      return false;
    }
    return true;
  }

  public Iterable<ITestNodeWrapper> getTestableNodes() {
    Iterable<ITestNodeWrapper> wrappedTestNodes = SetSequence.fromSet(getTestItemContainers(repo)).select((final SNode it) -> {
      final Wrappers._T<ITestNodeWrapper> wrapper = new Wrappers._T<ITestNodeWrapper>();
      final TestNodeWrapperFactory tnf = new TestNodeWrapperFactory(platform);
      repo.getModelAccess().runReadAction(() -> wrapper.value = tnf.tryToWrap(it));
      return wrapper.value;
    }).where(new NotNullWhereFilter());
    return wrappedTestNodes;
  }

  public void executeTestsByInterpreter(Iterable<ITestNodeWrapper> wrappedTestNodes, ICustomRunnerConfig config) {
    if (Sequence.fromIterable(wrappedTestNodes).count() == 0) {
      if (LOG.isWarningLevel()) {
        LOG.warning("No Nodes of concept 'ITestItemContainer' was found!");
      }
      return;
    }
    JUnitInterpreterExecutor executor = new JUnitInterpreterExecutor(repo, Sequence.fromIterable(wrappedTestNodes).toList(), config);
    executor.execute();
    config.getReporter().writeToFiles(evaluationOutputPath, config.getReportFileNamePrefix());
  }

  private Set<SNode> getTestItemContainers(final MPSModuleRepository repo) {
    final Set<SNode> testItemContainers = SetSequence.fromSet(new HashSet<SNode>());
    repo.getModelAccess().runReadAction(() -> {
      for (SModule existingModule : Sequence.fromIterable(repo.getModules())) {
        for (SModel mdl : existingModule.getModels()) {
          ListSequence.fromList(SModelOperations.nodes(mdl, CONCEPTS.ITestItemContainer$ow)).visitAll((it) -> SetSequence.fromSet(testItemContainers).addElement(it));
        }
      }
    });
    return testItemContainers;
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept ITestItemContainer$ow = MetaAdapterFactory.getInterfaceConcept(0xd441fba0f46b43cdL, 0xb723dad7b65da615L, 0x527c70c5bae4dd04L, "org.iets3.core.expr.tests.structure.ITestItemContainer");
  }
}
