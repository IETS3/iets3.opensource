package org.iets3.core.expr.base.runtime.runtime;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.iets3.core.expr.base.shared.runtime.INixValue;
import org.iets3.core.expr.base.plugin.NoneValue;
import java.util.LinkedList;
import java.math.BigDecimal;
import java.math.BigInteger;
import com.mbeddr.mpsutil.interpreter.rt.IContext;
import com.mbeddr.mpsutil.interpreter.rt.ComputationTrace;
import org.iets3.core.expr.base.plugin.ConstraintFailedException;

public class NixSupport {

  private List<Object> values = ListSequence.fromList(new ArrayList<Object>());
  private Map<Object, Object> replacements = MapSequence.fromMap(new HashMap<Object, Object>());
  private Object overridingResult = null;
  private SNode node;
  private _FunctionTypes._return_P1_E0<? extends Object, ? super NixSupport> calculator;

  public NixSupport(Object value, SNode node, _FunctionTypes._return_P1_E0<? extends Object, ? super NixSupport> calculator) {
    ListSequence.fromList(values).addElement(value);
    this.node = node;
    this.calculator = calculator;
  }

  public NixSupport(Object value1, Object value2, SNode node, _FunctionTypes._return_P1_E0<? extends Object, ? super NixSupport> calculator) {
    this(value1, node, calculator);
    ListSequence.fromList(values).addElement(value2);
  }

  public NixSupport(Object value1, Object value2, Object value3, SNode node, _FunctionTypes._return_P1_E0<? extends Object, ? super NixSupport> calculator) {
    this(value1, value2, node, calculator);
    ListSequence.fromList(values).addElement(value3);
  }

  public NixSupport(Iterable<Object> values, SNode node, _FunctionTypes._return_P1_E0<? extends Object, ? super NixSupport> calculator) {
    ListSequence.fromList(this.values).addSequence(Sequence.fromIterable(values));
    this.node = node;
    this.calculator = calculator;
  }

  private Object process() {
    return NSF.resolveMapper().process(this);
  }

  public Object overrideResult(Object res) {
    return overridingResult = res;
  }

  public boolean isNix(int index) {
    return ListSequence.fromList(values).getElement(index) instanceof INixValue;
  }

  public Object getFirstNonNix() {
    return ListSequence.fromList(values).findFirst((it) -> !(it instanceof INixValue));
  }

  public boolean anyIsNix() {
    return ListSequence.fromList(values).any((it) -> it instanceof INixValue);
  }

  public boolean allAreNix() {
    return ListSequence.fromList(values).all((it) -> it instanceof INixValue);
  }

  public boolean anyIsNone() {
    return ListSequence.fromList(values).any((it) -> it instanceof NoneValue);
  }

  public boolean allAreNone() {
    return ListSequence.fromList(values).all((it) -> it instanceof NoneValue);
  }

  public Object getReplaced(int index) {
    Object n = MapSequence.fromMap(replacements).get(index);
    if (n != null) {
      return n;
    }
    return ListSequence.fromList(values).getElement(index);
  }

  public Object get(int index) {
    return getReplaced(index);
  }

  public Iterable<Object> getAll() {
    List<Object> result = ListSequence.fromList(new LinkedList<Object>());
    for (int i = 0; i < ListSequence.fromList(values).count(); i++) {
      ListSequence.fromList(result).addElement(this.get(i));
    }
    return result;
  }

  public BigDecimal getBigD(int index) {
    return (BigDecimal) castUp(get(index), BigDecimal.class);
  }

  public boolean getBool(int index) {
    return (Boolean) castUp(get(index), Boolean.class);
  }

  public String getString(int index) {
    return get(index) + "";
  }

  public BigInteger getBigI(int index) {
    return (BigInteger) castUp(get(index), BigInteger.class);
  }

  public boolean hasOverridingResult() {
    return overridingResult != null;
  }

  public Object getOverridingResult() {
    return overridingResult;
  }

  public Object run() {
    process();
    if (overridingResult != null) {
      return overridingResult;
    }
    return calculator.invoke(this);
  }

  public Object runWithContext(IContext ctx, ComputationTrace trace) {
    try {
      process();
      if (overridingResult != null) {
        return overridingResult;
      }
      return calculator.invoke(this);
    } catch (ArithmeticException ex) {
      throw new ConstraintFailedException(ConstraintFailedException.PLAIN, ex.getMessage(), node, ex.getMessage(), ctx, trace);
    }
  }

  public Object setReplacement(int index, Object newVal) {
    MapSequence.fromMap(replacements).put(index, newVal);
    return newVal;
  }

  public static Object castUp(Object input, Class targetType) {
    Object mangledInput = input;
    boolean targetIsNumber = Number.class.isAssignableFrom(targetType);
    if (input instanceof Character && targetIsNumber) {
      mangledInput = Integer.valueOf(((Character) input));
    }
    String msg = "don't know how to cast up from " + input + " to " + targetType;
    if (mangledInput instanceof Number) {
      Number numberInput = (Number) mangledInput;
      if (targetType == Double.class) {
        return numberInput.doubleValue();
      } else if (targetType == Float.class) {
        return numberInput.floatValue();
      } else if (targetType == Long.class) {
        return numberInput.longValue();
      } else if (targetType == Integer.class) {
        return numberInput.intValue();
      } else if (targetType == Short.class) {
        return numberInput.shortValue();
      } else if (targetType == Character.class) {
        return ((char) numberInput.intValue());
      } else if (targetType == Byte.class) {
        return numberInput.byteValue();
      } else if (targetType == BigInteger.class) {
        if (input instanceof BigInteger) {
          return input;
        } else {
          return BigInteger.valueOf(numberInput.longValue());
        }
      } else if (targetType == BigDecimal.class) {
        if (input instanceof BigDecimal) {
          return input;
        } else if (input instanceof Double || input instanceof Float) {
          return BigDecimal.valueOf(numberInput.doubleValue());
        } else {
          return BigDecimal.valueOf(numberInput.longValue());
        }
      }
    } else if (targetIsNumber) {
      throw new RuntimeException(msg);
    }
    return input;
  }

  public SNode node() {
    return node;
  }

  public int numberOfValues() {
    return ListSequence.fromList(values).count();
  }


}
