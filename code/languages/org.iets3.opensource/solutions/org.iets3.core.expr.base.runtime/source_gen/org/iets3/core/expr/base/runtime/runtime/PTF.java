package org.iets3.core.expr.base.runtime.runtime;

/*Generated by MPS */

import org.iets3.core.expr.base.plugin.PrimitiveTypeMapper;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.model.SNode;
import org.iets3.core.expr.base.plugin.InfHelper;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.typesystem.inference.SubtypingManager;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.ListSequence;

public class PTF {

  private static PrimitiveTypeMapper mapper = null;

  public static PrimitiveTypeMapper resolveMapper() {
    if (mapper == null) {
      ExtensionPoint<PrimitiveTypeMapper> ep = new ExtensionPoint<PrimitiveTypeMapper>("org.iets3.core.expr.base.primitiveTypeMapper");
      Iterable<PrimitiveTypeMapper> sortedMappers = Sequence.fromIterable(ep.getObjects()).sort((it) -> it.getPriorityLevel(), false);
      mapper = Sequence.fromIterable(sortedMappers).first();
      if (mapper == null) {
        throw new RuntimeException("No PrimitiveTypeMapper found, not even the default; include org.iets3.core.expr.simpleTypes in your model.");
      }
    }
    return mapper;
  }

  public static void invalidateCache() {
    mapper = null;
  }

  public static SNode createBooleanType() {
    return resolveMapper().createBooleanType();
  }

  public static SNode createIntegerType(String value) {
    return createIntegerType(value, false);
  }

  public static SNode createIntegerType(String value, boolean isHexadecimal) {
    return resolveMapper().createIntegerType(value, isHexadecimal);
  }

  public static SNode createGenericIntegerType() {
    return resolveMapper().createGenericIntegerType();
  }

  public static SNode createIntegerType(String min, String max) {
    return resolveMapper().createIntegerType(min, max);
  }

  public static SNode createIntegerType(String min, boolean minIsHexadecimal, String max, boolean maxIsHexadecimal) {
    return resolveMapper().createIntegerType(min, minIsHexadecimal, max, maxIsHexadecimal);
  }

  public static SNode createPositiveIntegerType() {
    return resolveMapper().createIntegerType("0", InfHelper.POSINF);
  }

  public static SNode createRealType(String value) {
    return resolveMapper().createRealType(value);
  }

  public static SNode createStringType() {
    return resolveMapper().createStringType();
  }

  public static SNode createEmptyType() {
    return resolveMapper().createEmptyType();
  }

  public static boolean isBooleanType(SNode type) {
    return TypeChecker.getInstance().getSubtypingManager().isSubtype(type, createBooleanType());
  }

  public static boolean isStringType(SNode type) {
    return TypeChecker.getInstance().getSubtypingManager().isSubtype(type, createStringType());
  }

  public static boolean isIntegerType(SNode type) {
    SubtypingManager sm = TypeChecker.getInstance().getSubtypingManager();
    return sm.isSubtype(type, createIntegerType(null)) || sm.isSubtype(type, createGenericIntegerType());
  }

  public static boolean isRealType(SNode type) {
    return resolveMapper().isRealType(type);
  }

  public static boolean isEmptyType(SNode type) {
    return resolveMapper().isEmptyType(type);
  }

  public static boolean isOtherwiseLiteral(SNode expr) {
    return resolveMapper().isOtherwiseLiteral(expr);
  }

  public static SNode createNumberLiteral(String value) {
    return resolveMapper().createNumberLiteral(value);
  }

  public static boolean isTrueLiteral(SNode expr) {
    return resolveMapper().isTrueLiteral(expr);
  }

  public static boolean isFalseLiteral(SNode expr) {
    return resolveMapper().isFalseLiteral(expr);
  }

  public static SNode computeSupertype(List<SNode> types, boolean goToInfinity, SubtypingManager mgr) {
    return resolveMapper().computeSupertype(types, goToInfinity, mgr);
  }

  public static SNode computeSupertype(SNode left, SNode right, boolean goToInfinity, SubtypingManager mgr) {
    List<SNode> types = new ArrayList<SNode>();
    ListSequence.fromList(types).addElement(left);
    ListSequence.fromList(types).addElement(right);
    return resolveMapper().computeSupertype(types, goToInfinity, mgr);
  }

  public static SNode reverseValue(SNode expectedType, Object javaValue) {
    return resolveMapper().reverseValue(expectedType, javaValue);
  }

  public static SNode createFalseLiteral() {
    return resolveMapper().createFalseLiteral();
  }

  public static SNode createTrueLiteral() {
    return resolveMapper().createTrueLiteral();
  }

  public static SNode widenToInfinityIfNumber(SNode type) {
    return resolveMapper().widenToInfinityIfNumber(type);
  }

  public static SNode setInfinityPrecisionIfNotInteger(SNode type) {
    return resolveMapper().setInfinitePrecisionIfNotInteger(type);
  }

  public static boolean useCommaInsteadOfDotForDecimals() {
    return resolveMapper().useCommaInsteadOfDotForDecimals();
  }

  public static boolean allowHexadecimalNumbers() {
    return resolveMapper().allowHexadecimalNumbers();
  }

  public static boolean areHexadecimalNumbersSupported(SNode node) {
    return allowHexadecimalNumbers() && resolveMapper().filterHexadecimalSupportingNodes(node);
  }

  public static boolean useParenthesisInsteadOfBracketsForTuples() {
    return resolveMapper().useParenthesisInsteadOfBracketsForTuples();
  }

  public static boolean useStringConstraints() {
    return resolveMapper().useStringConstraints();
  }

}
