package org.iets3.core.expr.base.runtime.runtime;

/*Generated by MPS */


public class Fraction implements Comparable<Fraction> {

  public int numerator;
  public int denominator;

  public static final Fraction ZERO = new Fraction(0);
  public static final Fraction ONE = new Fraction(1);

  public Fraction(int numerator) {
    this(numerator, 1);
  }

  public Fraction(int numerator, int denominator) {
    this.numerator = numerator;
    this.denominator = denominator;
  }

  public Fraction reciprocal() {
    return new Fraction(this.denominator, this.numerator).simplify();
  }

  public Fraction negate() {
    return new Fraction(-this.numerator, this.denominator).simplify();
  }

  public boolean isNonZero() {
    return this.numerator != 0;
  }

  public boolean isPositive() {
    return (this.numerator >= 0 && this.denominator > 0) || (this.numerator < 0 && this.denominator < 0);
  }

  public boolean isNegative() {
    return !(isPositive());
  }

  public boolean isMultipleOf(Fraction that) {
    return (this.numerator * that.denominator) % (this.denominator * that.numerator) == 0;
  }

  @Override
  public String toString() {
    if (this.denominator != 1) {
      return "(" + this.numerator + "/" + this.denominator + ")";
    } else {
      return String.valueOf(this.numerator);
    }
  }

  @Override
  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    } else if (obj == null || obj.getClass() != this.getClass()) {
      return false;
    } else {
      Fraction that = ((Fraction) obj);
      return this.numerator == that.numerator && this.denominator == that.denominator;
    }
  }

  @Override
  public int hashCode() {
    int hash = 1;
    hash = hash * 17 + numerator;
    hash = hash * 31 + denominator;
    return hash;
  }

  private Fraction simplify() {
    int g = gcd(this.numerator, this.denominator);
    Fraction fraction = new Fraction(this.numerator / g, this.denominator / g);
    if (fraction.numerator >= 0 && fraction.denominator < 0) {
      fraction.numerator = -fraction.numerator;
      fraction.denominator = -fraction.denominator;
    }
    return fraction;
  }

  public Fraction multiply(int numerator) {
    return multiply(new Fraction(numerator));
  }

  public Fraction multiply(Fraction that) {
    return new Fraction(this.numerator * that.numerator, this.denominator * that.denominator).simplify();
  }

  public Fraction divide(Fraction that) {
    return this.multiply(that.reciprocal());
  }

  public Fraction add(Fraction that) {
    return new Fraction(this.numerator * that.denominator + this.denominator * that.numerator, this.denominator * that.denominator).simplify();
  }

  public Fraction subtract(Fraction that) {
    return new Fraction(this.numerator * that.denominator - this.denominator * that.numerator, this.denominator * that.denominator).simplify();
  }

  public Fraction sqrt() {
    return new Fraction(this.numerator, this.denominator * 2).simplify();
  }

  public Fraction pow(int power) {
    return new Fraction(this.numerator * power, this.denominator).simplify();
  }

  public int gcd(int a, int b) {
    if (b == 0) {
      return a;
    } else {
      return gcd(b, a % b);
    }
  }

  public int compareTo(Fraction that) {
    // a/b < c/d -> we want to decide whether ad < bc holds
    // however, need to pay attention that if b or d (or both of them) are negative then the operator flips

    int flip = 0;
    if (this.denominator < 0) {
      flip += 1;
    }
    if (that.denominator < 0) {
      flip += 1;
    }

    Integer o1 = this.numerator * that.denominator;
    Integer o2 = this.denominator * that.numerator;

    if (flip == 1) {
      // this is the case that the operator has flipped and it is >
      return o1.compareTo(o2) * -1;
    } else {
      return o1.compareTo(o2);
    }
  }

}
