package org.iets3.core.expr.util.interpreter.plugin;

/*Generated by MPS */

import org.iets3.core.expr.base.behavior.IETS3ExprContext;
import org.jetbrains.mps.openapi.model.SNode;
import com.mbeddr.mpsutil.interpreter.rt.ICoverageAnalyzer;
import com.mbeddr.mpsutil.interpreter.rt.ComputationTrace;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.iets3.core.expr.util.behavior.RangeSpecifier__BehaviorDescriptor;
import java.util.Objects;
import com.mbeddr.mpsutil.interpreter.rt.InvalidValueException;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SConcept;

public class DecTabHelper {

  private IETS3ExprContext ctx;
  private SNode node;
  private ICoverageAnalyzer cov;
  private ComputationTrace trace;
  /**
   * Value set for the node representing a column in the computation trace by this helper. 
   * Knowing the value that is used to indicate that the column was matched is useful for analyses 
   * scenarios like coverage reporting.
   */
  public static final String COLUMN_MATCHED_VALUE = "column matched";
  /**
   * Value set for the node representing a row in the computation trace by this helper. 
   * Knowing the value that is used to indicate that the row was matched is useful for analyses 
   * scenarios like coverage reporting.
   */
  public static final String ROW_MATCHED_VALUE = "row matched";

  public DecTabHelper(SNode node, IETS3ExprContext ctx, ICoverageAnalyzer coverage, ComputationTrace trace) {
    this.ctx = ctx;
    this.node = node;
    this.cov = coverage;
    this.trace = trace;
  }

  public Object exec(SNode expr) {
    return ctx.getRootInterpreter().evaluate(expr, ctx, cov, trace, false);
  }

  public Object runDectab() {
    Object predefXVal = null;
    if (SLinkOperations.getTarget(node, LINKS.predefX$16Jb) != null) {
      predefXVal = exec(SLinkOperations.getTarget(node, LINKS.predefX$16Jb));
    }
    Object predefYVal = null;
    if (SLinkOperations.getTarget(node, LINKS.predefY$bypa) != null) {
      predefYVal = exec(SLinkOperations.getTarget(node, LINKS.predefY$bypa));
    }
    for (final SNode col : ListSequence.fromList(SLinkOperations.getChildren(node, LINKS.colHeaders$3s_N))) {
      Object colVal;

      boolean colTrue = false;
      for (SNode expr : ListSequence.fromList(SLinkOperations.getChildren(col, LINKS.expressions$2RXU))) {
        if (SNodeOperations.isInstanceOf(expr, CONCEPTS.RangeValueExpr$Vq)) {
          // need to add coverage explicitly, as only its copy is evaluated
          ListSequence.fromList(SNodeOperations.getNodeDescendants(col, null, true, new SAbstractConcept[]{})).visitAll((n) -> cov.coverValue(n, null));
          SNode eee = RangeSpecifier__BehaviorDescriptor.createExpression_id1tPb0nsnb6P.invoke(SLinkOperations.getTarget(SNodeOperations.cast(expr, CONCEPTS.RangeValueExpr$Vq), LINKS.range$iA1U), SLinkOperations.getTarget(node, LINKS.predefX$16Jb));
          colVal = exec(eee);
          colTrue = ((boolean) colVal);
        } else if (SNodeOperations.isInstanceOf(expr, CONCEPTS.OtherwiseLiteral$Cj)) {
          colTrue = true;
        } else {
          colVal = exec(expr);
          colTrue = (predefXVal != null ? Objects.equals(predefXVal, colVal) : ((boolean) colVal));
        }
        if (colTrue) {
          break;
        }
      }
      if (colTrue) {
        ComputationTrace colTrace = trace.newChild(col, true, "col " + SNodeOperations.getIndexInParent(col));
        colTrace.setValue(COLUMN_MATCHED_VALUE);
        for (final SNode row : ListSequence.fromList(SLinkOperations.getChildren(node, LINKS.rowHeaders$3rSK))) {
          ComputationTrace rowTrace = trace.newChild(row, true, "row " + SNodeOperations.getIndexInParent(row));

          Object rowVal;
          boolean rowTrue = false;
          for (SNode expr : ListSequence.fromList(SLinkOperations.getChildren(row, LINKS.expressions$2RXU))) {
            if (SNodeOperations.isInstanceOf(expr, CONCEPTS.RangeValueExpr$Vq)) {
              // need to add coverage explicitly, as only its copy is evaluated
              ListSequence.fromList(SNodeOperations.getNodeDescendants(row, null, true, new SAbstractConcept[]{})).visitAll((n) -> cov.coverValue(n, null));
              SNode eee = RangeSpecifier__BehaviorDescriptor.createExpression_id1tPb0nsnb6P.invoke(SLinkOperations.getTarget(SNodeOperations.cast(expr, CONCEPTS.RangeValueExpr$Vq), LINKS.range$iA1U), SLinkOperations.getTarget(node, LINKS.predefY$bypa));
              rowVal = exec(eee);
              rowTrue = ((boolean) rowVal);
            } else if (SNodeOperations.isInstanceOf(expr, CONCEPTS.OtherwiseLiteral$Cj)) {
              // Getting to otherwise means row is true
              rowTrue = true;
            } else {
              rowVal = exec(expr);
              rowTrue = (predefYVal != null ? Objects.equals(predefYVal, rowVal) : ((boolean) rowVal));
            }
            if (rowTrue) {
              break;
            }
          }

          if (rowTrue) {
            rowTrace.setValue(ROW_MATCHED_VALUE);
            SNode c = ListSequence.fromList(SLinkOperations.getChildren(node, LINKS.contents$3yGd)).findFirst((it) -> SLinkOperations.getTarget(it, LINKS.col$3qUK) == col && SLinkOperations.getTarget(it, LINKS.row$3lio) == row);
            if (c != null) {
              return exec(ListSequence.fromList(SLinkOperations.getChildren(c, LINKS.expressions$2RXU)).first());
            }
          }

        }
      }

    }
    if (SLinkOperations.getTarget(node, LINKS.default$x3kk) != null) {
      Object defaultValue = exec(SLinkOperations.getTarget(node, LINKS.default$x3kk));
      trace.newChild(node, true, "default value", defaultValue);
      return defaultValue;
    }
    throw new InvalidValueException(node, "none of the combinations was true", ctx, trace);
  }


  private static final class LINKS {
    /*package*/ static final SContainmentLink predefX$16Jb = MetaAdapterFactory.getContainmentLink(0x8bb1251eeae547abL, 0x984333adfae8edaaL, 0x3a7ea77800c04308L, 0xcde8c60cefc3c13L, "predefX");
    /*package*/ static final SContainmentLink predefY$bypa = MetaAdapterFactory.getContainmentLink(0x8bb1251eeae547abL, 0x984333adfae8edaaL, 0x3a7ea77800c04308L, 0xcde8c60cefe1fe6L, "predefY");
    /*package*/ static final SContainmentLink range$iA1U = MetaAdapterFactory.getContainmentLink(0x8bb1251eeae547abL, 0x984333adfae8edaaL, 0x6d1e5fea0f4a460bL, 0x6d1e5fea0f4a460cL, "range");
    /*package*/ static final SContainmentLink expressions$2RXU = MetaAdapterFactory.getContainmentLink(0x8bb1251eeae547abL, 0x984333adfae8edaaL, 0x3a7ea77800c0430fL, 0x3a7ea77800c04310L, "expressions");
    /*package*/ static final SContainmentLink contents$3yGd = MetaAdapterFactory.getContainmentLink(0x8bb1251eeae547abL, 0x984333adfae8edaaL, 0x3a7ea77800c04308L, 0x3a7ea77800c04349L, "contents");
    /*package*/ static final SReferenceLink row$3lio = MetaAdapterFactory.getReferenceLink(0x8bb1251eeae547abL, 0x984333adfae8edaaL, 0x3a7ea77800c0430eL, 0x3a7ea77800c04339L, "row");
    /*package*/ static final SReferenceLink col$3qUK = MetaAdapterFactory.getReferenceLink(0x8bb1251eeae547abL, 0x984333adfae8edaaL, 0x3a7ea77800c0430eL, 0x3a7ea77800c0433cL, "col");
    /*package*/ static final SContainmentLink rowHeaders$3rSK = MetaAdapterFactory.getContainmentLink(0x8bb1251eeae547abL, 0x984333adfae8edaaL, 0x3a7ea77800c04308L, 0x3a7ea77800c04341L, "rowHeaders");
    /*package*/ static final SContainmentLink colHeaders$3s_N = MetaAdapterFactory.getContainmentLink(0x8bb1251eeae547abL, 0x984333adfae8edaaL, 0x3a7ea77800c04308L, 0x3a7ea77800c04344L, "colHeaders");
    /*package*/ static final SContainmentLink default$x3kk = MetaAdapterFactory.getContainmentLink(0x8bb1251eeae547abL, 0x984333adfae8edaaL, 0x3a7ea77800c04308L, 0x3a7ea77800cef3aeL, "default");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept RangeValueExpr$Vq = MetaAdapterFactory.getConcept(0x8bb1251eeae547abL, 0x984333adfae8edaaL, 0x6d1e5fea0f4a460bL, "org.iets3.core.expr.util.structure.RangeValueExpr");
    /*package*/ static final SConcept OtherwiseLiteral$Cj = MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x6ea1ae96e114065eL, "org.iets3.core.expr.simpleTypes.structure.OtherwiseLiteral");
  }
}
