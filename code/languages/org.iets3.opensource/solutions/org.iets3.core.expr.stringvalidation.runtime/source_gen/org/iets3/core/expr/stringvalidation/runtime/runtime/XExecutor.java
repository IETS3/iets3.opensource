package org.iets3.core.expr.stringvalidation.runtime.runtime;

/*Generated by MPS */

import java.util.List;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import java.util.Objects;
import org.iets3.core.expr.base.runtime.runtime.DefaultNix;
import org.iets3.core.expr.base.shared.runtime.INixValue;

public class XExecutor {



  private class XEnv {
    private List<Map<Object, Object>> data = ListSequence.fromList(new ArrayList<Map<Object, Object>>());
    public XEnv() {
      push();
    }
    public void put(Object key, Object value) {
      MapSequence.fromMap(curr()).put(key, value);
    }
    public Object gettun(Object key) {
      int i = ListSequence.fromList(data).count() - 1;
      while (true) {
        Map<Object, Object> c = ListSequence.fromList(data).getElement(i);
        Object v = MapSequence.fromMap(c).get(key);
        if (v != null) {
          return v;
        }
        i--;
        if (i < 0) {
          return null;
        }
      }
    }
    public void push() {
      ListSequence.fromList(data).addElement(MapSequence.fromMap(new HashMap<Object, Object>()));
    }
    public void pop() {
      ListSequence.fromList(data).removeElementAt(ListSequence.fromList(data).count() - 1);
    }
    public Map<Object, Object> curr() {
      return ListSequence.fromList(data).last();
    }
  }

  private final XValidateStringExpression expr;
  private final XEnv xenv = new XEnv();



  public String makeValidationError(Object finding, String message) {
    return "[" + finding + "|" + message + "]";
  }

  public XExecutor(XValidateStringExpression expr) {
    this.expr = expr;
  }

  private Object runMatch(XAbstractMatch match) {
    if (match instanceof XAllSameCharMatcher) {
      XAllSameCharMatcher allSameChar = (XAllSameCharMatcher) match;
      if (Objects.equals(xenv.gettun(Constants.USE_MATCH_AS_FINDER), true)) {
        List<OccurenceMatchFind> findings = ((List<OccurenceMatchFind>) runMatch(allSameChar.match));
        return ListSequence.fromList(findings).where((it) -> Runtime.allSameChar(it.whatWasFound));
      } else {
        SuccessAndFoundString inner = (SuccessAndFoundString) runMatch(allSameChar.match);
        if (!(inner.success)) {
          return inner;
        }
        return new SuccessAndFoundString(Runtime.allSameChar(inner.found), inner.found.charAt(0));
      }
    } else if (match instanceof XDigitMatch) {
      if (Objects.equals(xenv.gettun(Constants.USE_MATCH_AS_FINDER), true)) {
        String theString = (String) xenv.gettun(Constants.CANDIDATE_STRING);
        return Runtime.findAllDigits(theString);
      } else {
        PositionFind finding = ((PositionFind) xenv.gettun(Constants.POSITION_BASED_FIND));
        if (isEmptyString(finding.whatWasFound)) {
          return new SuccessAndFoundString(false, "");
        } else {
          char c0 = finding.whatWasFound.charAt(0);
          return new SuccessAndFoundString(Character.isDigit(c0), c0 + "");
        }
      }
    } else if (match instanceof XLetterMatch) {
      if (Objects.equals(xenv.gettun(Constants.USE_MATCH_AS_FINDER), true)) {
        String theString = (String) xenv.gettun(Constants.CANDIDATE_STRING);
        return Runtime.findAllLetters(theString);
      } else {
        PositionFind finding = (PositionFind) xenv.gettun(Constants.POSITION_BASED_FIND);
        if (isEmptyString(finding.whatWasFound)) {
          return new SuccessAndFoundString(false, null);
        } else {
          char c0 = finding.whatWasFound.charAt(0);
          return new SuccessAndFoundString(Character.isLetter(c0), c0);
        }
      }
    } else if (match instanceof XNumberMatch) {
      if (Objects.equals(xenv.gettun(Constants.USE_MATCH_AS_FINDER), true)) {
        String theString = (String) xenv.gettun(Constants.CANDIDATE_STRING);
        return Runtime.findAllNumbers(theString);
      } else {
        PositionFind finding = ((PositionFind) xenv.gettun(Constants.POSITION_BASED_FIND));
        if (isEmptyString(finding.whatWasFound)) {
          return new SuccessAndFoundString(false, null);
        } else {
          char c0 = finding.whatWasFound.charAt(0);
          return new SuccessAndFoundString(Character.isDigit(c0), c0 + "");
        }
      }
    } else if (match instanceof XNotLetterOrDigitMatch) {
      if (Objects.equals(xenv.gettun(Constants.USE_MATCH_AS_FINDER), true)) {
        String theString = (String) xenv.gettun(Constants.CANDIDATE_STRING);
        return Runtime.findAllNotLetterOrDigit(theString);
      } else {
        PositionFind finding = ((PositionFind) xenv.gettun(Constants.POSITION_BASED_FIND));
        if (isEmptyString(finding.whatWasFound)) {
          return new SuccessAndFoundString(false, null);
        } else {
          char c0 = finding.whatWasFound.charAt(0);
          return new SuccessAndFoundString(!(Character.isDigit(c0) || Character.isLetter(c0)), c0);
        }
      }
    } else if (match instanceof XSequenceMatch) {
      XSequenceMatch seqMatch = ((XSequenceMatch) match);
      if (Objects.equals(xenv.gettun(Constants.USE_MATCH_AS_FINDER), true)) {
        String candidate = (String) xenv.gettun(Constants.CANDIDATE_STRING);
        List<OccurenceMatchFind> separateFindings = ((List<OccurenceMatchFind>) runMatch(seqMatch.match));
        return Runtime.joinAdjacentFindings(candidate, separateFindings, seqMatch.howOften);
      } else {
        try {
          xenv.push();
          PositionFind finding = ((PositionFind) xenv.gettun(Constants.POSITION_BASED_FIND));
          String substringAtPos = finding.whatWasFound;
          int nextPos = 0;
          for (int i = 0; i < seqMatch.howOften; i++) {
            PositionFind pbf = new PositionFind(nextPos, substringAtPos.substring(nextPos));
            xenv.put(Constants.POSITION_BASED_FIND, pbf);
            SuccessAndFoundString innermatch = ((SuccessAndFoundString) runMatch(seqMatch.match));
            if (!(innermatch.success)) {
              return innermatch;
            }
            nextPos = nextPos + innermatch.length();
          }
          String substring = substringAtPos.substring(0, nextPos);
          return new SuccessAndFoundString(true, substring);
        } finally {
          xenv.pop();
        }
      }
    } else if (match instanceof XSpecificSequenceElementaryMatch) {
      XSpecificSequenceElementaryMatch specSeq = ((XSpecificSequenceElementaryMatch) match);
      if (Objects.equals(xenv.gettun(Constants.USE_MATCH_AS_FINDER), true)) {
        String theString = (String) xenv.gettun(Constants.CANDIDATE_STRING);
        List<OccurenceMatchFind> findings = Runtime.findAllSubstringMatches(theString, specSeq.value);
        return findings;
      } else {
        PositionFind finding = ((PositionFind) xenv.gettun(Constants.POSITION_BASED_FIND));
        return new SuccessAndFoundString(finding.whatWasFound.startsWith(specSeq.value), specSeq.value);
      }
    } else if (match instanceof XOneOfMatch) {
      XOneOfMatch oneOfMatch = ((XOneOfMatch) match);
      if (Objects.equals(xenv.gettun(Constants.USE_MATCH_AS_FINDER), true)) {
        String theString = (String) xenv.gettun(Constants.CANDIDATE_STRING);
        List<OccurenceMatchFind> all = ListSequence.fromList(new ArrayList<OccurenceMatchFind>());
        for (XAbstractMatch m : ListSequence.fromList(oneOfMatch.matches)) {
          ListSequence.fromList(all).addSequence(ListSequence.fromList(Runtime.findAllNotLetterOrDigit(theString)));
        }
        return all;
      } else {
        PositionFind finding = ((PositionFind) xenv.gettun(Constants.POSITION_BASED_FIND));
        for (XAbstractMatch m : ListSequence.fromList(oneOfMatch.matches)) {
          SuccessAndFoundString option = ((SuccessAndFoundString) runMatch(m));
          if (option.success) {
            return option;
          }
        }
        return new SuccessAndFoundString(false, null);
      }
    } else {
      throw new RuntimeException("don't know how to run match " + match.getClass().getName());
    }
  }

  private Object singleMatchOrFirst(Object o) {
    if (o instanceof List) {
      List list = ((List) o);
      if (list.isEmpty()) {
        return null;
      }
      if (list.size() >= 1) {
        return singleMatchOrFirst(list.get(0));
      }
    }
    return o;
  }

  private Object runOccurenceBasedCheck(XAbstractOccurenceBasedCheck check) {
    if (check instanceof XAtPositionCheck) {
      XAtPositionCheck atPosCheck = ((XAtPositionCheck) check);
      OccurenceMatchFind finding = ((OccurenceMatchFind) xenv.gettun(Constants.OCCURENCE_BASED_FINDING));
      XAbstractPositionIndicator pos = atPosCheck.pos;
      if (atPosCheck.kind instanceof XMustBeCheckKind) {
        if (!(Runtime.isFindingAtPosition(finding, pos))) {
          return makeValidationError(finding, "must be at position " + pos);
        }
      }
      if (atPosCheck.kind instanceof XCannotBeCheckKind) {
        if (Runtime.isFindingAtPosition(finding, pos)) {
          return makeValidationError(finding, "cannot be at position " + pos);
        }
      }
      return new DefaultNix();
    } else if (check instanceof XCannotRepeatCheck) {
      XCannotRepeatCheck cannotRepeat = ((XCannotRepeatCheck) check);
      OccurenceMatchFind finding = ((OccurenceMatchFind) xenv.gettun(Constants.OCCURENCE_BASED_FINDING));
      if (cannotRepeat.kind instanceof XMustBeCheckKind) {
        if (finding.textAfterFinding.startsWith(finding.whatWasFound)) {
          return makeValidationError(finding, "must not repeat, but does: " + finding);
        }
      }
      if (cannotRepeat.kind instanceof XCannotBeCheckKind) {
        if (!(finding.textAfterFinding.startsWith(finding.whatWasFound))) {
          return makeValidationError(finding, "must repeat, but does not: " + finding);
        }
      }
      return new DefaultNix();
    } else if (check instanceof XPredecessorCheck) {
      XPredecessorCheck predCheck = ((XPredecessorCheck) check);
      OccurenceMatchFind finding = ((OccurenceMatchFind) xenv.gettun(Constants.OCCURENCE_BASED_FINDING));
      String candidate = ((String) xenv.gettun(Constants.CANDIDATE_STRING));
      int pos = finding.position;
      if (pos == 0) {
        return new DefaultNix();
      }
      try {
        xenv.push();
        xenv.put(Constants.USE_MATCH_AS_FINDER, false);
        PositionFind predecessor = new PositionFind(pos, candidate.substring(pos - 1));
        xenv.put(Constants.POSITION_BASED_FIND, predecessor);
        SuccessAndFoundString r = ((SuccessAndFoundString) singleMatchOrFirst(runMatch(predCheck.match)));
        boolean success = (predCheck.kind instanceof XMustBeCheckKind ? r.success : !(r.success));
        if (r != null && success) {
          return new DefaultNix();
        } else {
          return makeValidationError(predecessor, "was supposed to find " + predCheck.match);
        }
      } finally {
        xenv.pop();
      }
    } else if (check instanceof XSuccessorCheck) {
      XSuccessorCheck succCheck = ((XSuccessorCheck) check);
      OccurenceMatchFind finding = ((OccurenceMatchFind) xenv.gettun(Constants.OCCURENCE_BASED_FINDING));
      String candidate = ((String) xenv.gettun(Constants.CANDIDATE_STRING));
      int pos = finding.endPos();
      if (pos >= candidate.length() - 1) {
        return new DefaultNix();
      }
      try {
        xenv.push();
        xenv.put(Constants.USE_MATCH_AS_FINDER, false);
        PositionFind successor = new PositionFind(pos, candidate.substring(pos + 1));
        xenv.put(Constants.POSITION_BASED_FIND, successor);
        SuccessAndFoundString r = ((SuccessAndFoundString) singleMatchOrFirst(runMatch(succCheck.match)));
        boolean success = (succCheck.kind instanceof XMustBeCheckKind ? r.success : !(r.success));
        if (success) {
          return new DefaultNix();
        } else {
          return makeValidationError(successor, "was supposed to find " + succCheck.match);
        }
      } finally {
        xenv.pop();
      }
    } else if (check instanceof XFailCheck) {
      OccurenceMatchFind finding = ((OccurenceMatchFind) xenv.gettun(Constants.OCCURENCE_BASED_FINDING));
      return makeValidationError(finding, "is not allowed: " + finding);
    } else {
      throw new RuntimeException("don't know how to run check " + check.getClass().getName());
    }
  }

  private List<String> runClause(XAbstractValidationClause clause) {
    List<String> errors = ListSequence.fromList(new ArrayList<String>());
    if (clause instanceof XRangeBasedValidationClause) {
      XRangeBasedValidationClause rangeBased = (XRangeBasedValidationClause) clause;
      String candidate = ((String) xenv.gettun(Constants.CANDIDATE_STRING));
      int posStart = Runtime.getNumericPosition(candidate, rangeBased.posStart);
      int posEnd = Runtime.getNumericPosition(candidate, rangeBased.posEnd);
      for (int i = posStart; i <= posEnd; i++) {
        PositionFind positionFind = Runtime.getStringAtPosition(candidate, i);
        xenv.put(Constants.POSITION_BASED_FIND, positionFind);
        boolean positiveMatch = rangeBased.kind instanceof XMustBeCheckKind;
        boolean didTheMatchMatch = ((SuccessAndFoundString) runMatch(rangeBased.match)).success;
        if (!(didTheMatchMatch) && positiveMatch) {
          ListSequence.fromList(errors).addElement(makeValidationError(positionFind, "didn't find " + rangeBased.match.toString()));
        } else if (didTheMatchMatch && !(positiveMatch)) {
          ListSequence.fromList(errors).addElement(makeValidationError(positionFind, "wasn't supposed to find " + rangeBased.match.toString()));
        }
      }
    } else if (clause instanceof XOccurenceBasedValidationClause) {
      XOccurenceBasedValidationClause occurenceBased = (XOccurenceBasedValidationClause) clause;
      xenv.put(Constants.USE_MATCH_AS_FINDER, true);
      XAbstractMatch theThingToFind = occurenceBased.match;
      List<OccurenceMatchFind> founds = ((List<OccurenceMatchFind>) runMatch(theThingToFind));
      for (OccurenceMatchFind found : ListSequence.fromList(founds)) {
        xenv.put(Constants.OCCURENCE_BASED_FINDING, found);
        for (XAbstractOccurenceBasedCheck check : ListSequence.fromList(occurenceBased.checks).where((it) -> !(it instanceof XMaxCountCheck))) {
          Object error = runOccurenceBasedCheck(check);
          if (!(error instanceof INixValue)) {
            ListSequence.fromList(errors).addElement(((String) error));
          }
        }
      }
      XMaxCountCheck maxCount = ListSequence.fromList(occurenceBased.checks).ofType(XMaxCountCheck.class).first();
      if (maxCount != null) {
        boolean moreFoundThanGiven = ListSequence.fromList(founds).count() > maxCount.value;
        if (maxCount.kind instanceof XMustBeCheckKind && !(moreFoundThanGiven)) {
          ListSequence.fromList(errors).addElement(makeValidationError(maxCount, "more than " + maxCount.value + " required of " + occurenceBased.match));
        } else if (maxCount.kind instanceof XCannotBeCheckKind && moreFoundThanGiven) {
          ListSequence.fromList(errors).addElement(makeValidationError(maxCount, "less than " + maxCount.value + " required of " + occurenceBased.match));
        }
      }
    } else if (clause instanceof XPositionBasedValidationClause) {
      XPositionBasedValidationClause posBased = ((XPositionBasedValidationClause) clause);
      String candidate = ((String) xenv.gettun(Constants.CANDIDATE_STRING));
      int pos = Runtime.getNumericPosition(candidate, posBased.pos);
      PositionFind positionFind = Runtime.getStringAtPosition(candidate, pos);
      xenv.put(Constants.POSITION_BASED_FIND, positionFind);
      boolean positiveMatch = posBased.kind instanceof XMustBeCheckKind;
      boolean didTheMatchMatch = ((SuccessAndFoundString) runMatch(posBased.match)).success;
      if (!(didTheMatchMatch) && positiveMatch) {
        ListSequence.fromList(errors).addElement(makeValidationError(positionFind, "didn't find " + posBased.match.toString()));
      } else if (didTheMatchMatch && !(positiveMatch)) {
        ListSequence.fromList(errors).addElement(makeValidationError(positionFind, "wasn't supposed to find " + posBased.match.toString()));
      }
    } else {
      throw new RuntimeException("don't know how to run clause " + clause.getClass().getName());
    }
    return errors;
  }


  public List<String> run() {
    xenv.put(Constants.CANDIDATE_STRING, expr.candidate);
    List<String> res = ListSequence.fromList(new ArrayList<String>());
    for (XAbstractValidationClause clause : ListSequence.fromList(expr.clauses)) {
      ListSequence.fromList(res).addSequence(ListSequence.fromList(runClause(clause)));
    }
    return res;
  }




  private static boolean isEmptyString(String str) {
    return str == null || str.isEmpty();
  }
}
