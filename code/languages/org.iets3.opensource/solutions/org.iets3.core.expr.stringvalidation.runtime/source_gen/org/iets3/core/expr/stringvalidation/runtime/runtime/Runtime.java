package org.iets3.core.expr.stringvalidation.runtime.runtime;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ArrayUtils;

public class Runtime {

  public static List<OccurenceMatchFind> findAllSubstringMatches(String candidate, String toBeFound) {
    List<OccurenceMatchFind> findings = ListSequence.fromList(new ArrayList<OccurenceMatchFind>());
    int lastMatch = -1;
    do {
      lastMatch = candidate.indexOf(toBeFound, lastMatch + 1);
      if (lastMatch >= 0) {
        ListSequence.fromList(findings).addElement(new OccurenceMatchFind(toBeFound, candidate, lastMatch, candidate.substring(lastMatch + 1)));
      }
    } while (lastMatch >= 0);
    return findings;
  }

  public static List<OccurenceMatchFind> findAllNotLetterOrDigit(String candidate) {
    List<OccurenceMatchFind> findings = ListSequence.fromList(new ArrayList<OccurenceMatchFind>());
    for (int i = 0; i < candidate.length(); i++) {
      char c = candidate.charAt(i);
      if (!(Character.isDigit(c) || Character.isLetter(c))) {
        ListSequence.fromList(findings).addElement(new OccurenceMatchFind(c + "", candidate, i, candidate.substring(i + 1)));
      }
    }
    return findings;
  }

  public static List<OccurenceMatchFind> findAllLetters(String candidate) {
    List<OccurenceMatchFind> findings = ListSequence.fromList(new ArrayList<OccurenceMatchFind>());
    for (int i = 0; i < candidate.length(); i++) {
      char c = candidate.charAt(i);
      if (Character.isLetter(c)) {
        ListSequence.fromList(findings).addElement(new OccurenceMatchFind(c + "", candidate, i, candidate.substring(i + 1)));
      }
    }
    return findings;
  }

  public static List<OccurenceMatchFind> findAllDigits(String candidate) {
    List<OccurenceMatchFind> findings = ListSequence.fromList(new ArrayList<OccurenceMatchFind>());
    for (int i = 0; i < candidate.length(); i++) {
      char c = candidate.charAt(i);
      if (Character.isDigit(c)) {
        ListSequence.fromList(findings).addElement(new OccurenceMatchFind(c + "", candidate, i, candidate.substring(i + 1)));
      }
    }
    return findings;
  }

  public static List<OccurenceMatchFind> findAllNumbers(String candidate) {
    List<OccurenceMatchFind> findings = ListSequence.fromList(new ArrayList<OccurenceMatchFind>());
    Pattern p = Pattern.compile("\\d+");
    Matcher m = p.matcher(candidate);
    while (m.find()) {
      ListSequence.fromList(findings).addElement(new OccurenceMatchFind(m.group() + "", candidate, (m.start()), candidate.substring(m.end())));
    }
    return findings;
  }

  public static PositionFind getStringAtPosition(String candidate, int position) {
    if (position < 0) {
      return new PositionFind(position, "");
    }
    if ((candidate == null || candidate.length() == 0)) {
      return new PositionFind(position, "");
    }
    if (position > candidate.length() - 1) {
      return new PositionFind(position, "");
    }
    String s = candidate.substring(position);
    return new PositionFind(position, s);
  }

  public static PositionFind getStringAtRange(String candidate, int start, int end) {
    String s = candidate.substring(start, end);
    return new PositionFind(start, s);
  }

  public static boolean isFindingAtPosition(OccurenceMatchFind finding, PositionIndicatorEnum indicator, int payload) {
    if (indicator == PositionIndicatorEnum.index) {
      return finding.position == payload;
    }
    if (indicator == PositionIndicatorEnum.first) {
      return finding.position == 0;
    }
    if (indicator == PositionIndicatorEnum.last) {
      return finding.position == finding.foundIn.length() - finding.whatWasFound.length();
    }
    return false;
  }

  public static boolean isFindingAtPosition(OccurenceMatchFind finding, XAbstractPositionIndicator indicator) {
    if (indicator instanceof XPositionIndicatorIndex) {
      return finding.position == ((XPositionIndicatorIndex) indicator).index;
    }
    if (indicator instanceof XPositionIndicatorFirst) {
      return finding.position == 0;
    }
    if (indicator instanceof XPositionIndicatorLast) {
      return finding.position == finding.foundIn.length() - finding.whatWasFound.length();
    }
    return false;
  }

  public static int getNumericPosition(String candidate, PositionIndicatorEnum indicator, int payload) {
    if (indicator == PositionIndicatorEnum.index) {
      return payload;
    }
    if (indicator == PositionIndicatorEnum.first) {
      return 0;
    }
    if (indicator == PositionIndicatorEnum.last) {
      return candidate.length() - 1;
    }
    return -1;
  }

  public static int getNumericPosition(String candidate, XAbstractPositionIndicator indicator) {
    if (indicator instanceof XPositionIndicatorIndex) {
      return ((XPositionIndicatorIndex) indicator).index;
    }
    if (indicator instanceof XPositionIndicatorLast) {
      return candidate.length() - 1;
    }
    return 0;
  }

  public static List<OccurenceMatchFind> joinAdjacentFindings(String candidate, List<OccurenceMatchFind> findings, int minLength) {
    List<OccurenceMatchFind> aSequence = ListSequence.fromList(new ArrayList<OccurenceMatchFind>());
    OccurenceMatchFind lastFinding = null;
    for (int i = 0; i < ListSequence.fromList(findings).count(); i++) {
      OccurenceMatchFind currentFinding = ListSequence.fromList(findings).getElement(i);
      if (lastFinding == null) {
        ListSequence.fromList(aSequence).addElement(currentFinding);
      } else {
        if (ListSequence.fromList(findings).getElement(i).position == lastFinding.endPos() + 1) {
          ListSequence.fromList(aSequence).addElement(currentFinding);
        }
      }
      lastFinding = currentFinding;
    }
    List<OccurenceMatchFind> res = ListSequence.fromList(new ArrayList<OccurenceMatchFind>());
    if (ListSequence.fromList(aSequence).count() >= minLength) {
      String totalText = IterableUtils.join(ListSequence.fromList(aSequence).select((it) -> it.whatWasFound), " ");
      int firstPos = ListSequence.fromList(aSequence).first().position;
      String textAfterwards = candidate.substring(ListSequence.fromList(aSequence).last().endPos() + 1);
      ListSequence.fromList(res).addElement(new OccurenceMatchFind(totalText, candidate, firstPos, textAfterwards));
    }
    if (ListSequence.fromList(findings).count() > 1) {
      ListSequence.fromList(res).addSequence(ListSequence.fromList(joinAdjacentFindings(candidate, ListSequence.fromList(findings).take(1).toList(), 3)));
    }
    return res;
  }

  public static boolean allSameChar(String s) {
    final char c = s.charAt(0);
    return Sequence.fromIterable(ArrayUtils.fromCharacterArray(s.toCharArray())).all((it) -> it == c);
  }

}
