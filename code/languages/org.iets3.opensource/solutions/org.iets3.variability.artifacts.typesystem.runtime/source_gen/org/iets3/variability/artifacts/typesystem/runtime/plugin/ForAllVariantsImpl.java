package org.iets3.variability.artifacts.typesystem.runtime.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import com.google.common.collect.ImmutableBiMap;
import org.iets3.variability.artifacts.base.plugin.ArtifactHelper;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.iets3.variability.artifacts.base.behavior.IFeatureConfigContext__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import org.iets3.variability.artifacts.base.plugin.IVAAUtil;
import java.util.Collection;
import org.iets3.variability.artifacts.base.plugin.IArtifactAlgorithms;
import org.iets3.variability.artifacts.base.plugin.IFilterInstantiator;
import org.iets3.variability.artifacts.base.plugin.RootNodesCopy;
import org.iets3.variability.artifacts.base.plugin.FilterParams;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.iets3.variability.configuration.base.behavior.FeatureModelConfiguration__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;

public class ForAllVariantsImpl {
  private static final boolean debug = false;

  private static boolean hasMulticheckWarningBeenShown = false;

  /**
   * A wrapper for errors/warnings/info occurring during execution of checking rules.
   */
  public interface IMapper {
    /**
     * Wrap the original message of the error/warning/info.
     * 
     * @param orig the original message text
     * @return the wrapped message text
     */
    String mapText(String orig);

    /**
     * Map the node-under-check if the checking has been done on a copy of the node
     * 
     * @param actuallyChecked the actually checked node (might be a copy)
     * @return the node in the original model
     */
    SNode mapNode(SNode actuallyChecked);
  }

  public static class Mapper implements IMapper {
    private final String suffix;
    private final ImmutableBiMap<SNode, SNode> inverseMap;

    /**
     * Construct a mapper from a configuration name and a copy-to-original mapping.
     * 
     * @param configName the name of the current configuration
     * @param inverseMap the mapping from copied nodes to original nodes
     */
    public Mapper(String configName, ImmutableBiMap<SNode, SNode> inverseMap) {
      this.suffix = ", in configuration '" + configName + "'";
      this.inverseMap = inverseMap;
    }

    @Override
    public String mapText(String orig) {
      return orig + suffix;
    }

    @Override
    public SNode mapNode(SNode actuallyChecked) {
      // compute original node from actually checked copy of the node
      return inverseMap.get(actuallyChecked);
    }
  }

  public static class NonMapper implements IMapper {
    @Override
    public String mapText(String orig) {
      return orig;
    }

    @Override
    public SNode mapNode(SNode actuallyChecked) {
      return actuallyChecked;
    }
  }

  public static boolean isIn150Model(SNode n) {
    SNode ivaa = ArtifactHelper.findIVAA(n);
    return (ivaa != null);
  }

  /**
   * Run the body of a checking rule for a given node.
   * 
   * If the node is in a variability-aware context, this will be done for all concrete configurations
   * visible in the node's model and the model's dependencies.
   * 
   * For each configuration, a copy of the relevant root nodes of the model will be created, filtered
   * according to variability and used for the actual check. If there are any messages (errors/warnings/infos),
   * the message texts will be extended by the name of the configuration where the checking failed.
   * 
   * @param nodeUnderCheck_ the node which should be checked by the checking rule
   * @param typeCheckingContext current typechecking context
   * @param checkName short description of the checking rule purpose
   * @param checkingLogic the actual checking logic (as a lambda function)
   */
  public static <NodeT> void doMultiCheck(NodeT nodeUnderCheck_, final TypeCheckingContext typeCheckingContext, String checkName, _FunctionTypes._void_P2_E0<? super NodeT, ? super IMapper> checkingLogic) {
    if (ForAllVariantsImpl.doMultiCheckInner(nodeUnderCheck_, checkingLogic, checkName, ForAllVariantsContext.make(typeCheckingContext))) {
      return;
    }
  }

  public static <NodeT> boolean doMultiCheckInner(NodeT nodeUnderCheck_, _FunctionTypes._void_P2_E0<? super NodeT, ? super IMapper> checkingLogic, String checkName, final ForAllVariantsContext typeCheckingContext) throws RuntimeException {
    // assert that first argument is actually a node<>
    if (!(nodeUnderCheck_ instanceof SNode)) {
      throw new RuntimeException("Invalid argument type, must be node<>");
    }
    SNode nodeUnderCheck = (SNode) nodeUnderCheck_;
    // check if we are in a variability-aware context
    SNode ivaa = ArtifactHelper.findIVAA(nodeUnderCheck);
    if ((ivaa == null)) {
      // node-under-check is not a 150% artifact, just execute checking logic and collect warnings and errors
      checkingLogic.invoke(nodeUnderCheck_, new NonMapper());
      return true;
    }

    // this is a real 150% artifact, run checking rule for each available configuration
    Iterable<SNode> configs = SNodeOperations.ofConcept(IFeatureConfigContext__BehaviorDescriptor.getAvailableConfigurations_id5bXbDSdjI5A.invoke(ivaa).getAvailableElements(null), CONCEPTS.FeatureModelConfiguration$nE);

    // run check for each complete and non-abstract variant configuration in scope
    Iterable<SNode> concreteConfigs = Sequence.fromIterable(configs).where((it) -> isConcreteConfig(it));
    if (debug) {
      System.err.println("********** CHECK MULTI configs=" + Sequence.fromIterable(concreteConfigs).count() + " check='" + checkName + "' node=" + nodeUnderCheck + " (id=" + nodeUnderCheck.getNodeId().toString() + ")");
    }

    // if there are no concrete configurations, skip check and issue an info message
    if (Sequence.fromIterable(concreteConfigs).isEmpty()) {
      report(typeCheckingContext, checkName, "' will not be executed, no variant configurations available", nodeUnderCheck, false);
      return true;
    }

    List<SNode> artifactGroup = Sequence.fromIterable(IVAAUtil.artifactGroup(ivaa)).toList();
    Collection<SNode> artifactGroupLogical = Sequence.fromIterable(IVAAUtil.artifactGroupWithLogicalChildren(artifactGroup)).toList();

    IArtifactAlgorithms instance = IArtifactAlgorithms.instance();
    IFilterInstantiator filterInstantiator = instance.filterInstantiator();
    for (SNode config : Sequence.fromIterable(concreteConfigs)) {
      // create cloned root nodes for 150% artifact group
      final RootNodesCopy origToCopy = RootNodesCopy.createFromNodeGroup(artifactGroupLogical);

      // apply variability filtering to copy
      FilterParams params = FilterParams.builder(ivaa, config).setUseSkeletonCache(true).setNodeMapper(origToCopy.getMapper()).setDeleteStaticContent(false).setFixBrokenLinks(true).build();
      Collection<SNode> detachments = filterInstantiator.filterInPlace(params);

      ImmutableBiMap<SNode, SNode> inverseMapping = origToCopy.inverseMapping();
      if (!(nodeUnderCheckHasBeenRemoved(detachments, inverseMapping, nodeUnderCheck))) {
        // execute checking logic and collect warnings and errors
        SNode nodeUnderCheckCopy = origToCopy.getCopyFor(nodeUnderCheck);
        checkingLogic.invoke((NodeT) nodeUnderCheckCopy, new Mapper(SPropertyOperations.getString(config, PROPS.name$MnvL), inverseMapping));
      }
      // else the node-under-check has been filtered => no check necessary for this configuration
    }
    return false;
  }

  private static boolean nodeUnderCheckHasBeenRemoved(Collection<SNode> detachments, final ImmutableBiMap<SNode, SNode> inverseMapping, SNode nodeUnderCheck) {
    // check if node-under-check does still exist (otherwise it has been filtered by variability)
    Iterable<SNode> allDetached = CollectionSequence.fromCollection(detachments).translate((it) -> SNodeOperations.getNodeDescendants(it, null, false, new SAbstractConcept[]{})).union(CollectionSequence.fromCollection(detachments)).select((it) -> inverseMapping.get(it));

    return Sequence.fromIterable(allDetached).contains(nodeUnderCheck);
  }

  private static void report(final ForAllVariantsContext typeCheckingContext, String checkName, String msg, SNode n, boolean isWarning) {
    String text = "Model check '" + checkName + "' " + msg;
    if (isWarning) {
      typeCheckingContext.reportWarning(n, text);
    } else {
      typeCheckingContext.reportInfo(n, text);
    }
  }

  private static Boolean isConcreteConfig(SNode fmc) {
    return (boolean) FeatureModelConfiguration__BehaviorDescriptor.isConcrete_id3fjVuHBlYzw.invoke(fmc);
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept FeatureModelConfiguration$nE = MetaAdapterFactory.getConcept(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x5cf5c0d0479ec915L, "org.iets3.variability.configuration.base.structure.FeatureModelConfiguration");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }
}
