package org.iets3.core.expr.path.interpreter.plugin;

/*Generated by MPS */

import com.mbeddr.mpsutil.interpreter.rt.InterpreterBase;
import java.util.List;
import com.mbeddr.mpsutil.interpreter.rt.IEvaluator;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.mbeddr.mpsutil.interpreter.rt.ConceptEvaluatorBase;
import org.jetbrains.mps.openapi.model.SNode;
import com.mbeddr.mpsutil.interpreter.rt.IContext;
import com.mbeddr.mpsutil.interpreter.rt.ICoverageAnalyzer;
import com.mbeddr.mpsutil.interpreter.rt.ComputationTrace;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.iets3.core.expr.base.behavior.IDotTarget__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import org.iets3.core.expr.path.plugin.IRecordValue;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.pcollections.PCollection;
import org.pcollections.PVector;
import org.pcollections.Empty;
import java.util.Iterator;
import org.iets3.core.expr.base.plugin.NoneValue;
import com.mbeddr.mpsutil.interpreter.rt.StopAndReturnException;
import com.mbeddr.mpsutil.interpreter.rt.InterpreterEscapeException;
import com.mbeddr.mpsutil.interpreter.rt.InterpreterRuntimeException;
import com.mbeddr.mpsutil.interpreter.rt.EvaluatorInfo;
import com.mbeddr.mpsutil.interpreter.rt.ITypeMapper;
import com.mbeddr.mpsutil.interpreter.rt.IRelationship;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SReferenceLink;

public class InterpreterExprPathInterpreterPCollections extends InterpreterBase {
  public InterpreterExprPathInterpreterPCollections() {
    init();
  }

  @Override
  public String getCategory() {
    return "arithmetic";
  }

  protected void populateEvaluators(List<? extends IEvaluator> evaluators) {
    ListSequence.fromList(((List<IEvaluator>) evaluators)).addElement(new ConceptEvaluatorBase(CONCEPTS.PathElement$sr, "r:2e472b3c-7ae8-4bc6-9b99-e3ae831d74bf(org.iets3.core.expr.path.interpreter.plugin)/3182453369942597745", true) {
      public Object evaluateEvaluator(SNode node, IContext context, ICoverageAnalyzer coverage, ComputationTrace trace) {
        try {
          coverage.visitedEvaluator(this);
          coverage.visitedConcept(this.concept);
          coverage.visitedConcept(SNodeOperations.getConcept(node));
          coverage.registerBranches(CONCEPTS.PathElement$sr, new String[]{"single", "multiple"});
          SNode ctxExpr = IDotTarget__BehaviorDescriptor.contextExpression_id6zmBjqUivyF.invoke(node);
          Object evaluatedContext = MapSequence.fromMap(context.getEnvironment()).get(ctxExpr);
          if (evaluatedContext instanceof IRecordValue) {
            coverage.visitedConceptBranch(CONCEPTS.PathElement$sr, "single");
            IRecordValue enVal = ((IRecordValue) evaluatedContext);
            Object result = enVal.getValueForPath(SLinkOperations.getTarget(node, LINKS.member$d1yc));
            coverage.coverValue(SLinkOperations.getTarget(node, LINKS.member$d1yc), result);
            return result;
          }
          if (evaluatedContext instanceof PCollection) {
            coverage.visitedConceptBranch(CONCEPTS.PathElement$sr, "multiple");
            if (evaluatedContext instanceof PVector) {
              PVector ctxList = ((PVector) evaluatedContext);
              PVector res = Empty.vector();
              Iterator<Object> it = ctxList.iterator();
              while (it.hasNext()) {
                Object e = it.next();
                if (e instanceof PVector) {
                  PVector innerVec = (PVector) e;
                  Iterator<Object> iit = innerVec.iterator();
                  while (iit.hasNext()) {
                    Object inner = iit.next();
                    Object v = ((IRecordValue) inner).getValueForPath(SLinkOperations.getTarget(node, LINKS.member$d1yc));
                    if (v != null) {
                      res = res.plus(v);
                    }
                  }
                } else {
                  Object v = ((IRecordValue) e).getValueForPath(SLinkOperations.getTarget(node, LINKS.member$d1yc));
                  if (v != null) {
                    if (!(v instanceof NoneValue)) {
                      res = res.plus(v);
                    }
                  }
                }

              }
              return res;
            }
          }
          return InterpreterBase.__NEXT__INTERPRETER__;
        } catch (StopAndReturnException stop) {
          return stop.value();
        } catch (InterpreterEscapeException ex) {
          throw ex;
        } catch (RuntimeException ex) {
          throw new InterpreterRuntimeException("PathElement()", node, ex, trace);
        }
      }
      public EvaluatorInfo getInfo() {
        return new EvaluatorInfo("PathElement", "http://127.0.0.1:63320/node?ref=98af764d-be36-4c3f-b8c9-cf0067326583%2Fi%3A10000001%28org.iets3.core.expr.path.interpreter%40transient58%2Forg.iets3.core.expr.path.interpreter.plugin%400%29%2F3182453369942597745");
      }

      @Override
      public String toString() {
        return "PathElement";
      }

      @Override
      public boolean canLookupBeCached() {
        return true;
      }
    });
  }


  protected void populateTypeMappers(List<? extends ITypeMapper> typeMappers) {
  }



  protected void populateRelationships(List<? extends IRelationship> relationships) {
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept PathElement$sr = MetaAdapterFactory.getConcept(0xf3eafff030d246d6L, 0x9150f0f3b880ce27L, 0x6c71b19f6f13ea6fL, "org.iets3.core.expr.path.structure.PathElement");
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink member$d1yc = MetaAdapterFactory.getReferenceLink(0xf3eafff030d246d6L, 0x9150f0f3b880ce27L, 0x6c71b19f6f13ea6fL, 0x6c71b19f6f13ea72L, "member");
  }
}
