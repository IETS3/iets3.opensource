package org.iets3.core.expr.collections.rt.rt;

/*Generated by MPS */

import org.pcollections.PVector;
import org.pcollections.PCollection;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.pcollections.TreePVector;
import org.iets3.core.expr.simpleTypes.runtime.AH;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Comparator;

public class CollectionHelper {
  public static PVector<Object> flatten(PCollection<? extends PCollection<? extends Object>> vec) {
    List<Object> r = new ArrayList<Object>();
    for (PCollection<? extends Object> coll : CollectionSequence.fromCollection(vec)) {
      r.addAll(coll);
    }
    PVector<Object> result = TreePVector.from(r);

    return result;
  }

  public static Number min(PCollection<Number> c) {

    Object[] o = c.toArray();
    Number min = ((Number) o[0]);

    for (Object i : o) {
      Number j = ((Number) i);
      if (AH.isLess(j, min)) {
        min = j;

      }
    }
    return min;
  }

  public static Number max(PCollection<Number> c) {

    Object[] o = c.toArray();
    Number max = ((Number) o[0]);

    for (Object i : o) {
      Number j = ((Number) i);
      if (AH.isGreater(j, max)) {
        max = j;

      }
    }
    return max;
  }

  public static Number sumAsBigDecimal(PCollection<Number> c) {
    if (c.isEmpty()) {
      return new BigDecimal("0");
    }
    Object[] o = c.toArray();
    Number sum = new BigDecimal("0");

    for (Object i : o) {
      Number j = ((Number) i);
      sum = AH.add(j, sum);
    }
    return sum;
  }

  public static Number sumAsBigInteger(PCollection<Number> c) {
    if (c.isEmpty()) {
      return new BigInteger("0");
    }
    Object[] o = c.toArray();
    Number sum = new BigInteger("0");

    for (Object i : o) {
      Number j = ((Number) i);
      sum = AH.add(j, sum);
    }
    return sum;
  }

  public static PVector<Number> sortAsc(PCollection<Object> vec) {
    List<Number> l = new ArrayList<Number>();
    for (Object n : vec.toArray()) {
      l.add(((Number) n));
    }


    l.sort(new Comparator<Number>() {

      @Override
      public int compare(Number n1, Number n2) {
        return AH.compare(n1, n2);
      }
    });
    PVector<Number> result = TreePVector.from(l);
    return result;
  }

  public static PVector<Number> sortDesc(PCollection<Object> vec) {
    List<Number> l = new ArrayList<Number>();
    for (Object n : vec.toArray()) {
      l.add(((Number) n));
    }


    l.sort(new Comparator<Number>() {

      @Override
      public int compare(Number n1, Number n2) {
        return -AH.compare(n1, n2);

      }
    });
    TreePVector<Number> result = TreePVector.from(l);
    return result;
  }
}
