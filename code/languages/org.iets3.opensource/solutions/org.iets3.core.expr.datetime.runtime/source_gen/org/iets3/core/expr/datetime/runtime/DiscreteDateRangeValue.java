package org.iets3.core.expr.datetime.runtime;

/*Generated by MPS */

import java.time.LocalDate;
import java.time.temporal.TemporalUnit;
import java.util.Objects;
import java.time.temporal.ChronoUnit;
import java.math.BigInteger;
import java.time.YearMonth;

/**
 * Represents a date range (interval) starting from 'begin', of length 'count' units given by 'unit'.
 * Example: new DateRangeValue(LocalDate.of(2018, 1, 1), ChronoUnit.MONTHS, 3) represents Q1 of 2018.
 * 
 * Factory methods are provided for the common cases of single-year, single-month, and "all-time" ranges.
 */
public class DiscreteDateRangeValue extends AbstractDateRangeValue {
  private final LocalDate begin;
  private final TemporalUnit unit;
  private final int count;

  public DiscreteDateRangeValue(LocalDate begin, TemporalUnit unit) {
    this(begin, unit, 1);
  }

  public DiscreteDateRangeValue(LocalDate begin, TemporalUnit unit, int count) {
    this.begin = begin;
    this.unit = unit;
    this.count = count;
  }

  public LocalDate begin() {
    return begin;
  }

  public LocalDate end() {
    if (Objects.equals(unit, ChronoUnit.FOREVER)) {
      return LocalDate.MAX;
    }
    return begin.plus(count, unit).minus(1L, ChronoUnit.DAYS);
  }

  public TemporalUnit unit() {
    return unit;
  }

  public DiscreteDateRangeValue next() {
    if (unit == ChronoUnit.FOREVER) {
      return this;
    }
    return new DiscreteDateRangeValue(begin.plus(count, unit), unit, count);
  }

  public DiscreteDateRangeValue prev() {
    return new DiscreteDateRangeValue(begin.minus(count, unit), unit, count);
  }

  public DiscreteDateRangeValue year() {
    return year(begin.getYear());
  }

  public BigInteger durationInDays() {
    return BigInteger.valueOf(ChronoUnit.DAYS.between(begin, end()) + 1);
  }

  public boolean isEqual(DiscreteDateRangeValue other) {
    ensureSameType(other);
    return this.begin.isEqual(other.begin);
  }
  public boolean isGreater(DiscreteDateRangeValue other) {
    ensureSameType(other);
    return this.begin.isAfter(other.begin);
  }

  public boolean isLess(DiscreteDateRangeValue other) {
    ensureSameType(other);
    return this.begin.isBefore(other.begin);
  }

  @Override
  public String toString() {
    if (isGlobal()) {
      return "[global]";
    }
    if (isSingleYear()) {
      return "year[" + begin.getYear() + "]";
    }
    if (isSingleMonth()) {
      return "month[" + begin.getYear() + "/" + begin.getMonthValue() + "]";
    }
    return "[date range: " + begin() + " to " + end() + "]";
  }

  private void ensureSameType(DiscreteDateRangeValue other) {
    if (!(Objects.equals(this.unit, other.unit)) || this.count != other.count) {
      throw new ArithmeticException(String.format("Cannot compare %d %s to %d %s", this.count, this.unit, other.count, other.unit));
    }
  }

  private static final DiscreteDateRangeValue GLOBAL = new DiscreteDateRangeValue(LocalDate.MIN, ChronoUnit.FOREVER);

  public static DiscreteDateRangeValue global() {
    return GLOBAL;
  }

  public static DiscreteDateRangeValue year(int y) {
    return new DiscreteDateRangeValue(LocalDate.of(y, 1, 1), ChronoUnit.YEARS);
  }

  public static DiscreteDateRangeValue month(int y, int m) {
    return month(YearMonth.of(y, m));
  }
  public static DiscreteDateRangeValue month(YearMonth yearMonth) {
    return new DiscreteDateRangeValue(yearMonth.atDay(1), ChronoUnit.MONTHS);
  }

  public boolean isGlobal() {
    return Objects.equals(unit, ChronoUnit.FOREVER);
  }

  public boolean isSingleYear() {
    return Objects.equals(unit, ChronoUnit.YEARS) && count == 1;
  }

  public boolean isSingleMonth() {
    return Objects.equals(unit, ChronoUnit.MONTHS) && count == 1;
  }

  @Override
  public int compareTo(AbstractDateRangeValue value) {
    int beginComparison = this.begin.compareTo(value.begin());

    if (beginComparison != 0) {
      return beginComparison;
    }

    int endComparison = this.end().compareTo(value.end());

    return endComparison;
  }
}
