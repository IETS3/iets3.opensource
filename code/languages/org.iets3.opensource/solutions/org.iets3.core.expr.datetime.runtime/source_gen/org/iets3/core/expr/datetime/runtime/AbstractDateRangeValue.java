package org.iets3.core.expr.datetime.runtime;

/*Generated by MPS */

import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.time.Period;
import java.util.Objects;

public abstract class AbstractDateRangeValue implements Comparable<AbstractDateRangeValue> {

  public abstract LocalDate begin();

  public abstract LocalDate end();

  public long countDays() {
    return ChronoUnit.DAYS.between(begin(), end()) + 1;
  }

  public long countYears(boolean full) {
    if (full) {
      return ChronoUnit.YEARS.between(begin(), end().plusDays(1));
    } else {
      Period p = Period.between(begin(), end().plusDays(1));
      int years = p.getYears();
      if (!(p.minusYears(years).isZero())) {
        years += 1;
      }
      return years;
    }
  }

  public long countMonths(boolean full) {
    if (full) {
      return ChronoUnit.MONTHS.between(begin(), end().plusDays(1));
    } else {
      Period p = Period.between(begin(), end().plusDays(1));
      long months = p.toTotalMonths();
      if (!(p.minusMonths(months).normalized().isZero())) {
        months += 1;
      }
      return months;
    }
  }

  @Override
  public boolean equals(Object object) {
    if (!(object instanceof AbstractDateRangeValue)) {
      return false;
    }
    AbstractDateRangeValue other = (AbstractDateRangeValue) object;
    return Objects.equals(this.begin(), other.begin()) && Objects.equals(this.end(), other.end());
  }

  @Override
  public int hashCode() {
    return Objects.hash(this.begin(), this.end());
  }

  public boolean fitsIn(AbstractDateRangeValue other) {
    boolean beginOk = this.begin().isAfter(other.begin()) || this.begin().equals(other.begin());
    boolean endOk = this.end().isBefore(other.end()) || this.end().equals(other.end());
    return beginOk && endOk;
  }

  public boolean contains(AbstractDateRangeValue other) {
    boolean beginOk = this.begin().isBefore(other.begin()) || this.begin().equals(other.begin());
    boolean endOk = this.end().isAfter(other.end()) || this.end().equals(other.end());
    return beginOk && endOk;
  }

  public boolean containsDate(LocalDate other) {
    ArbitraryDateRangeValue o = new ArbitraryDateRangeValue(other, other);
    return this.contains(o);
  }

  public boolean overlaps(AbstractDateRangeValue other) {
    boolean otherBeginsAfterThis = beginsAfter(other, this);
    boolean otherEndsBeforeThis = beginsAfter(this, other);

    return !(otherBeginsAfterThis || otherEndsBeforeThis);
  }

  public AbstractDateRangeValue intersect(AbstractDateRangeValue other) {
    AbstractDateRangeValue i = this.intersectOneWay(other);
    if (i instanceof EmptyDateRangeValue) {
      return other.intersectOneWay(this);
    }
    return i;
  }

  private AbstractDateRangeValue intersectOneWay(AbstractDateRangeValue other) {
    //       other
    // this
    if (beginsAfter(other, this)) {
      return new EmptyDateRangeValue();
    }

    // this
    //    other
    if (beginsWithin(other, this) && endsWithin(this, other)) {
      return new ArbitraryDateRangeValue(other.begin(), this.end());
    }

    //  this
    // _other_
    if (beginsWithin(this, other) && endsWithin(this, other)) {
      return this;
    }

    return new EmptyDateRangeValue();
  }


  private boolean isBeforeOrEqual(LocalDate l, LocalDate r) {
    return l.isBefore(r) || l.isEqual(r);
  }

  private boolean isEqualOrLater(LocalDate l, LocalDate r) {
    return l.isAfter(r) || l.isEqual(r);
  }

  private boolean beginsAfter(AbstractDateRangeValue l, AbstractDateRangeValue r) {
    return l.begin().isAfter(r.end());
  }

  private boolean endsWithin(AbstractDateRangeValue l, AbstractDateRangeValue r) {
    return isEqualOrLater(l.end(), r.begin()) && isBeforeOrEqual(l.end(), r.end());
  }

  private boolean beginsWithin(AbstractDateRangeValue l, AbstractDateRangeValue r) {
    return isEqualOrLater(l.begin(), r.begin()) && isBeforeOrEqual(l.begin(), r.end());
  }

  @Override
  public int compareTo(AbstractDateRangeValue value) {
    return 0;
  }
}
