package org.iets3.variability.artifacts.base.behavior;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import java.util.Collection;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

/**
 * Restricted builder for skeleton trees. The following features are not supported:
 * - instantiation
 * - logical children
 * - dependent sources
 * - presence prerequisites
 * - structural evaluation
 */
public class SkeletonTreeBaseBuilder extends AbstractSkeletonTreeBuilder {
  private static final boolean debug = false;
  private static DebugLogger logger = new DebugLogger(debug);

  public static SkeletonTree buildTreeFor(SNode artifact) {
    return new SkeletonTreeBaseBuilder().buildTree(artifact);
  }

  public SkeletonTreeBaseBuilder() {
    super(new SkelNodeMap());
  }

  @Override
  public SkeletonTree buildTree(SNode artifact) {
    try {
      SkeletonNode rootNode = buildTreeInternal(artifact);
      SkeletonTree skeletonTree = new SkeletonTree(artifact, rootNode, ListSequence.fromList(skelnodeMap.collectedSkeletonNodes()).toList(), makeResolver(skelnodeMap));
      printSkeletonGraph(skeletonTree);
      return skeletonTree;
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  private static _FunctionTypes._return_P2_E0<? extends SkeletonNode, ? super SNode, ? super ArtifactPath> makeResolver(final SkelNodeMap skelNodeMap) {
    return (SNode childNode, ArtifactPath path) -> skelNodeMap.resolveSkeletonNode(childNode, path);
  }

  private SkeletonNode buildTreeInternal(SNode artifact) {
    skelnodeMap.clear();
    SNode origRoot = IVariabilityAwareArtifact__BehaviorDescriptor.artifactRoot_id3q2wVeorTKs.invoke(artifact);
    ArtifactPath rootPath = new ArtifactPath(artifact);
    SkeletonNode skeletonRoot = createSkeletonNodeVP(origRoot, origRoot, null, null, rootPath);
    createSkelRec(new SkeletonEnvironment(origRoot, skeletonRoot, artifact, rootPath), 0);
    return skeletonRoot;
  }

  private void createSkelRec(SkeletonEnvironment skeletonEnv, final int indent) {
    String txt = "createSkel " + BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(skeletonEnv.node());
    logger.out(txt, indent);
    for (final SkeletonEnvironment skelEnvNext : CollectionSequence.fromCollection(nextSkeletonEnvironmentsFor(skeletonEnv))) {
      Iterable<SNode> skipVarExprs = skelEnvNext.skeleton().getConditionExpressions();
      ListSequence.fromList(stbu.relevantChildren(skelEnvNext.node(), skipVarExprs)).visitAll((child) -> createSkelRec(skelEnvNext.sameFor(child), indent + 1));
    }
  }

  /**
   * Checks whether a new environment needs to be created. Else returns the current active (the parameter)
   */
  private Collection<SkeletonEnvironment> nextSkeletonEnvironmentsFor(SkeletonEnvironment skelEnv) {
    {
      final SNode itvp = skelEnv.node();
      if (SNodeOperations.isInstanceOf(itvp, CONCEPTS.ITabularVarPoint$NA)) {
        return makeSkeletonEnvironmentForTabularVarPoint(itvp, skelEnv.skeleton(), skelEnv.path(), skelEnv.ivaa());
      }
    }
    return Sequence.fromIterable(Sequence.singleton(makeSkeletonEnvironmentForGenericVarPoint(skelEnv))).toList();
  }

  private SkeletonEnvironment makeSkeletonEnvironmentForGenericVarPoint(final SkeletonEnvironment skelEnv) {
    final SNode n = skelEnv.node();
    return varpointFor(n).map((vp) -> {
      // only create new nodes if there is a variation point
      SkeletonNode skelNode = createSkeletonNodeVP(n, n, vp, skelEnv.skeleton(), skelEnv.path());
      return new SkeletonEnvironment(n, skelNode, skelEnv.ivaa(), skelEnv.path());
    }).orElse(skelEnv);
  }


  private static void printSkeletonGraph(SkeletonTree result) {
    logger.out(result.buildGraph(true), 0);
    logger.sep();
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept ITabularVarPoint$NA = MetaAdapterFactory.getInterfaceConcept(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0xf3bd927d24fa475L, "org.iets3.variability.artifacts.base.structure.ITabularVarPoint");
  }
}
