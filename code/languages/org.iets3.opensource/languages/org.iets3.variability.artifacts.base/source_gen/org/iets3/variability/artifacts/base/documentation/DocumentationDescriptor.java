package org.iets3.variability.artifacts.base.documentation;

/*Generated by MPS */

import com.mbeddr.doc.aspect.runtime.IDocumentationAspectDescriptor;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.ModuleRepositoryFacade;
import jetbrains.mps.smodel.Language;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import java.util.List;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModuleOperations;
import com.mbeddr.doc.aspect.runtime.DocumentationAspectHelper;

public class DocumentationDescriptor implements IDocumentationAspectDescriptor {

  public SNode getDocumentation(final SAbstractConcept concept, final SProperty property) {
    final ModuleRepositoryFacade repositoryFacade = ModuleRepositoryFacade.getInstance();
    final Language currentLanguage = repositoryFacade.getModule(PersistenceFacade.getInstance().createModuleReference("f0883503-8eaa-4bc8-8846-eb63220ab1dd(org.iets3.variability.artifacts.base)"), Language.class);

    final Iterable<Language> languages = Sequence.fromIterable(Sequence.<Language>singleton(currentLanguage)).concat(CollectionSequence.fromCollection(repositoryFacade.getAllExtendingLanguages(currentLanguage)));

    List<Tuples._2<SNode, Integer>> availableDocs = ListSequence.fromList(new ArrayList<Tuples._2<SNode, Integer>>());
    for (Language language : Sequence.fromIterable(languages)) {
      final SModel model = SModuleOperations.getAspect(language, "documentation");
      final List<Tuples._2<SNode, Integer>> foundDocs = DocumentationAspectHelper.findDocumentationElements(model, concept, property);
      if (foundDocs != null) {
        ListSequence.fromList(availableDocs).addSequence(ListSequence.fromList(foundDocs));
      }
    }

    Iterable<Tuples._2<SNode, Integer>> seq = ListSequence.fromList(availableDocs).sort((a, b) -> (int) a._1() - (int) b._1(), false);
    if (Sequence.fromIterable(seq).isNotEmpty()) {
      return Sequence.fromIterable(seq).first()._0();
    }

    return null;
  }

}
