package org.iets3.variability.artifacts.base.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import com.mbeddr.mpsutil.interpreter.rt.IContext;
import org.iets3.variability.artifacts.base.behavior.IConditionVarPoint__BehaviorDescriptor;
import org.iets3.variability.artifacts.base.behavior.IConfigListVarPoint__BehaviorDescriptor;
import java.util.Optional;
import org.jetbrains.annotations.NotNull;
import com.mbeddr.mpsutil.logicalChild.behavior.ILogicalChild__BehaviorDescriptor;
import org.iets3.variability.artifacts.base.behavior.PresenceConditionValue;
import org.iets3.variability.artifacts.base.behavior.IVariationPointBase__BehaviorDescriptor;
import org.iets3.variability.artifacts.base.behavior.IPreviewableArtifact__BehaviorDescriptor;
import java.util.List;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public class ArtifactHelper {

  public static Iterable<SNode> getVariationPoints(SNode n) {
    Iterable<SNode> attributes = SNodeOperations.ofConcept(SLinkOperations.getChildren(n, LINKS.smodelAttribute$KJ43), CONCEPTS.IVariationPointBase$F1);
    if (SNodeOperations.isInstanceOf(n, CONCEPTS.IVariationPointBase$F1) && !(SNodeOperations.isAttribute(n))) {
      return Sequence.fromIterable(attributes).union(ListSequence.fromList(ListSequence.fromListAndArray(new ArrayList<SNode>(), SNodeOperations.cast(n, CONCEPTS.IVariationPointBase$F1))));
    } else {
      return attributes;
    }
  }

  public static Boolean isPresentTernary(SNode vp, SNode featureConfig, IContext context) {
    {
      final SNode cvp = vp;
      if (SNodeOperations.isInstanceOf(cvp, CONCEPTS.IConditionVarPoint$bG)) {
        // this branch doesn't use the featureConfig parameter (the information is coded in the IContext)
        return IConditionVarPoint__BehaviorDescriptor.isPresentTernary_id1R5hpWYhU60.invoke(cvp, context);
      }
    }
    {
      final SNode clvp = vp;
      if (SNodeOperations.isInstanceOf(clvp, CONCEPTS.IConfigListVarPoint$l9)) {
        if ((featureConfig == null)) {
          // config is not specified, return null which represents "undecided"
          return null;
        } else {
          // TODO: for included/nested configs, it is not clear if we will check against the root config or the sub-configs here (this hasn't been defined yet, as IConfigListVarPoint is just a sketch without any productive use yet)
          return (boolean) IConfigListVarPoint__BehaviorDescriptor.isPresent_id63fgxdO0qXV.invoke(clvp, featureConfig);
        }
      }
    }

    // unknown variation point type: assume "undecided"
    return null;
  }

  /**
   * Get the IVAA from a given node.
   * 
   * This will be either the node itself or one of its node attributes.
   * Note: Currently n has to be a root node, this is an assumption throughout the 
   * variability-awareness-framework (including the solver_gen generators).
   * 
   * @param n a given root node
   * @return the IVariabilityAwareArtifact node for n (if any)
   */
  public static SNode getIVAA(SNode n) {
    {
      final SNode ivaa = n;
      if (SNodeOperations.isInstanceOf(ivaa, CONCEPTS.IVariabilityAwareArtifact$qo)) {
        return ivaa;
      }
    }
    Iterable<SNode> attr = SNodeOperations.ofConcept(SLinkOperations.getChildren(n, LINKS.smodelAttribute$KJ43), CONCEPTS.IVariabilityAwareArtifact$qo);
    if (Sequence.fromIterable(attr).isNotEmpty()) {
      return Sequence.fromIterable(attr).first();
    }
    return null;
  }

  public static Optional<SNode> artifactInstanceOf(@NotNull SNode n) {
    {
      final SNode iai = n;
      if (SNodeOperations.isInstanceOf(iai, CONCEPTS.IArtifactInstance$ce)) {
        return Optional.of(iai);
      }
    }
    return Optional.ofNullable(Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(n, LINKS.smodelAttribute$KJ43), CONCEPTS.IArtifactInstance$ce)).first());
  }

  /**
   * Get IVAA for some model node even if it is not attached to the root node.
   * 
   * Currently this could be the case if we are in a NodesTest. Otherwise IVAAs should always
   * reside at root nodes for the current version of IETS3 Variability. 
   * 
   * Note that this assumption will be removed in later IETS3 Variability versions.
   * 
   * Caution: This method has to run up the parent-chain and check for each node
   * if it either has an IVAA attribute or is itself implementing IVAA. This is 
   * probably not efficient if it is called for many nodes.
   * 
   * @param start the node for which we want to get the IVAA
   * @return the IVAA which is relevant for the input node
   */
  public static SNode findIVAA(SNode start) {
    return findIVAAAux(start, true);
  }

  /**
   * Get IVAA for some model node, but ignore logical children relationships.
   * 
   * See previous method's comment for general remarks.
   */
  public static SNode findDirectIVAA(SNode start) {
    return findIVAAAux(start, false);
  }

  private static SNode findIVAAAux(SNode start, boolean withLogicalChildren) {
    SNode n = start;
    do {
      SNode ivaa = getIVAA(n);
      if ((ivaa != null)) {
        return ivaa;
      }

      n = (withLogicalChildren ? ArtifactHelper.getLogicalParent(n) : SNodeOperations.getParent(n));
    } while ((n != null));
    return null;
  }

  public static SNode getLogicalParent(SNode n) {
    // if n is a logical child, then the logical child owner is its parent
    {
      final SNode ilc = n;
      if (SNodeOperations.isInstanceOf(ilc, CONCEPTS.ILogicalChild$Av)) {
        if (ILogicalChild__BehaviorDescriptor.getOwner_id7c93VeVMBwo.invoke(ilc) != null) {
          return ILogicalChild__BehaviorDescriptor.getOwner_id7c93VeVMBwo.invoke(ilc);
        }
      }
    }

    // otherwise return the containment parent according to the AST
    return SNodeOperations.getParent(n);
  }

  public static boolean showArtefactsOf(SNode ivp) {
    PresenceConditionValue pcv = IVariationPointBase__BehaviorDescriptor.getState_id7pGmjNvL72C.invoke(ivp);
    if (pcv == null) {
      return true;
    }
    return previewCriteriaOf(ivp).isVisible(pcv);
  }

  public static PreviewCriteria previewCriteriaOf(SNode ivp) {
    SNode ivaa = IVariationPointBase__BehaviorDescriptor.getContextIVAA_id2eukZZwMmyR.invoke(ivp);
    return IPreviewableArtifact__BehaviorDescriptor.previewCriteria_id6ViAOjRttY.invoke(ivaa);
  }

  public static boolean needsAttributeSorting(SNode n) {
    List<SNode> attrs = SLinkOperations.getChildren(n, LINKS.smodelAttribute$KJ43);
    if (ListSequence.fromList(attrs).count() < 2) {
      return false;
    }
    for (int i = 1; i < ListSequence.fromList(attrs).count(); i++) {
      if (prio(ListSequence.fromList(attrs).getElement(i - 1)) > prio(ListSequence.fromList(attrs).getElement(i))) {
        return true;
      }
    }
    return false;
  }

  public static void sortAttributes(SNode n) {
    List<SNode> sorted = ListSequence.fromList(SLinkOperations.getChildren(n, LINKS.smodelAttribute$KJ43)).sort((it) -> prio(it), true).toList();
    ListSequence.fromList(SLinkOperations.getChildren(n, LINKS.smodelAttribute$KJ43)).clear();
    ListSequence.fromList(SLinkOperations.getChildren(n, LINKS.smodelAttribute$KJ43)).addSequence(ListSequence.fromList(sorted));
  }

  private static Integer prio(SNode attr) {
    {
      final SNode a1 = attr;
      if (SNodeOperations.isInstanceOf(a1, CONCEPTS.IArtifactInstance$ce)) {
        return 3;
      }
    }
    {
      final SNode a1 = attr;
      if (SNodeOperations.isInstanceOf(a1, CONCEPTS.IVariationPointBase$F1)) {
        return 1;
      }
    }
    return 5;
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink smodelAttribute$KJ43 = MetaAdapterFactory.getContainmentLink(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, 0x47bf8397520e5942L, "smodelAttribute");
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept IVariationPointBase$F1 = MetaAdapterFactory.getInterfaceConcept(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x19503178dec840e6L, "org.iets3.variability.artifacts.base.structure.IVariationPointBase");
    /*package*/ static final SInterfaceConcept IConditionVarPoint$bG = MetaAdapterFactory.getInterfaceConcept(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0xe86d1af52aae5ceL, "org.iets3.variability.artifacts.base.structure.IConditionVarPoint");
    /*package*/ static final SInterfaceConcept IConfigListVarPoint$l9 = MetaAdapterFactory.getInterfaceConcept(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x23e80284f237bef8L, "org.iets3.variability.artifacts.base.structure.IConfigListVarPoint");
    /*package*/ static final SInterfaceConcept IVariabilityAwareArtifact$qo = MetaAdapterFactory.getInterfaceConcept(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x716b3738b4b28e4bL, "org.iets3.variability.artifacts.base.structure.IVariabilityAwareArtifact");
    /*package*/ static final SInterfaceConcept IArtifactInstance$ce = MetaAdapterFactory.getInterfaceConcept(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x29c0f4d5e8127ce1L, "org.iets3.variability.artifacts.base.structure.IArtifactInstance");
    /*package*/ static final SInterfaceConcept ILogicalChild$Av = MetaAdapterFactory.getInterfaceConcept(0x85a9bace37a140afL, 0x956a7bb1b081a77cL, 0x4d47311ce85ef55L, "com.mbeddr.mpsutil.logicalChild.structure.ILogicalChild");
  }
}
