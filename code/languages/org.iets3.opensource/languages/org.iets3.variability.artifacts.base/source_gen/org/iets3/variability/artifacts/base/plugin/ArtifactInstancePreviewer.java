package org.iets3.variability.artifacts.base.plugin;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Map;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.iets3.variability.artifacts.base.behavior.ArtifactInstances;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.iets3.variability.artifacts.base.behavior.IPreviewableArtifact__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import com.mbeddr.mpsutil.editor.displayControl.behavior.ICanHide__BehaviorDescriptor;
import org.iets3.variability.artifacts.base.behavior.IVariationPointBase__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.iets3.variability.artifacts.base.behavior.SkeletonNode;
import org.iets3.contextfilter.behavior.IContextFilterOwner__BehaviorDescriptor;
import org.iets3.variability.artifacts.base.behavior.ArtifactInstanceContextSelector__BehaviorDescriptor;
import org.iets3.variability.artifacts.base.behavior.SkeletonTree;
import org.iets3.variability.artifacts.base.behavior.StateStoreProviderIVP;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.Set;
import org.iets3.variability.artifacts.base.behavior.IVariabilityAwareArtifact__BehaviorDescriptor;
import com.mbeddr.mpsutil.logicalChild.behavior.ILogicalChildOwner__BehaviorDescriptor;
import com.google.common.collect.Sets;
import java.util.LinkedList;
import org.iets3.variability.artifacts.base.behavior.ArtifactPath;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.iets3.variability.artifacts.base.behavior.PresenceConditionValue;
import java.util.ArrayList;
import java.awt.Color;
import java.util.HashMap;
import org.iets3.variability.artifacts.base.behavior.StateStore;
import java.util.Objects;
import jetbrains.mps.nodeEditor.NodeHighlightManager;
import jetbrains.mps.openapi.editor.message.EditorMessageOwner;
import de.slisson.mps.hacks.editor.EditorComponentHacks;
import com.intellij.ui.JBColor;
import jetbrains.mps.nodeEditor.highlighter.EditorComponentCreateListener;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.module.SRepository;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.nodeEditor.EditorContext;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;

/**
 * Compute top-level nodes affected by selections in a configuration and 
 * preview an instance of affected artifacts according to the selected criteria.
 * For example if can hide not selected nodes and its dependencies or 
 * highlight those nodes.
 * 
 * Note: This class depends on an ISkeletonTreeBuilder and an IArtifactEvaluator. Depending on the extensions
 * that are available (e.g., "base" or "advanced"), the functionality of these components might be restricted.
 * The overall functionality of ArtifactInstancePreviewer is then restricted as well.
 */
public class ArtifactInstancePreviewer {
  public static boolean debug = false;

  private static final String RENDER_NODES = "RENDER_NODES";
  private static final String RENDER_STATUS = "RENDER_STATUS";
  private static final String RENDERED = "RENDERED";
  private static final String NODE_COLOR = "COLOR";

  /**
   * Flag which blocks calls from the model listeners of the artifact language.
   * This is used while the previewer is running and also during tests.
   */
  public static volatile boolean blockModelListener = false;

  private static PreviewCriteria previewCriteria;
  private static List<SNode> ivaasForUpdate;
  private static Iterable<SNode> allRootNodes;
  private static Map<SNode, EditorComponent> editors;


  private static EditorListenerManager editorListenerMgr = new EditorListenerManager(new PreviewerEditorListener());

  public static void clear(SNode targetIvaa) {
    log(targetIvaa, "clear event handler starting");
    if (blockModelListener) {
      log(targetIvaa, "clear event ignored");
    } else {
      blockModelListener = true;
      collectDataForPreviewer(targetIvaa);
      clearInternal(targetIvaa);
      log(targetIvaa, "clear event handler finished");
      blockModelListener = false;
    }
  }

  private static void clearInternal(SNode targetIvaa) {
    log(targetIvaa, "cleaning");

    clearIvaas();

    clearRootNodes(targetIvaa);

    editorListenerMgr.disconnect();
  }

  private static void clearIvaas() {
    for (SNode ivaa : ListSequence.fromList(ivaasForUpdate)) {
      ArtifactInstances.clear(ivaa);
      SPropertyOperations.assign(ivaa, PROPS.inPreview$Ox7X, false);
    }
  }

  private static void clearRootNodes(SNode targetIvaa) {
    for (SNode root : Sequence.fromIterable(allRootNodes)) {
      log(root, "cleaning artifact root");
      clearHighlighter(root);
      clearRenderStatus(root);
      clearStateOfVariationPointsForDecoloringPresenceConditions(root);
      if (!((boolean) IPreviewableArtifact__BehaviorDescriptor.enforceHighlighterPreview_id2eXfxf9wG9q.invoke(targetIvaa))) {
        clearHideStatus(root);
      }
      updateActiveEditor(root);
    }
  }

  private static void clearHighlighter(SNode artifact) {
    Highlighter hlr = Highlighter.create(artifact, getEditorComponent(artifact));
    if (hlr != null) {
      hlr.clear();
    }
  }

  private static void clearHideStatus(SNode artifact) {
    ListSequence.fromList(SNodeOperations.getNodeDescendants(artifact, CONCEPTS.ICanHide$4s, false, new SAbstractConcept[]{})).visitAll((it) -> ICanHide__BehaviorDescriptor.show_id5I8v_DCoggH.invoke(it));
  }

  private static void clearStateOfVariationPointsForDecoloringPresenceConditions(SNode artifact) {
    ListSequence.fromList(SNodeOperations.getNodeDescendants(artifact, CONCEPTS.IVariationPointBase$F1, false, new SAbstractConcept[]{})).visitAll((vp) -> IVariationPointBase__BehaviorDescriptor.resetState_id7pGmjNvL6KZ.invoke(vp));
  }

  public static void forcedClear(SNode ivaa) {
    log(ivaa, "forced clear");

    // this is required if the previewer has its blockModelListener flag set because of an exception in a previous activity
    blockModelListener = false;

    // set configRef to null in order to clear the previewer
    SLinkOperations.setTarget(ivaa, LINKS.configRef$mKqc, null);
  }

  public static void updateAccordingToSelectedContext(SNode ivaa) {
    log(ivaa, "update according to selected context");
    {
      final SNode owner = ivaa;
      if (SNodeOperations.isInstanceOf(owner, CONCEPTS.IContextFilterOwner$ly)) {
        SkeletonNode instanceRootNode = null;
        if ((boolean) IContextFilterOwner__BehaviorDescriptor.hasContextFilter_id1UWdA_Ujlm9.invoke(owner)) {
          SNode selector = SNodeOperations.as(IContextFilterOwner__BehaviorDescriptor.getFirstSelectorOf_id3j0RMEs8lUK.invoke(owner, CONCEPTS.ArtifactInstanceContextSelector$aN), CONCEPTS.ArtifactInstanceContextSelector$aN);
          if (null != selector) {
            instanceRootNode = ArtifactInstanceContextSelector__BehaviorDescriptor.getSkeletonNodeForSelectedInstance_idHf7whNvtfR.invoke(selector);
          }
        } else {
          if (SPropertyOperations.getBoolean(ivaa, PROPS.inPreview$Ox7X)) {
            instanceRootNode = ArtifactInstances.getFirstInstance(ivaa);
          }
        }

        if (null != instanceRootNode) {
          updateNodesForInstance(instanceRootNode, ivaa);
          EditorComponent editor = getEditorComponent(SNodeOperations.getContainingRoot(ivaa));
          render(SNodeOperations.getContainingRoot(ivaa), editor);
          log(SNodeOperations.getContainingRoot(ivaa), "update context");
          editor.update();
        }
      }
    }
  }

  public static void update(SNode ivaa, PreviewCriteria criteria) {
    log(ivaa, "updating with preview criteria: " + criteria.description());
    previewCriteria = criteria;
    guardedUpdate(ivaa);
  }

  public static void update(SNode ivaa) {
    log(ivaa, "updating event handler");
    previewCriteria = IPreviewableArtifact__BehaviorDescriptor.previewCriteria_id6ViAOjRttY.invoke(ivaa);
    guardedUpdate(ivaa);
  }

  /**
   * 
   * @deprecated Use one of the other update() methods
   */
  @Deprecated
  public static void update(SNode ivaa, boolean onlyLocally) {
    log(ivaa, "updating legacy public API");
    guardedUpdate(ivaa);
  }

  private static void guardedUpdate(SNode targetIvaa) {
    if (blockModelListener) {
      log(targetIvaa, "update event ignored");
    } else {
      blockModelListener = true;
      collectDataForPreviewer(targetIvaa);
      clearInternal(targetIvaa);
      updateInternal(targetIvaa);
      blockModelListener = false;
    }
  }

  private static void updateInternal(SNode targetIvaa) {
    log(targetIvaa, "update internal");

    if (!(canUpdate(targetIvaa))) {
      return;
    }

    boolean connected = editorListenerMgr.connect(targetIvaa);
    log(targetIvaa, "initialization of listener " + ((connected ? "succeed" : "failed")));

    setupIvaasForPreview();

    ITopAffectedNodesProvider affectedNodes = identifyAffectedNodes(targetIvaa);

    List<ArtifactVisualizationData> visualizationData = transformVisualizationData(affectedNodes);

    ListSequence.fromList(visualizationData).visitAll((it) -> it.applyPreviewCriteria());

    render(allRootNodes);

    log(targetIvaa, "instance previewer finished");
  }

  private static ITopAffectedNodesProvider identifyAffectedNodes(SNode targetIvaa) {
    // build skeleton tree and compute affected nodes so that we know their presence conditions
    // Note: The SkelTree-Builder in "base" is quite restricted, and will ignore instantiation, dependent sources, logical children and much more. Thus, the ArtifactInstancePreviewer will be restricted as well.
    IArtifactAlgorithms algorithms = IArtifactAlgorithms.instance();
    SkeletonTree skelTree = algorithms.skeletonTreeBuilder().buildTree(targetIvaa);
    StateStoreProviderIVP p = new StateStoreProviderIVP();
    IArtifactEvaluator artifactEvaluator = algorithms.artifactEvaluator(skelTree, p);
    ITopAffectedNodesProvider affectedNodes = artifactEvaluator.computeTopAffectedNodesAux(SLinkOperations.getTarget(SLinkOperations.getTarget(targetIvaa, LINKS.configRef$mKqc), LINKS.featureConfig$pJ5X));

    // attach IVAA instances (i.e. skeleton nodes) to the IVAA, so that it can be used within context filtering
    ArtifactInstances.attachExisting(skelTree, affectedNodes.getTopFilteredNodes());

    return affectedNodes;
  }

  private static void render(Iterable<SNode> roots) {
    for (SNode root : Sequence.fromIterable(roots)) {
      EditorComponent editor = MapSequence.fromMap(editors).get(root);
      if (null != editor && editor.isEnabled()) {
        render(root, editor);
        log(root, "render - update active editor");
        editor.update();
      }
    }
  }

  private static void setupIvaasForPreview() {
    for (SNode ivaa : ListSequence.fromList(ivaasForUpdate)) {
      log(ivaa, "ivaa found. Setting criteria: " + previewCriteria);
      SPropertyOperations.assign(ivaa, PROPS.inPreview$Ox7X, true);
      IPreviewableArtifact__BehaviorDescriptor.previewCriteria_id51XFjh5Ptnl.invoke(ivaa, previewCriteria);
    }
  }

  private static Set<SNode> rootNodesWithLogicalChildren(Iterable<SNode> ivaasForUpdate) {
    // find all logical-child owners for this set of IVAAs
    Iterable<SNode> allOwners = Sequence.fromIterable(ivaasForUpdate).translate((ivaa) -> SNodeOperations.getNodeDescendants(IVariabilityAwareArtifact__BehaviorDescriptor.artifactRoot_id3q2wVeorTKs.invoke(ivaa), CONCEPTS.ILogicalChildOwner$nQ, true, new SAbstractConcept[]{}));

    // find all corresponding logical children and retrieve their root nodes
    Iterable<SNode> logicalChildRoots = Sequence.fromIterable(allOwners).translate((owner) -> (Iterable<SNode>) ILogicalChildOwner__BehaviorDescriptor.findLogicalChildren_id7c93VeVMIYV.invoke(owner)).select((it) -> SNodeOperations.getContainingRoot(it));

    // return set for better read performance
    return Sets.newHashSet(logicalChildRoots);
  }

  private static List<SNode> defineArtifactsForUpdate(SNode targetIvaa, boolean onlyLocally) {
    List<SNode> ivaasForUpdate = ListSequence.fromListAndArray(new LinkedList<SNode>(), targetIvaa);
    if (!(onlyLocally)) {
      Iterable<SNode> dependentIvaas = IVariabilityAwareArtifact__BehaviorDescriptor.getDependenciesTransitivePlain_id3hajdyqDQD6.invoke(targetIvaa);
      ListSequence.fromList(ivaasForUpdate).addSequence(Sequence.fromIterable(dependentIvaas));
    }
    return ivaasForUpdate;
  }

  private static List<ArtifactVisualizationData> transformVisualizationData(ITopAffectedNodesProvider affectedNodes) {
    log("transform visualization data");

    final Iterable<ArtifactPath> instances = ListSequence.fromList(ivaasForUpdate).select((ivaa) -> (ArtifactPath) IVariabilityAwareArtifact__BehaviorDescriptor.getContextArtifactPath_id4I8sp9GPJNO.invoke(ivaa));
    log("Selected Instance Paths: " + Sequence.fromIterable(instances).select((it) -> check_ifwv5z_a0a0a0a0d0dc(it)));

    final List<ArtifactVisualizationData> data = ListSequence.fromList(new LinkedList<ArtifactVisualizationData>());

    SetSequence.fromSet(affectedNodes.getTopFilteredNodes()).where((node) -> Sequence.fromIterable(instances).contains(nodeInRecalculatedPath(node))).visitAll((it) -> ListSequence.fromList(data).addElement(createVisualizationData(it, PresenceConditionValue.FALSE)));

    SetSequence.fromSet(affectedNodes.getTopUndefinedNodes()).where((node) -> Sequence.fromIterable(instances).contains(nodeInRecalculatedPath(node))).visitAll((it) -> ListSequence.fromList(data).addElement(createVisualizationData(it, PresenceConditionValue.UNDEFINED)));

    return data;
  }

  private static ArtifactPath nodeInRecalculatedPath(SkeletonNode node) {
    if (check_ifwv5z_a0a75(node.getPivot())) {
      return node.getParent().getFullPath();
    } else {
      return node.getFullPath();
    }
  }

  private static ArtifactVisualizationData createVisualizationData(SkeletonNode skelNode, PresenceConditionValue value) {
    SNode originalNode = skelNode.getOriginalData();
    SNode ivaa = ArtifactHelper.findIVAA(originalNode);
    return new ArtifactVisualizationData(ivaa, originalNode, value);
  }

  private static void updateActiveEditor(SNode artifact) {
    EditorComponent editor = MapSequence.fromMap(editors).get(artifact);
    if (editor != null) {
      log(artifact, "update active editor after cleaning");
      editor.update();
    }
  }

  private static boolean canUpdate(SNode ivaa) {
    return (SLinkOperations.getTarget(ivaa, LINKS.configRef$mKqc) != null) && (SLinkOperations.getTarget(SLinkOperations.getTarget(ivaa, LINKS.configRef$mKqc), LINKS.featureConfig$pJ5X) != null);
  }

  public static boolean shouldBeUpdated(SNode artifact) {
    return ListSequence.fromList(getNodesToRender(artifact)).isEmpty();
  }

  public static boolean shouldBeRendered(SNode artifact) {
    return ListSequence.fromList(getNodesToRender(artifact)).isNotEmpty() && !(isRendered(artifact));
  }

  private static boolean isRendered(SNode artifact) {
    Object rs = artifact.getUserObject(RENDER_STATUS);
    if (null == rs) {
      return false;
    }
    if (rs.toString().equals(RENDERED)) {
      return true;
    }
    return false;
  }

  private static List<SNode> getNodesToRender(SNode artifact) {
    Object rs = artifact.getUserObject(RENDER_NODES);
    if (null == rs) {
      return new ArrayList<SNode>();
    }
    if (rs instanceof List) {
      return (List<SNode>) rs;
    }
    return new ArrayList<SNode>();
  }

  private static void putNodesToRender(SNode artifact, List<SNode> status) {
    artifact.putUserObject(RENDER_NODES, status);
  }

  private static boolean render(SNode artifact, EditorComponent editor) {
    Highlighter hlr = Highlighter.create(artifact, editor);
    if (null != hlr) {
      log(artifact, "rendering (" + (getNodesToRender(artifact)) + " nodes to be highlighted)");
      doHighlight(hlr, getNodesToRender(artifact));
      markAsRendered(artifact);
      return true;
    }
    return false;
  }

  private static void clearRenderStatus(SNode artifact) {
    log(artifact, "clearRenderStatus");
    markAsNotRendered(artifact);
    clearNodesToRender(artifact);
  }

  private static void markAsRendered(SNode artifact) {
    artifact.putUserObject(RENDER_STATUS, RENDERED);
  }

  private static void markAsNotRendered(SNode artifact) {
    artifact.putUserObject(RENDER_STATUS, null);
  }

  private static void clearNodesToRender(SNode artifact) {
    artifact.putUserObject(RENDER_NODES, null);
  }

  private static void doHighlight(final Highlighter highlighter, List<SNode> nodes) {
    highlighter.clear();
    ListSequence.fromList(nodes).visitAll((it) -> {
      Object color = it.getUserObject(NODE_COLOR);
      if (color != null && color instanceof Color) {
        highlighter.mark(it, (Color) color, "variability");
      }
    });
  }

  private static EditorComponent getEditorComponent(SNode root) {
    return (null == MapSequence.fromMap(editors).get(root) ? Highlighter.getEditorComponent(root) : MapSequence.fromMap(editors).get(root));
  }

  private static void log(SNode artifact, String txt) {
    if (debug) {
      {
        final SNode ivaa = artifact;
        if (SNodeOperations.isInstanceOf(ivaa, CONCEPTS.IVariabilityAwareArtifact$qo)) {
          log("[" + IVariabilityAwareArtifact__BehaviorDescriptor.artifactName_id7eAm6HphX4A.invoke(ivaa) + "] " + txt);
        } else if (SNodeOperations.isInstanceOf(ivaa, CONCEPTS.INamedConcept$Kd)) {
          final SNode namedConcept = artifact;

          log("[" + SPropertyOperations.getString(namedConcept, PROPS.name$MnvL) + "] " + txt);
        } else {
          log("[" + SNodeOperations.present(artifact) + "] " + txt);
        }
      }
    }
  }

  private static void log(String txt) {
    if (debug) {
      System.out.println("ArtifactInstancePreviewer: " + txt);
    }
  }

  private static void collectDataForPreviewer(SNode targetIvaa) {
    ivaasForUpdate = defineArtifactsForUpdate(targetIvaa, false);
    allRootNodes = SetSequence.fromSet(rootNodesWithLogicalChildren(ivaasForUpdate)).union(ListSequence.fromList(ivaasForUpdate).select((it) -> SNodeOperations.getContainingRoot(it))).distinct();

    editors = MapSequence.fromMap(new HashMap<SNode, EditorComponent>());
    for (SNode root : Sequence.fromIterable(allRootNodes)) {
      MapSequence.fromMap(editors).put(root, Highlighter.getEditorComponent(root));
    }
  }

  private static void updateNodesForInstance(SkeletonNode instanceRootNode, final SNode ivaa) {
    Iterable<SkeletonNode> nodesInArtifactRoot = ListSequence.fromList(instanceRootNode.getChildren()).where((it) -> belongsToRoot(it, IVariabilityAwareArtifact__BehaviorDescriptor.artifactRoot_id3q2wVeorTKs.invoke(ivaa)));

    Sequence.fromIterable(createVisualizationDataFor(nodesInArtifactRoot)).visitAll((node) -> node.applyPreviewCriteria());

  }

  private static Iterable<ArtifactVisualizationData> createVisualizationDataFor(Iterable<SkeletonNode> nodesInArtifactRoot) {
    return Sequence.fromIterable(nodesInArtifactRoot).select((it) -> createVisualizationData(it, getPresenceConditionValue(it)));
  }

  private static PresenceConditionValue getPresenceConditionValue(SkeletonNode skelNode) {
    SkeletonNode currentNode = skelNode;
    while (!(currentNode.hasVarPoint()) && !(currentNode.representsRootNode())) {
      currentNode = currentNode.getParent();
    }

    if (currentNode.hasVarPoint()) {
      return StateStore.get(currentNode.getVarPoint().get()).getState(nodeInRecalculatedPath(currentNode));
    } else {
      log("[" + skelNode.getLabel() + "]" + "getPresenceCondition - Force TRUE");
      return PresenceConditionValue.TRUE;
    }
  }

  private static boolean belongsToRoot(SkeletonNode skeletonNode, SNode localRoot) {
    SNode n = skeletonNode.getOriginal();
    // search upwards from the skeleton nodes AST node, until either finding localRoot, or reaching the root node
    while (!(Objects.equals(n, localRoot))) {
      if ((SNodeOperations.getParent(n) == null)) {
        return false;
      }
      n = SNodeOperations.getParent(n);
    }
    return true;
  }

  private static class Highlighter {
    private final NodeHighlightManager highlightMgr;
    private final EditorMessageOwner messageOwner;

    public static Highlighter create(SNode artifact, EditorComponent editor) {
      log(artifact, "creating highlighter (haveEditorComponent=" + (editor != null) + ")");
      if (editor == null) {
        return null;
      }
      NodeHighlightManager highlightMgr = editor.getHighlightManager();
      EditorMessageOwner messageOwner = editor.getHighlightMessagesOwner();
      highlightMgr.clearForOwner(messageOwner);
      return new Highlighter(highlightMgr, messageOwner);
    }

    private Highlighter(NodeHighlightManager hm, EditorMessageOwner mo) {
      this.highlightMgr = hm;
      this.messageOwner = mo;
    }

    public void mark(SNode n, Color col, String messageText) {
      highlightMgr.mark(n, col, messageText, messageOwner);
    }

    public void clear() {
      highlightMgr.clearForOwner(messageOwner);
    }

    public static EditorComponent getEditorComponent(final SNode containedNode) {
      Iterable<EditorComponent> editorComps = ListSequence.fromList(EditorComponentHacks.findAllInstances()).where((it) -> check_ifwv5z_a0a0a0a0a0l301(it) == SNodeOperations.getContainingRoot(containedNode));

      if (null == editorComps || Sequence.fromIterable(editorComps).isEmpty()) {
        return null;
      }
      return Sequence.fromIterable(editorComps).first();
    }
    private static SNode check_ifwv5z_a0a0a0a0a0l301(EditorComponent checkedDotOperand) {
      if (null != checkedDotOperand) {
        return checkedDotOperand.getEditedNode();
      }
      return null;
    }
  }

  /*package*/ static class ArtifactVisualizationData {
    public final SNode ivaa;
    public final SNode node;
    public final PresenceConditionValue presenceConditionValue;

    private ArtifactVisualizationData(final SNode ivaa, final SNode node, final PresenceConditionValue presenceConditionValue) {
      this.ivaa = ivaa;
      this.node = node;
      this.presenceConditionValue = presenceConditionValue;
    }

    private boolean isVisible() {
      return IPreviewableArtifact__BehaviorDescriptor.previewCriteria_id6ViAOjRttY.invoke(ivaa).isVisible(presenceConditionValue);
    }

    private void applyPreviewCriteria() {
      if (Objects.equals(previewCriteria, PreviewCriteria.criteria3)) {
        storeHighlightColors();
        storeRenderStatus();
      } else {
        {
          final SNode hidebleNode = node;
          if (SNodeOperations.isInstanceOf(hidebleNode, CONCEPTS.ICanHide$4s)) {
            if (isVisible()) {
              ICanHide__BehaviorDescriptor.show_id5I8v_DCoggH.invoke(hidebleNode);
            } else {
              ICanHide__BehaviorDescriptor.hide_id5I8v_DCofzu.invoke(hidebleNode);
            }
          }
        }
      }
    }

    private void storeRenderStatus() {
      SNode artifact = SNodeOperations.getContainingRoot(node);
      List<SNode> status = getNodesToRender(artifact);
      if (!(ListSequence.fromList(status).contains(node))) {
        ListSequence.fromList(status).addElement(node);
      }
      putNodesToRender(artifact, status);
    }

    private void storeHighlightColors() {
      if (null == presenceConditionValue) {
        log(this.ivaa, "== ERRO PC NULL: " + SNodeOperations.present(this.node));
      } else {
        if (presenceConditionValue.equals(PresenceConditionValue.FALSE)) {
          this.node.putUserObject(NODE_COLOR, JBColor.DARK_GRAY);
        }
        if (presenceConditionValue.equals(PresenceConditionValue.UNDEFINED)) {
          this.node.putUserObject(NODE_COLOR, JBColor.LIGHT_GRAY);
        }
        if (presenceConditionValue.equals(PresenceConditionValue.TRUE)) {
          this.node.putUserObject(NODE_COLOR, cleanWithTransparency());
        }
      }
    }

    private JBColor cleanWithTransparency() {
      return new JBColor(new Color(0, 0, 0, 1), new Color(0, 0, 0, 1));
    }
  }

  /**
   * The listener is used to render editors on open and reset render status on close.
   * It avoids re-computation of preview visualization data and assures update of editors 
   * that are closed in the moment of the computation.
   * 
   * It replaces the solution based on checking rules, because it could not be used with
   * logical children.
   */
  private static class PreviewerEditorListener implements EditorComponentCreateListener {
    private PreviewerEditorListener() {
    }

    @Override
    public void editorComponentCreated(@NotNull EditorComponent component) {
      SNode artifact = check_ifwv5z_a0a0c701(check_ifwv5z_a0a0a2de(component));
      if ((artifact != null) && ArtifactInstancePreviewer.shouldBeRendered(artifact)) {
        log(artifact, "editor created");
        ArtifactInstancePreviewer.render(artifact, component);
        log(artifact, "update active editor");
        component.update();
      }
    }

    @Override
    public void editorComponentDisposed(@NotNull final EditorComponent component) {
      SRepository repository = check_ifwv5z_a0a0e701(check_ifwv5z_a0a0a4de(component));
      final Wrappers._boolean isRendered = new Wrappers._boolean(false);
      final Wrappers._T<SNode> artifact = new Wrappers._T<SNode>();
      repository.getModelAccess().runReadAction(() -> {
        try {

          artifact.value = check_ifwv5z_a0b0a0a0a3a4de(check_ifwv5z_a0a1a0a0a0d0e701(component));
          if ((artifact.value != null)) {
            log(artifact.value, "listener - component disposed!!!");
            isRendered.value = ArtifactInstancePreviewer.isRendered(artifact.value);
          }

          if (isRendered.value) {
            log(artifact.value, "listener - component disposed - marking as not rendered");
            markAsNotRendered(artifact.value);
          }
        } catch (Exception e) {
          e.printStackTrace();
        }
      });

    }
    private static SNode check_ifwv5z_a0a0c701(SNode checkedDotOperand) {
      if (null != checkedDotOperand) {
        return checkedDotOperand.getContainingRoot();
      }
      return null;
    }
    private static SNode check_ifwv5z_a0a0a2de(EditorComponent checkedDotOperand) {
      if (null != checkedDotOperand) {
        return checkedDotOperand.getEditedNode();
      }
      return null;
    }
    private static SRepository check_ifwv5z_a0a0e701(EditorContext checkedDotOperand) {
      if (null != checkedDotOperand) {
        return checkedDotOperand.getRepository();
      }
      return null;
    }
    private static EditorContext check_ifwv5z_a0a0a4de(EditorComponent checkedDotOperand) {
      if (null != checkedDotOperand) {
        return checkedDotOperand.getEditorContext();
      }
      return null;
    }
    private static SNode check_ifwv5z_a0b0a0a0a3a4de(SNode checkedDotOperand) {
      if (null != checkedDotOperand) {
        return checkedDotOperand.getContainingRoot();
      }
      return null;
    }
    private static SNode check_ifwv5z_a0a1a0a0a0d0e701(EditorComponent checkedDotOperand) {
      if (null != checkedDotOperand) {
        return checkedDotOperand.getEditedNode();
      }
      return null;
    }
  }
  private static String check_ifwv5z_a0a0a0a0d0dc(ArtifactPath checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.asInstancePath();
    }
    return null;
  }
  private static boolean check_ifwv5z_a0a75(SkeletonNode.PivotInfo checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.isInstance();
    }
    return false;
  }

  private static final class PROPS {
    /*package*/ static final SProperty inPreview$Ox7X = MetaAdapterFactory.getProperty(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x41a5090d088f66bcL, 0x41a5090d0891713dL, "inPreview");
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept ICanHide$4s = MetaAdapterFactory.getInterfaceConcept(0x5fef253e34b0443dL, 0x80359a2928b716d3L, 0x5136578b182923d9L, "com.mbeddr.mpsutil.editor.displayControl.structure.ICanHide");
    /*package*/ static final SInterfaceConcept IVariationPointBase$F1 = MetaAdapterFactory.getInterfaceConcept(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x19503178dec840e6L, "org.iets3.variability.artifacts.base.structure.IVariationPointBase");
    /*package*/ static final SInterfaceConcept IContextFilterOwner$ly = MetaAdapterFactory.getInterfaceConcept(0xdcb9d48f1fb64793L, 0x88cff6f4971432a5L, 0x1ebc36697a4d5563L, "org.iets3.contextfilter.structure.IContextFilterOwner");
    /*package*/ static final SConcept ArtifactInstanceContextSelector$aN = MetaAdapterFactory.getConcept(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x3ef9945f640c3e60L, "org.iets3.variability.artifacts.base.structure.ArtifactInstanceContextSelector");
    /*package*/ static final SInterfaceConcept ILogicalChildOwner$nQ = MetaAdapterFactory.getInterfaceConcept(0x85a9bace37a140afL, 0x956a7bb1b081a77cL, 0x4d47311ce8608adL, "com.mbeddr.mpsutil.logicalChild.structure.ILogicalChildOwner");
    /*package*/ static final SInterfaceConcept IVariabilityAwareArtifact$qo = MetaAdapterFactory.getInterfaceConcept(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x716b3738b4b28e4bL, "org.iets3.variability.artifacts.base.structure.IVariabilityAwareArtifact");
    /*package*/ static final SInterfaceConcept INamedConcept$Kd = MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink configRef$mKqc = MetaAdapterFactory.getContainmentLink(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x716b3738b4b28e4bL, 0x35bab6d0bc28e906L, "configRef");
    /*package*/ static final SReferenceLink featureConfig$pJ5X = MetaAdapterFactory.getReferenceLink(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x48cf645483c30387L, 0x48cf645483c30388L, "featureConfig");
  }
}
