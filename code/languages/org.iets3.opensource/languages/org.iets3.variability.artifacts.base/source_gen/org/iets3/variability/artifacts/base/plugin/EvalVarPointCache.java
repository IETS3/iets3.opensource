package org.iets3.variability.artifacts.base.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.iets3.variability.configuration.base.behavior.AbstractFeatureConfiguration__BehaviorDescriptor;
import java.util.Optional;
import com.mbeddr.mpsutil.interpreter.rt.IContext;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.iets3.variability.artifacts.base.behavior.IVariabilityAwareArtifact__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.iets3.variability.artifacts.base.behavior.IVariationPointBase__BehaviorDescriptor;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import java.util.concurrent.ExecutionException;
import org.iets3.core.base.behavior.IDetectNeedToRunManually__BehaviorDescriptor;
import de.itemis.mps.utils.serializer.xml.serializer.NodeSerializer;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;

/**
 * A cache for the evaluation of variation point conditions against specific configuration states.
 * 
 * This allows avoiding unnecessary interpreter calls for evaluating presence conditions.
 * If the presence condition has been evaluated against the same configuration before and neither
 * the presence condition nor the configuration have been changed, the previous result will be
 * returned immediately.
 */
public final class EvalVarPointCache {
  private static final String VP_KEY = "EVAL_VP_CACHE";
  private static final String CONFIG_HASH = "CONFIG_HASH";

  private static final CacheStatistics statistics = new CacheStatistics();

  /**
   * Reset hashcode cache for a given configuration and its sub-configurations.
   * 
   * Call this once before using getEvalResult() for this configuration.
   * 
   * @param config the configuration to be initialized.
   */
  public static void resetHashcode(SNode config) {
    config.putUserObject(CONFIG_HASH, null);
    ListSequence.fromList(AbstractFeatureConfiguration__BehaviorDescriptor.getUsedSubConfigurations_id4I8sp9GGHJ2.invoke(config)).visitAll((it) -> it.putUserObject(CONFIG_HASH, null));
  }

  /**
   * Get the evaluation result of a variation point against a given configuration.
   * 
   * The result will be computed only once until the configuration or the variation point's
   * condition are changed. For subsequent calls, the cached result will be returned immediately.
   * 
   * @param vp variation point to be evaluated
   * @param config configuration to be evaluated against
   * @param context interpreter context (prepared as required by ArtifactHelper.isPresentTernary)
   * @return the evaluation result (a ternary value, i.e. true, false or null)
   */
  public static Optional<Boolean> getEvalResult(SNode vp, SNode config, IContext context) {
    EvalVarPointCache cache = getCache(vp);
    return cache.valueOf(config, context);
  }

  public static void flushCaches(SNode mainIVAA) {
    Iterable<SNode> ivaas = Sequence.fromIterable(Sequence.<SNode>singleton(mainIVAA)).concat(Sequence.fromIterable(IVariabilityAwareArtifact__BehaviorDescriptor.getDependenciesTransitivePlain_id3hajdyqDQD6.invoke(mainIVAA)));
    for (SNode ivaa : Sequence.fromIterable(ivaas)) {
      ListSequence.fromList(SNodeOperations.getNodeDescendants(ivaa, CONCEPTS.IVariationPointBase$F1, false, new SAbstractConcept[]{})).visitAll((vp) -> vp.putUserObject(VP_KEY, null));
    }
  }

  public static ICacheStatistics statistics() {
    return statistics;
  }

  private static EvalVarPointCache getCache(SNode vp) {
    int currentHashcode = (int) IVariationPointBase__BehaviorDescriptor.computeHash_id6s5puhjUPSP.invoke(vp);

    Object data = vp.getUserObject(VP_KEY);
    if (data != null && data instanceof EvalVarPointCache) {
      // we have a cached instance
      EvalVarPointCache cache = (EvalVarPointCache) data;
      if (cache.lastHashcode == currentHashcode) {
        // the cache is still valid
        return cache;
      }
    }

    // create a new instance and store it as user object of the VP
    EvalVarPointCache cache = new EvalVarPointCache(vp, currentHashcode);
    vp.putUserObject(VP_KEY, cache);
    return cache;
  }

  private SNode vp;
  private int lastHashcode;
  private Cache<Integer, Optional<Boolean>> cache = CacheBuilder.newBuilder().maximumSize(300).<Integer,Optional<Boolean>>build();

  private EvalVarPointCache(SNode vp, int vpHashcode) {
    this.vp = vp;
    this.lastHashcode = vpHashcode;
  }

  /**
   * For a specific varpoint's cache, get the evaluation result for a specific configuration.
   * 
   * Note that if a configuration's checkboxes or attribute values are being changed,
   * the cache will contain multiple values for each previous state of this configuration.
   * As the number of configurable states and thus the cache size might be big, we have to 
   * limit the cache size in order to avoid a memory leak. However, in practice we do not
   * expect to reach that limit.
   * 
   * @param config the configuration against the varpoint should be evaluated (or null if unspecified)
   * @param context the interpreter context (needed if no value in cache yet)
   * @return the ternary-valued evaluation result
   */
  private Optional<Boolean> valueOf(final SNode config, final IContext context) {
    // if the config is unspecified, we just use a constant hash here (as all unspecified configs of the same feature model behave the same, they are isomorphic)
    int hash = ((config != null) ? getConfigHash(config) : 0xCAFECAFE);

    try {
      statistics.countCall();
      Optional<Boolean> ternaryValue = this.cache.get(hash, () -> {
        statistics.countMiss();
        return Optional.ofNullable(ArtifactHelper.isPresentTernary(vp, config, context));
      });
      return ternaryValue;
    } catch (ExecutionException e) {
      throw new RuntimeException("Caching of Variation Points failed!", e);
    }
  }

  /**
   * Get the hashcode for the state of a configuration.
   * 
   * This is an extra level of optimization: We will need the configuration's hashcode very often,
   * so we cache it as user object at the configuration node. This is much cheaper than computing
   * it from scratch every time we need it.
   * 
   * Note that this requires a call to resetHashcode() before using the EvalVarPointCache in order
   * to avoid using an old hashcode for the configuration.
   * 
   * @param config the configuration we need the hashcode for
   * @return the configuration's hashcode
   */
  private static int getConfigHash(SNode config) {
    Object hash = config.getUserObject(CONFIG_HASH);
    if (hash != null) {
      return as_57uu7y_a0a0b0x(hash, Integer.class);
    }

    // cache miss, compute
    int hashcode = getHash(config);
    config.putUserObject(CONFIG_HASH, hashcode);
    return hashcode;
  }

  private static int getHash(SNode config) {
    {
      final SNode fmc = config;
      if (SNodeOperations.isInstanceOf(fmc, CONCEPTS.FeatureModelConfiguration$nE)) {
        return (int) IDetectNeedToRunManually__BehaviorDescriptor.calculateHash_id6MJy$PGsrIf.invoke(fmc);
      }
    }
    NodeSerializer s = new NodeSerializer(config, true, "__", true);
    return s.getXMLAsString().hashCode();
  }

  private static <T> T as_57uu7y_a0a0b0x(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept IVariationPointBase$F1 = MetaAdapterFactory.getInterfaceConcept(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x19503178dec840e6L, "org.iets3.variability.artifacts.base.structure.IVariationPointBase");
    /*package*/ static final SConcept FeatureModelConfiguration$nE = MetaAdapterFactory.getConcept(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x5cf5c0d0479ec915L, "org.iets3.variability.configuration.base.structure.FeatureModelConfiguration");
  }
}
