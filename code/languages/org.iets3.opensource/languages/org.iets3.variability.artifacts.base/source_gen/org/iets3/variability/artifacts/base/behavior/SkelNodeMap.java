package org.iets3.variability.artifacts.base.behavior;

/*Generated by MPS */

import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import java.util.HashMap;
import java.util.Objects;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.iets3.variability.artifacts.base.plugin.ArtifactHelper;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IMapping;

/**
 * A mapping from AST nodes to the corresponding skeleton tree nodes.
 * 
 * Note: Due to instantiation there might be more than one skeleton node for 
 *       an AST node, thus we have to provide an ArtifactPath to distinguish between
 *       these skeleton node instances.
 */
public class SkelNodeMap {
  private static class InstanceMap {
    private Map<ArtifactPath, SkeletonNode> path2skelnode = MapSequence.fromMap(new LinkedHashMap<ArtifactPath, SkeletonNode>(16, (float) 0.75, false));

    public void put(ArtifactPath path, SkeletonNode sn) {
      MapSequence.fromMap(path2skelnode).put(path, sn);
    }

    public SkeletonNode get(ArtifactPath path) {
      return MapSequence.fromMap(path2skelnode).get(path);
    }

    public Iterable<ArtifactPath> paths() {
      return MapSequence.fromMap(path2skelnode).keySet();
    }

    public List<SkeletonNode> skelNodes() {
      return Sequence.fromIterable(MapSequence.fromMap(path2skelnode).values()).toList();
    }

    @Override
    public String toString() {
      return "[" + IterableUtils.join(MapSequence.fromMap(path2skelnode).select((it) -> it.key().asInstancePath() + "=>" + it.value().getLabel()), ", ") + "]";
    }
  }

  /**
   * If this flag is false, only direct AST children can be resolved.
   */
  private final boolean supportLogicalParents;

  /**
   * A map from some AST node to all its instance-SkelNodes.
   * 
   * Note that for AST nodes which are pivot, the target node is used as the key.
   */
  private Map<SNode, InstanceMap> node2instances = MapSequence.fromMap(new LinkedHashMap<SNode, InstanceMap>(16, (float) 0.75, false));

  /**
   * For pivot nodes, get the Segment leading to the target node and the target node itself.
   * This is used to resolve pivot nodes, as they are not stored as keys in node2instances.
   */
  private Map<SNode, Tuples._2<Segment, SNode>> pivot2target = MapSequence.fromMap(new HashMap<SNode, Tuples._2<Segment, SNode>>());

  public SkelNodeMap() {
    this(false);
  }

  public SkelNodeMap(boolean supportLogicalParents) {
    this.supportLogicalParents = supportLogicalParents;
  }

  public void clear() {
    MapSequence.fromMap(node2instances).clear();
  }

  public void put(final SNode n, ArtifactPath path, final SkeletonNode sn) {
    Map<SNode, InstanceMap> m = node2instances;
    m.computeIfAbsent(n, (SNode keyNode) -> new InstanceMap()).put(path, sn);
    if (!(Objects.equals(n, sn.getOriginal()))) {
      path.lastSegment().ifPresent((seg) -> MapSequence.fromMap(pivot2target).put(sn.getOriginal(), MultiTuple.<Segment,SNode>from(seg, n)));
    }
  }

  public List<SkeletonNode> collectedSkeletonNodes() {
    return Sequence.fromIterable(MapSequence.fromMap(node2instances).values()).translate((it) -> it.skelNodes()).toList();
  }

  public SkeletonNode skeletonNodeFor(SNode n, ArtifactPath path) {
    // return null if either there is no entry for n, or if path is no known key in the instance mapping
    return check_kjm965_a1a81(MapSequence.fromMap(node2instances).get(n), path);
  }

  public SkeletonNode resolveSkeletonNode(SNode toBeResolved, ArtifactPath artifactPath) {
    // move upwards in AST to find a node which has a skeleton node also matching the artifactPath
    SNode n = toBeResolved;
    while ((n != null)) {
      // check if n belongs to a skeleton node (and matching the given artifact path)
      SkeletonNode sn = lookupNodeAtPath(n, artifactPath);
      if (sn != null) {
        // success: we found a skeleton node for the given artifactPath
        return sn;
      }

      // move up to parent (might be containment parent or logical owner)
      n = (supportLogicalParents ? ArtifactHelper.getLogicalParent(n) : SNodeOperations.getParent(n));
    }

    // the toBeResolved node is outside of any variability context (no IVAA has been found)
    return null;
  }

  private SkeletonNode lookupNodeAtPath(SNode n, ArtifactPath artifactPath) {
    // lookup first in standard map
    SkeletonNode sn = skeletonNodeFor(n, artifactPath);
    if (sn != null) {
      return sn;
    }

    // for pivot nodes, the instantiated node is stored as key in the node2instances map.
    // if we are resolving a node below the pivot node in the AST, we have to use the 
    // pivot2target map to find the correct key with the correct artifact path.
    if (MapSequence.fromMap(pivot2target).containsKey(n)) {
      Tuples._2<Segment, SNode> lastSegment = MapSequence.fromMap(pivot2target).get(n);
      SNode targetNode = lastSegment._1();

      // we have to append the final segment from the pivot node to the instantiated (target) node
      ArtifactPath targetPath = artifactPath.append(lastSegment._0());
      return skeletonNodeFor(targetNode, targetPath);
    }

    return null;
  }


  public void printSkelNodeMap() {
    System.out.println("------------------ SkelNodeMap ---------");
    for (IMapping<SNode, InstanceMap> e : MapSequence.fromMap(this.node2instances)) {
      System.out.println("-----> Node " + SNodeOperations.present(e.key()) + " concept " + SNodeOperations.getConcept(e.key()));
      InstanceMap instMap = e.value();
      if (instMap != null) {
        for (ArtifactPath artifactPath : Sequence.fromIterable(instMap.paths())) {
          System.out.println("---------> AP " + artifactPath);
        }
      }
      System.out.println("####################");
    }
    System.out.println("----------------------------END Node2SkelNode---------");
  }
  private static SkeletonNode check_kjm965_a1a81(InstanceMap checkedDotOperand, ArtifactPath path) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.get(path);
    }
    return null;
  }
}
