package org.iets3.variability.artifacts.base.behavior;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import org.iets3.core.expr.base.behavior.Expression__BehaviorDescriptor;
import jetbrains.mps.ide.httpsupport.runtime.base.HttpSupportUtil;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.IMapping;
import java.util.List;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;

/**
 * Create a graph of the skeleton tree in graphviz/dot format (for debugging).
 */
public class SkeletonTreeGraphCreator implements ISkeletonVisitor {

  private StringBuilder sb;

  private final boolean showVarExprs;

  public SkeletonTreeGraphCreator() {
    this(true);
  }

  public SkeletonTreeGraphCreator(boolean showVarExpressions) {
    this.showVarExprs = showVarExpressions;
  }

  public String draw(SkeletonNode skelRoot, boolean withReferences) {
    this.sb = new StringBuilder();
    sb.append("digraph Skel {\n");
    skelRoot.accept(this);
    sb.append("}\n");
    return sb.toString();
  }

  @Override
  public boolean visit(SkeletonNode sn) {
    // each node in the graph represents a SkeletonNode
    // skeleton nodes representing MPS root nodes are shown in yellow
    SNode orig = sn.getOriginal();
    String origConcept = SNodeOperations.getConcept(orig).getName();
    String label = BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(orig) + "\\n" + origConcept + "\\n" + orig.getNodeId();
    String pathStr = check_i3mtk4_a0f0l(sn.getFullPath());
    String fullPathStr = check_i3mtk4_a0g0l(sn.getFullPath());
    boolean hasFullPath = fullPathStr != null && (fullPathStr != null && fullPathStr.length() > 0);
    if (pathStr != null && (pathStr != null && pathStr.length() > 0)) {
      label += "\\npath: " + pathStr;
      if (!(hasFullPath)) {
        label += "\\n(no full path)";
      } else if (!(Objects.equals(fullPathStr, pathStr))) {
        label += "\\nfull path: " + fullPathStr;
      }
    } else if (hasFullPath) {
      label += "\\nfull path: " + fullPathStr;
    }

    SkeletonNode.PivotInfo pivot = sn.getPivot();
    if (pivot != null) {
      label += "\\npivot: " + pivot.getFMIncludePathString() + " / " + IVariabilityAwareArtifact__BehaviorDescriptor.artifactName_id7eAm6HphX4A.invoke(pivot.getTargetIVAA());
    }
    if (showVarExprs && Sequence.fromIterable(sn.getVarExpressions()).isNotEmpty()) {
      label += "\\nexprs: " + IterableUtils.join(Sequence.fromIterable(sn.getVarExpressions()).select((it) -> (String) Expression__BehaviorDescriptor.renderReadable_id4Y0vh0cfqjE.invoke(it)), ", ");
    }
    boolean hasVarPoints = sn.hasVarPoint();
    String styling = (!(hasVarPoints) ? ", style=filled, fillcolor=yellow" : "");
    if (sn.representsRootNode()) {
      styling += ", shape=rectangle";
    }
    if (pivot != null && !(pivot.isInstance())) {
      styling += ", shape=diamond";
    }
    String url = ", URL=\"" + HttpSupportUtil.getURL(orig) + "\"";
    sb.append("  N" + sn.getId() + " [label=\"" + label + "\"" + styling + url + "];\n");

    // draw a black/grey arrow to indicate nesting along the node hierarchy
    // (if the child doesn't contain own VarPoint, the line is drawn in grey)
    for (SkeletonNode c : ListSequence.fromList(sn.getChildren())) {
      boolean hasVarPointsChild = Sequence.fromIterable(c.varPoints()).count() > 0;
      String col = (hasVarPointsChild ? "black" : "grey");
      sb.append("  N" + sn.getId() + " -> N" + c.getId() + " [color=" + col + "];\n");
    }

    // draw a blue arrow to each dependent source (from it's governing node)
    for (SkeletonNode d : SetSequence.fromSet(sn.getDependents())) {
      sb.append("  N" + sn.getId() + " -> N" + d.getId() + " [color=blue];\n");
    }

    // draw a dashed orange arrow for each accumulated reference between two skeleton nodes.
    // the number indicates how many references from one node<> in the referring skeleton node
    // to any other node<> in the referenced skeleton node have been collected.
    for (IMapping<SkeletonNode, List<SReference>> ref : MapSequence.fromMap(sn.getReferrers())) {
      sb.append("  N" + ref.key().getId() + " -> N" + sn.getId() + " [label=\"" + ListSequence.fromList(ref.value()).count() + "\", style=dashed, color=orange];\n");
    }
    return true;
  }
  private static String check_i3mtk4_a0f0l(ArtifactPath checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.asSegmentPathString();
    }
    return null;
  }
  private static String check_i3mtk4_a0g0l(ArtifactPath checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.asSegmentPathString();
    }
    return null;
  }
}
