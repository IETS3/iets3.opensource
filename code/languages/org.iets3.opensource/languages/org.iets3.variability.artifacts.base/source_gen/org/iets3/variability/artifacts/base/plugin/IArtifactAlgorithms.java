package org.iets3.variability.artifacts.base.plugin;

/*Generated by MPS */

import java.util.Optional;
import org.iets3.variability.artifacts.base.behavior.ISolverCheckExtender;
import org.jetbrains.mps.openapi.model.SNode;
import org.iets3.variability.artifacts.base.behavior.ISkeletonTreeBuilder;
import org.iets3.variability.artifacts.base.behavior.SkeletonTreeBaseBuilder;
import org.iets3.variability.artifacts.base.behavior.SkeletonTree;
import org.iets3.variability.artifacts.base.behavior.StateStoreProvider;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.structure.ExtensionPoint;

public interface IArtifactAlgorithms {

  default Optional<ISolverCheckExtender> solverCheckExtenderFor(SNode st) {
    return Optional.empty();
  }

  default ISkeletonTreeBuilder skeletonTreeBuilder() {
    return new SkeletonTreeBaseBuilder();
  }

  default IArtifactEvaluator artifactEvaluator(SkeletonTree skt) {
    return IArtifactEvaluator.basicImpl();
  }

  default IArtifactEvaluator artifactEvaluator(SkeletonTree skt, StateStoreProvider ssp) {
    return IArtifactEvaluator.basicImpl();
  }

  default IFilterInstantiator filterInstantiator() {
    return new IFilterInstantiator() {};
  }

  default int priority() {
    return 0;
  }

  static IArtifactAlgorithms instance() {
    IArtifactAlgorithms template = Sequence.fromIterable(new ExtensionPoint<IArtifactAlgorithms>("org.iets3.variability.artifacts.base.artifactAlgorithmsExt").getObjects()).sort((it) -> it.priority(), false).first();
    LogUtil.log(template);
    return template;
  }

}
