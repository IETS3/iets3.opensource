package org.iets3.variability.artifacts.base.behavior;

/*Generated by MPS */

import org.iets3.variability.artifacts.base.plugin.IInstantationContext;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import java.util.Optional;
import jetbrains.mps.internal.collections.runtime.LinkedListSequence;
import java.util.LinkedList;
import org.iets3.variability.artifacts.base.plugin.SkeletonNodeEvaluator;
import java.util.Collection;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.iets3.variability.artifacts.base.plugin.INodeMapper;
import com.google.common.collect.Lists;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.iets3.variability.artifacts.base.plugin.ArtifactHelper;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Objects;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import com.google.common.collect.Iterables;
import org.iets3.variability.artifacts.vanguard.behavior.IVariationPoint__BehaviorDescriptor;
import java.util.Collections;
import org.iets3.variability.artifacts.base.plugin.IInstantiation;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class SkeletonNode implements IInstantationContext {
  private static int nextId = 100;
  private SNode original;

  /**
   * Dummy ArtifactPath
   */
  private ArtifactPath path = new ArtifactPath(null);
  private SkeletonNode parent = null;
  private List<SkeletonNode> children = ListSequence.fromList(new ArrayList<SkeletonNode>());
  private SNode genId;

  private Map<SkeletonNode, List<SReference>> referrers = MapSequence.fromMap(new HashMap<SkeletonNode, List<SReference>>());
  private List<SkeletonNode> references = ListSequence.fromList(new ArrayList<SkeletonNode>());

  private List<SNode> variabilityExpressions = ListSequence.fromList(new ArrayList<SNode>());

  public static class PivotInfo {
    private List<SNode> fmIncludePath = null;
    private SNode targetIVAA = null;
    private boolean isInstance = false;
    private SNode targetNode;


    public PivotInfo(SNode fmInclude, SNode targetIVAA, boolean isInstance, SNode targetNode) {
      this.fmIncludePath = ListSequence.fromListAndArray(new ArrayList<SNode>(), fmInclude);
      this.targetIVAA = targetIVAA;
      this.isInstance = isInstance;
      this.targetNode = targetNode;
    }

    public PivotInfo(Iterable<SNode> fmIncludePath, SNode targetIVAA, boolean isInstance, SNode targetNode) {
      this.fmIncludePath = Sequence.fromIterable(fmIncludePath).toList();
      this.targetIVAA = targetIVAA;
      this.isInstance = isInstance;
      this.targetNode = targetNode;
    }

    public boolean isInstance() {
      return this.isInstance;
    }

    public Iterable<SNode> getFMIncludePath() {
      return ListSequence.fromList(this.fmIncludePath).where((it) -> (it != null));
    }

    public String getFMIncludePathString() {
      return IterableUtils.join(ListSequence.fromList(this.fmIncludePath).select((it) -> SPropertyOperations.getString(it, PROPS.name$MnvL)), ".");
    }

    public SNode getTargetIVAA() {
      return this.targetIVAA;
    }

    public SNode getTargetNode() {
      return this.targetNode;
    }

    @Override
    public String toString() {
      return new ToStringBuilder(this, ToStringStyle.MULTI_LINE_STYLE).append("fmIncludePath", this.fmIncludePath).append("targetIVAA", BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(this.targetIVAA)).append("isInstance", this.isInstance).toString();
    }
  }

  private PivotInfo pivotInfo = null;

  private Optional<SNode> variationPoint = Optional.empty();
  private List<SNode> prerequisites = LinkedListSequence.fromLinkedList(new LinkedList<SNode>());
  private SkeletonNodeEvaluator structuralEvaluator = null;
  private Collection<_FunctionTypes._void_P1_E0<? super INodeMapper>> prerequistesDeletionHandles = Lists.newLinkedList();
  private Set<SkeletonNode> dependsOn = SetSequence.fromSet(new HashSet<SkeletonNode>());
  private Set<SkeletonNode> dependents = SetSequence.fromSet(new HashSet<SkeletonNode>());
  private SNode tabularVarPoint = null;
  private static final String KEY2 = "SKELETON_NODE2";


  public SkeletonNode(SNode original, SNode varPoint, SkeletonNode parent, ArtifactPath path) {
    this.original = original;
    this.genId = createIntegerConstant_dahqtj_a0b0bb(nextId++);
    this.parent = parent;
    this.path = path;
    this.variationPoint = Optional.ofNullable(varPoint);
    original.putUserObject(KEY2, this);
  }

  public SkeletonNode(SNode original, SkeletonNode parent, SNode tabularVarPoint, ArtifactPath path) {
    this.original = original;
    this.genId = createIntegerConstant_dahqtj_a0b0db(nextId++);
    this.parent = parent;
    this.tabularVarPoint = tabularVarPoint;
    original.putUserObject(KEY2, this);
  }


  public static SkeletonNode enclosingSkelNode(SNode childNode) {
    SNode n = childNode;
    do {
      Object sn = n.getUserObject(KEY2);
      if (sn != null) {
        return (SkeletonNode) sn;
      }
      n = ArtifactHelper.getLogicalParent(n);
    } while ((n != null));
    return null;
  }

  public void insertChild(final SkeletonNode n) {
    // check if there is a child with n as new parent (also works if children is empty)
    List<SkeletonNode> childrenOnPath = ListSequence.fromList(children).where((it) -> n.isBetween(it, SkeletonNode.this)).toList();
    if (ListSequence.fromList(childrenOnPath).isEmpty()) {
      // no children have to be moved, just add n as new child
      ListSequence.fromList(children).addElement(n);
    } else {
      // insert new node between this node and childrenOnPath
      int idx = ListSequence.fromList(children).indexOf(ListSequence.fromList(childrenOnPath).first());
      ListSequence.fromList(children).insertElement(idx, n);
      ListSequence.fromList(childrenOnPath).visitAll((ch) -> ch.moveToOtherParent(n));
    }
  }

  private void moveToOtherParent(SkeletonNode newParent) {
    SkeletonNode oldParent = this.parent;
    ListSequence.fromList(newParent.children).addElement(this);
    this.parent = newParent;
    ListSequence.fromList(oldParent.children).removeElement(this);
  }

  private boolean isBetween(SkeletonNode south, SkeletonNode north) {
    SNode i = SNodeOperations.getParent(south.original);
    SNode watchFor = this.original;
    while ((i != null) && !(Objects.equals(i, north.original))) {
      if (Objects.equals(i, watchFor)) {
        return true;
      }
      i = SNodeOperations.getParent(i);
    }
    return false;
  }

  public void addReferenceTo(SkeletonNode target, SReference ref) {
    ListSequence.fromList(references).addElement(target);
    target.addReferenceFrom(this, ref);
  }

  private void addReferenceFrom(SkeletonNode src, SReference ref) {
    if (!(MapSequence.fromMap(referrers).containsKey(src))) {
      MapSequence.fromMap(referrers).put(src, ListSequence.fromList(new ArrayList<SReference>()));
    }
    ListSequence.fromList(MapSequence.fromMap(referrers).get(src)).addElement(ref);
  }

  public void addMaster(SkeletonNode master) {
    if (SetSequence.fromSet(dependsOn).contains(master)) {
      return;
    }
    SetSequence.fromSet(dependsOn).addElement(master);
    SetSequence.fromSet(master.dependents).addElement(this);
  }

  public void addVarExpressions(SNode varExpr) {
    ListSequence.fromList(variabilityExpressions).addElement(varExpr);
  }

  public void setPivot(PivotInfo pivot) {
    this.pivotInfo = pivot;
  }

  public PivotInfo getPivot() {
    return this.pivotInfo;
  }

  public SNode getOriginal() {
    return this.original;
  }

  /**
   * 
   * @deprecated Use getFullPath() instead.
   */
  @Deprecated(since = "2025-03-02")
  public ArtifactPath getPath() {
    return getFullPath();
  }

  public ArtifactPath getFullPath() {
    if (this.path == null) {
      return null;
    }
    if (this.pivotInfo == null) {
      return this.path;
    }
    if (ListSequence.fromList(this.pivotInfo.fmIncludePath).count() > 1) {
      System.err.println("ERROR in SkeletonNode: Calling getFullPath() for fmIncludes with more than one segment is not supported!");
    }
    return this.path;
  }

  /**
   * Return the data for the original node, excluding the presence condition.
   * 
   * The normal case is that the original node itself will be returned here.
   * However, if the original node itself implements the variation point, some child node
   * should be returned in order to exclude the presence condition.
   * This is used esp. for highlighting, because the presence condition should be highlighted
   * differently than the original node.
   * 
   * @return the main node representing the original node
   */
  public SNode getOriginalData() {
    if (this.variationPoint.isPresent() && Objects.equals(this.variationPoint.get(), this.original)) {
      // the original node implements the IVariationPoint interface, i.e., its editor will show the condition itself
      return IVariationPointBase__BehaviorDescriptor.artifactNodeData_id3PRltoWVL10.invoke(this.variationPoint.get());
    }
    return this.original;
  }

  public boolean representsRootNode() {
    // if we are in a testcase environment, the original node's parent will not be null
    // (it will be the NodesTestCase or similar)
    return this.parent == null || (SNodeOperations.getParent(this.original) == null) || SNodeOperations.isInstanceOf(SNodeOperations.getParent(this.original), CONCEPTS.ITestCase$Fp);
  }

  public SkeletonNode getParent() {
    return this.parent;
  }

  public int getId() {
    return SPropertyOperations.getInteger(this.genId, PROPS.value$jgCM);
  }

  public SNode genId() {
    return this.genId;
  }

  public String getLabel() {
    // ToDo this is very very dangerous. The method says its only used for presentation. But usages shows 
    // that it is used for discrimination
    return (String) BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(original);
  }

  public String pathSuffix() {
    ArtifactPath path = this.getFullPath();
    return (path != null && path.segmentsSize() > 1 ? "__" + path.asNameForSkeletonNode() : "");
  }

  public String getQuotedLabel() {
    return "'" + getLabel() + "'";
  }

  /**
   * Return string which identifies the skeleton node uniquely (even with instantiation).
   * 
   * This is needed for checking the skeleton tree in tests.
   */
  public String getUniqueLabel() {
    String result = BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(original);
    if (this.path != null) {
      String path = this.path.asNameForSolver();
      if ((path != null && path.length() > 0)) {
        if (getPivot() != null) {
          // if this skeleton node has a pivot (i.e., it is an instance node),
          // the path already includes the label of the original node
          return path;
        } else {
          // otherwise (i.e., no pivot), include the name of the original node
          return result + "_" + path;
        }
      }
    }
    return result;
  }

  public String getFullPathLabel() {
    ArtifactPath fullPath = getFullPath();
    if (fullPath == null) {
      return BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(original);
    }
    return fullPath.asInstancePath();
  }

  public List<SkeletonNode> getChildren() {
    return this.children;
  }

  public Map<SkeletonNode, List<SReference>> getReferrers() {
    return this.referrers;
  }

  public List<SkeletonNode> getReferenceTargets() {
    return this.references;
  }

  public Iterable<SNode> getVarExpressions() {
    return this.variabilityExpressions;
  }

  public void accept(ISkeletonVisitor visitor) {
    boolean recurse = visitor.visit(this);
    if (recurse) {
      for (SkeletonNode cn : ListSequence.fromList(this.children)) {
        cn.accept(visitor);
      }
    }
    visitor.visitEnd(this);
  }

  public boolean hasVarPoint() {
    return this.variationPoint.isPresent() || (CollectionSequence.fromCollection(this.getPrerequisites()).count()) > 0;
  }

  public Optional<SNode> getVarPoint() {
    return this.variationPoint;
  }

  public void addPrerequisite(PrerequisiteHolder holder) {
    ListSequence.fromList(this.prerequisites).addElement(createAdhocVarPoint_dahqtj_a0a0a29(this.original, holder.expressionCondition));
    this.prerequistesDeletionHandles.add(holder.deletionHandle);
  }

  public void addStructuralEvaluator(SkeletonNodeEvaluator e) {
    this.structuralEvaluator = e;
  }

  public Optional<SkeletonNodeEvaluator> getStructuralEvaluator() {
    return Optional.ofNullable(this.structuralEvaluator);
  }

  public void deleteOriginalPrerequisites(INodeMapper mapper) {
    for (_FunctionTypes._void_P1_E0<? super INodeMapper> handle : CollectionSequence.fromCollection(this.prerequistesDeletionHandles)) {
      handle.invoke(mapper);
    }
  }

  public Iterable<SNode> varPoints() {
    final Iterable<SNode> prerequisites = this.getPrerequisites();
    return this.variationPoint.map((SNode ivp) -> Iterables.concat(Sequence.singleton(ivp), prerequisites)).orElse(prerequisites);
  }

  public Iterable<SNode> getConditionExpressions() {
    return Sequence.fromIterable(varPoints()).select((vp) -> (Optional<SNode>) IVariationPoint__BehaviorDescriptor.getPresenceCondition_id4G1C74Q8D4_.invoke(vp)).where((it) -> it.isPresent()).select((it) -> it.get());
  }

  public Collection<SNode> getPrerequisites() {
    return this.prerequisites;
  }


  public String getVarPointAsString() {
    if (variationPoint.isPresent()) {
      return IVariationPointBase__BehaviorDescriptor.getConditionAsString_id7Ca9tj9CeW1.invoke(variationPoint.get());
    } else {
      return "";
    }
  }

  public Iterable<SNode> getVarPointsNested() {
    List<SNode> local = Collections.singletonList(this.variationPoint.get());
    SkeletonNode parent = getParent();
    if (parent != null && parent.variationPoint.isPresent()) {
      return Sequence.fromIterable(parent.getVarPointsNested()).union(ListSequence.fromList(local));
    } else {
      return local;
    }
  }

  public SNode getTabular() {
    return this.tabularVarPoint;
  }

  public Set<SkeletonNode> getDependents() {
    return Collections.unmodifiableSet(this.dependents);
  }
  public Set<SkeletonNode> getDependsOn() {
    return Collections.unmodifiableSet(this.dependsOn);
  }


  @Override
  public String toString() {
    return new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE).append("original", this.original).toString();
  }

  @Override
  public List<? extends IInstantiation> instantationPath() {
    return this.path.segmentsAsList();
  }
  private static SNode createIntegerConstant_dahqtj_a0b0bb(int p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.IntegerConstant$Na);
    n0.setProperty(PROPS.value$jgCM, "" + (p0));
    return n0.getResult();
  }
  private static SNode createIntegerConstant_dahqtj_a0b0db(int p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.IntegerConstant$Na);
    n0.setProperty(PROPS.value$jgCM, "" + (p0));
    return n0.getResult();
  }
  private static SNode createAdhocVarPoint_dahqtj_a0a0a29(SNode p0, SNode p1) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AdhocVarPoint$bT);
    n0.forChild(LINKS.artifact$eTvp).initNode(p0, CONCEPTS.BaseConcept$gP, true);
    n0.forChild(LINKS.featureExpr$cJRc).initNode(p1, CONCEPTS.Expression$D_, true);
    return n0.getResult();
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty value$jgCM = MetaAdapterFactory.getProperty(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc59b314L, 0xf8cc59b315L, "value");
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept ITestCase$Fp = MetaAdapterFactory.getInterfaceConcept(0xf61473f9130f42f6L, 0xb98d6c438812c2f6L, 0x11b2709bd56L, "jetbrains.mps.baseLanguage.unitTest.structure.ITestCase");
    /*package*/ static final SConcept IntegerConstant$Na = MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc59b314L, "jetbrains.mps.baseLanguage.structure.IntegerConstant");
    /*package*/ static final SConcept AdhocVarPoint$bT = MetaAdapterFactory.getConcept(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x37ad9e34b79dfe1cL, "org.iets3.variability.artifacts.base.structure.AdhocVarPoint");
    /*package*/ static final SConcept BaseConcept$gP = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept");
    /*package*/ static final SConcept Expression$D_ = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x670d5e92f854a047L, "org.iets3.core.expr.base.structure.Expression");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink artifact$eTvp = MetaAdapterFactory.getContainmentLink(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x37ad9e34b79dfe1cL, 0x37ad9e34b79e00d9L, "artifact");
    /*package*/ static final SContainmentLink featureExpr$cJRc = MetaAdapterFactory.getContainmentLink(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0xe86d1af52aae5ceL, 0x55275f0cc818c452L, "featureExpr");
  }
}
