package org.iets3.variability.artifacts.base.behavior;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;

/**
 * In an artifact model with instantiation, this class provides a mapping from each IVAA to its instances.
 * Each instance is thereby represented as a skeleton node.
 */
public class ArtifactInstances {
  /**
   * Initialization method which maps each IVAA to the list of skeleton nodes representing its instances.
   * This method should be used for a 150% model. It will contain all possible instances.
   * 
   * @param skelTree the skeleton tree to be used as an input
   */
  public static void attachAll(SkeletonTree skelTree) {
    attachAux(skelTree, new Attacher());
  }

  /**
   * Initialization method which maps each IVAA to the list of skeleton nodes representing its instances,
   * but restricts this to the instances which are actually present in an 100% model.
   * 
   * @param skelTree the skeleton tree to be used as an input
   * @param topFiltered the list of top-filtered skeleton nodes, based on a specific variant configuration
   */
  public static void attachExisting(SkeletonTree skelTree, Iterable<SkeletonNode> topFiltered) {
    // use an attacher which filters by set of actually existing instances
    attachAux(skelTree, new Attacher(topFiltered));
  }

  private static void attachAux(SkeletonTree skelTree, Attacher attacher) {
    // attach to root (it always exists)
    ArtifactInstances.attach(skelTree.getArtifact(), skelTree.getSkeletonRoot());

    // attach instances by traversing the skeleton tree
    skelTree.accept(attacher);
  }

  private static final String KEY = "ARTIFACT_INST";

  public static class Instance {
    private final SkeletonNode skelnode;

    public Instance(SkeletonNode sn) {
      skelnode = sn;
    }

    public SkeletonNode skeletonNode() {
      return this.skelnode;
    }
  }

  public static void clear(SNode ivaa) {
    ivaa.putUserObject(KEY, null);
  }

  private static void attach(SNode instantiated, SkeletonNode skelnode) {
    artifactInstancesOf(instantiated).addInstance(skelnode);
  }

  /**
   * This handles the low-level data structure for mapping the instances.
   * The mapping is stored as a user object at each IVAA
   */
  private static ArtifactInstances artifactInstancesOf(SNode ivaa) {
    Object obj = ivaa.getUserObject(KEY);
    if (obj != null && obj instanceof ArtifactInstances) {
      return (ArtifactInstances) obj;
    } else {
      ArtifactInstances aiNew = new ArtifactInstances();
      ivaa.putUserObject(KEY, aiNew);
      return aiNew;
    }
  }

  public static ArtifactInstances get(SNode ivaa) {
    Object obj = ivaa.getUserObject(KEY);
    if (obj instanceof ArtifactInstances) {
      ArtifactInstances ai = (ArtifactInstances) obj;
      return ai;
    }
    return null;
  }

  /**
   * Get skeleton node representing the first instance of an IVAA, or null if no instances exist.
   */
  public static SkeletonNode getFirstInstance(SNode ivaa) {
    ArtifactInstances ai = get(ivaa);
    if (ai == null) {
      return null;
    }
    Iterable<SkeletonNode> insts = ai.getInstances();
    if (Sequence.fromIterable(insts).isEmpty()) {
      return null;
    }
    return Sequence.fromIterable(insts).first();
  }

  private List<Instance> instances = ListSequence.fromList(new ArrayList<Instance>());

  private ArtifactInstances() {
  }

  public void addInstance(SkeletonNode sn) {
    ListSequence.fromList(this.instances).addElement(new Instance(sn));
  }

  public Iterable<SkeletonNode> getInstances() {
    return ListSequence.fromList(this.instances).select((it) -> it.skeletonNode());
  }


  /**
   * Helper class which traverses the skeleton tree and does the actual attaching.
   * It has two operation modes depending on which constructor is being used.
   */
  private static class Attacher implements ISkeletonVisitor {
    private final Set<SkeletonNode> topFiltered;

    /**
     * With this constructor, all instances will be attached.
     */
    public Attacher() {
      topFiltered = null;
    }

    /**
     * With this constructor, only instances which are not filtered will be attached.
     * 
     * @param topFiltered the top-filtered nodes in the skeleton tree (result of ArtifactEvaluator)
     */
    public Attacher(Iterable<SkeletonNode> topFiltered) {
      this.topFiltered = SetSequence.fromSet(new HashSet<SkeletonNode>());
      Sequence.fromIterable(topFiltered).visitAll((it) -> SetSequence.fromSet(Attacher.this.topFiltered).addElement(it));
    }

    @Override
    public boolean visit(SkeletonNode sn) {
      boolean isFiltered = topFiltered != null && SetSequence.fromSet(topFiltered).contains(sn);
      if (!(isFiltered)) {
        SkeletonNode.PivotInfo pivot = sn.getPivot();
        if (pivot != null && pivot.isInstance() && Sequence.fromIterable(pivot.getFMIncludePath()).isNotEmpty()) {
          ArtifactInstances.attach(pivot.getTargetIVAA(), sn);
        }
      }

      // visit all children recursively, if this node is not filtered
      return !(isFiltered);
    }
  }
}
