package org.iets3.variability.artifacts.base.behavior;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.model.SReference;
import java.util.List;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.Sequence;

public class ReferenceResolved {

  public static Iterable<ReferenceResolved> forReferencesOf(final SNode contextIVAA, SNode n) {
    return ListSequence.fromList(SNodeOperations.getReferences(n)).select((ref) -> forReference(contextIVAA, ref));
  }

  public static ReferenceResolved forReference(SNode contextIVAA, SReference ref) {
    // check if the reference target node is a pivot
    SNode refTarget = ref.getTargetNode();
    Pivot pivot = IVariabilityAwareArtifact__BehaviorDescriptor.getInstantiatedSubtree_id5LihCoMjncG.invoke(contextIVAA, refTarget);
    if (pivot == null) {
      // normal reference (without instantiation)
      return new ReferenceResolved(ref);
    } else {
      // reference to a pivot node, add relative path (only one segment)
      return new ReferenceResolved(ref, pivot.getTargetNode(), pivot.asSegment());
    }
  }

  public final SReference ref;
  public final SNode target;
  public List<Segment> relativePath = Collections.emptyList();

  /**
   * Constructor for standard case, i.e., without instantiation.
   * 
   * @param ref the SModel reference
   */
  public ReferenceResolved(SReference ref) {
    // this uses the actual target node of the reference as target Â 
    this(ref, ref.getTargetNode());
  }

  /**
   * Constructor for reference to a target which is an instantiation (i.e., the target node is a pivot).
   * 
   * This is the special case where the relative path consists of only one segment.
   * 
   * @param ref the reference
   * @param target the logical target of the reference (might be the instantiated node)
   * @param relativePath the relativePath consisting of just one segment
   */
  public ReferenceResolved(SReference ref, SNode target, Segment relativePath) {
    this(ref, target);
    this.relativePath = Collections.<Segment>singletonList(relativePath);
  }

  /**
   * Constructor for reference to a target which is an instantiation (i.e., the target node is a pivot).
   * 
   * @param ref the reference
   * @param target the logical target of the reference (might be a nested instantiate node)
   * @param relativePath the relativePath consisting of one or more segments
   */
  public ReferenceResolved(SReference ref, SNode target, Iterable<Segment> relativePath) {
    this(ref, target);
    this.relativePath = Collections.unmodifiableList(Sequence.fromIterable(relativePath).toList());
  }

  /**
   * Auxiliary constructor (private).
   */
  private ReferenceResolved(SReference ref, SNode target) {
    this.ref = ref;
    this.target = target;
  }

  @Override
  public String toString() {
    return "RefResolved(" + ref + ", " + SNodeOperations.present(target) + ", " + relativePath + ")";
  }
}
