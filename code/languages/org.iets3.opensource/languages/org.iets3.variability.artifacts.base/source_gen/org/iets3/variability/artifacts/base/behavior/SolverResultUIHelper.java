package org.iets3.variability.artifacts.base.behavior;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import java.util.List;
import org.iets3.core.base.behavior.IResult;
import org.iets3.variability.base.behavior.MpsActions;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.Collections;
import org.iets3.core.base.behavior.AbstractResultDescription;
import com.intellij.openapi.application.ApplicationManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.iets3.core.base.behavior.IDetectNeedToRunManually__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.iets3.analysis.solversupport.util.plugin.IResultUtil;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import java.util.Objects;
import org.iets3.core.base.behavior.ICanStoreCheckResult__BehaviorDescriptor;
import org.iets3.variability.artifacts.base.plugin.ArtifactHelper;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.nodeEditor.EditorComponent;
import de.slisson.mps.hacks.editor.EditorComponentHacks;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class SolverResultUIHelper {
  private static final Logger LOG = Logger.getLogger(SolverResultUIHelper.class);
  public static void postProcessUI(List<IResult> results, MpsActions.Impl executeCommand, SNode ivaa) {
    highlightResult(massage(results), executeCommand, ivaa);
  }

  /**
   * TODO: What does this method do? The name "massage" is quite generic... 
   */
  private static IResult massage(List<IResult> results) {
    List<IResult> results2 = results;
    final List<IResult> restResultList = (ListSequence.fromList(results2).count() > 1 ? ListSequence.fromList(results2).subListSequence(1, ListSequence.fromList(results2).count()) : Collections.<IResult>emptyList());
    final List<IResult> subResults = ListSequence.fromList(restResultList).translate((it) -> it.getSubResults()).toList();

    final IResult first = ListSequence.fromList(results2).getElement(0);
    return new IResult() {
      @Override
      public boolean isOk() {
        return first.isOk();
      }

      @Override
      public Object getErrorMessage() {
        return first.getErrorMessage();
      }

      /**
       * 
       * @deprecated 
       */
      @Deprecated(since = "17.10.2024")
      @Override
      public AbstractResultDescription getDescription() {
        return first.getDescription();
      }


      @Override
      public Iterable<SNode> targetNodes() {
        return first.targetNodes();
      }

      @Override
      public IResult.MessageType messageType() {
        return first.messageType();
      }

      @Override
      public Iterable<IResult> getSubResults() {
        return subResults;
      }
    };
  }

  private static void highlightResult(final IResult res, final MpsActions.Impl executeCommand, final SNode ivaa) {
    // this part is different from the super-method, we have to attach the results to different roots
    // (as target nodes might be not only from current IVAA, but also its dependencies)
    ApplicationManager.getApplication().invokeLaterOnWriteThread(() -> executeCommand.commandAction(() -> {
      try {
        List<SNode> resultStorers = storeResult(res);
        // the solver ran on this artifact, update hash to wait for next model change until solver runs again

        updateEditors(resultStorers);
        SPropertyOperations.assign(ivaa, PROPS.isRunning$8CV2, false);
        IDetectNeedToRunManually__BehaviorDescriptor.updateHash_id6MJy$PGs_q4.invoke(ivaa);
      } catch (Throwable t) {
        SPropertyOperations.assign(ivaa, PROPS.isRunning$8CV2, false);
        throw new RuntimeException(t);
      }
    }));
  }

  private static List<SNode> storeResult(IResult cr) {
    List<SNode> resultStorers = Sequence.fromIterable(IResultUtil.allTargetNodes(cr)).select((it) -> resultStorer(it)).distinct().toList();
    for (final SNode rs : ListSequence.fromList(resultStorers)) {
      // don't attach the full IResult to each resultStorer, but only a reduced filtered copy of it
      _FunctionTypes._return_P1_E0<? extends Boolean, ? super SNode> pred = (SNode target) -> Objects.equals(resultStorer(target), rs);
      IResult filteredResult = cr.cloneWithTargetFilter(pred);
      if (filteredResult != null) {
        if (LOG.isDebugLevel()) {
          LOG.debug("filtered: " + filteredResult);
        }
        ICanStoreCheckResult__BehaviorDescriptor.storeLastResult_id3R3AIvuq5Dp.invoke(rs, filteredResult);
      }
    }
    return resultStorers;
  }

  private static SNode resultStorer(SNode target) {
    SNode ivaa = ArtifactHelper.findIVAA(target);
    if ((ivaa == null)) {
      if (LOG.isErrorLevel()) {
        LOG.error("Cannot find IVAA for node " + BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(target) + " in order to store model check result");
      }
    }
    return ivaa;
  }

  private static void updateEditors(List<SNode> resultStorers) {
    // update all editors where errors/warnings have been attached
    final Iterable<SNode> roots = ListSequence.fromList(resultStorers).select((it) -> SNodeOperations.getContainingRoot(it));
    Iterable<EditorComponent> rootECs = ListSequence.fromList(EditorComponentHacks.findAllInstances()).where((it) -> Sequence.fromIterable(roots).contains(it.getEditedNode()));
    Sequence.fromIterable(rootECs).visitAll((it) -> it.update());
  }

  private static final class PROPS {
    /*package*/ static final SProperty isRunning$8CV2 = MetaAdapterFactory.getProperty(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x716b3738b4b28e4bL, 0x4f7dcb45a3f449c3L, "isRunning");
  }
}
