package org.iets3.variability.artifacts.base.behavior;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import com.google.common.collect.Lists;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import com.mbeddr.mpsutil.logicalChild.behavior.ILogicalChildOwner__BehaviorDescriptor;
import org.iets3.variability.artifacts.base.plugin.ArtifactHelper;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;

public class SkelTreeBuildUtil {
  public static final SkelTreeBuildUtil instance = new SkelTreeBuildUtil();

  private SkelTreeBuildUtil() {
  }

  /**
   * 
   * @deprecated Use two-parameter relevantChildren() instead
   */
  @Deprecated(since = "2025-07-21")
  public List<SNode> relevantChildren(SNode n) {
    return relevantChildren(n, Sequence.fromIterable(Collections.emptyList()));
  }

  /**
   * Return all relevant children of a given AST node. This includes:
   * - the actual children of the node based on the containment hierarchy
   * - the logical children of the node (if it is a ILogicalChildOwner)
   * 
   * @param n the input node
   * @param toBeSkipped a set of nodes which will be skipped if found among the children
   * @return all direct and logical children, excluding the skip-node (if any)
   */
  public List<SNode> relevantChildren(SNode n, final Iterable<SNode> toBeSkipped) {
    // start with actual AST children (but exclude the toBeSkipped-nodes, if any)
    List<SNode> children = Lists.newLinkedList(ListSequence.fromList(SNodeOperations.getChildren(n)).where((it) -> !(Sequence.fromIterable(toBeSkipped).contains(it))));

    // add logical children, if any
    {
      final SNode owner = n;
      if (SNodeOperations.isInstanceOf(owner, CONCEPTS.ILogicalChildOwner$nQ)) {
        Iterable<SNode> logicalChildren = Sequence.fromIterable(ILogicalChildOwner__BehaviorDescriptor.findLogicalChildren_id7c93VeVMIYV.invoke(owner)).toList();
        ListSequence.fromList(children).addSequence(Sequence.fromIterable(logicalChildren));
      }
    }

    return Sequence.fromIterable((ListSequence.fromList(children).where((it) -> !(SkelTreeBuildUtil.this.isCommentedOut(it))).where((it) -> !(SNodeOperations.isInstanceOf(it, CONCEPTS.AbstractTestNodeAnnotation$lh))).where((it) -> !(SNodeOperations.isInstanceOf(it, CONCEPTS.IVariabilityAwareArtifact$qo))).where((it) -> !(SNodeOperations.isInstanceOf(it, CONCEPTS.IArtifactInstance$ce))))).toList();
  }

  private boolean isCommentedOut(SNode n) {
    return (SNodeOperations.getNodeAncestor(n, CONCEPTS.BaseCommentAttribute$nv, false, false) != null);
  }



  /**
   * Get new artifact path based on pivot node and context artifact path.
   * 
   * @param pivot the pivot node used for the next step
   * @param contextArtifactPath the artifact path of the model element containing the pivot node
   * @return the new artifact path
   */
  public ArtifactPath artifactPathFor(Pivot pivot, ArtifactPath contextArtifactPath) {
    return contextArtifactPath.append(pivot.asSegment());
  }

  /**
   * 
   * @deprecated Use ArtifactHelper.getLogicalParent() directly.
   */
  @Deprecated(since = "2024-05-06")
  public static SNode nextUpwards(SNode n) {
    return ArtifactHelper.getLogicalParent(n);
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept ILogicalChildOwner$nQ = MetaAdapterFactory.getInterfaceConcept(0x85a9bace37a140afL, 0x956a7bb1b081a77cL, 0x4d47311ce8608adL, "com.mbeddr.mpsutil.logicalChild.structure.ILogicalChildOwner");
    /*package*/ static final SConcept AbstractTestNodeAnnotation$lh = MetaAdapterFactory.getConcept(0x8585453e6bfb4d80L, 0x98deb16074f1d86cL, 0x11e0d52da47L, "jetbrains.mps.lang.test.structure.AbstractTestNodeAnnotation");
    /*package*/ static final SInterfaceConcept IVariabilityAwareArtifact$qo = MetaAdapterFactory.getInterfaceConcept(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x716b3738b4b28e4bL, "org.iets3.variability.artifacts.base.structure.IVariabilityAwareArtifact");
    /*package*/ static final SInterfaceConcept IArtifactInstance$ce = MetaAdapterFactory.getInterfaceConcept(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x29c0f4d5e8127ce1L, "org.iets3.variability.artifacts.base.structure.IArtifactInstance");
    /*package*/ static final SConcept BaseCommentAttribute$nv = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x3dcc194340c24debL, "jetbrains.mps.lang.core.structure.BaseCommentAttribute");
  }
}
