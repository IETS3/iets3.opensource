package org.iets3.variability.artifacts.base.plugin;

/*Generated by MPS */

import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import com.google.common.collect.Sets;
import org.apache.commons.lang3.tuple.Pair;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import com.google.common.collect.Lists;
import java.util.Optional;
import java.util.Map;
import org.iets3.variability.artifacts.base.behavior.SkeletonNode;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;
import com.google.common.collect.ArrayListMultimap;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import java.util.Collections;
import java.util.HashSet;

public class FilterRunInformation {

  private InstanceEnvironment ie = new InstanceEnvironment();

  /**
   * nodes which need to be detached at the end
   */
  public final Set<SNode> detachments = Sets.newHashSet();

  public Set<Pair<SNode, SNode>> replacements = Sets.newHashSet();

  /**
   * Tabular VPs which have to be replaced at the end
   */
  public final List<SNode> tablesToBeDetached = ListSequence.fromList(new ArrayList<SNode>());

  /**
   * All IVariabilityAwareArtifacts which have been encountered
   */
  public final Set<SNode> foundIVAA = Sets.newHashSet();


  public List<BrokenLinks.BrokenLinksData> listOfChildReferencingNodes = Lists.newLinkedList();


  public Set<SNode> componentStaticReferenced = Sets.newHashSet();


  public Optional<SNode> instanceFor(SNode blueprint) {
    return this.ie.instanceFor(blueprint);
  }

  public Map<SNode, SNode> instanceToOriginal() {
    return this.ie.instanceToOrig();
  }

  /**
   * All copied nodes which have been created in instance-cases
   * 
   * @return instances
   */
  public Set<SNode> instances() {
    return this.instanceToOriginal().keySet();
  }

  public void remove(SkeletonNode skn) {
    this.ie.remove(skn);
  }

  public void add(SkeletonNode skn, Map<SNode, SNode> mapping) {
    this.ie.add(skn, mapping);
  }


  private static class InstanceEnvironment {

    /**
     * Tracks to which instantiation in a 'Copy' of a Artifact the original instantiation of the component currently is mapped.
     * This mapping changes as the algorithm traverses the SkeletonTree up and down in Top-to-Bottom-Traversal.
     */
    private Map<SNode, SNode> origToInstanceEnvironment = Maps.newHashMap();

    /**
     * With every new SkeletonNode new instantiation of a component c in the current model might happen. 
     * This means that further instantiation points are also copied. In the further run of the algorithm down the SkeletonTree
     * we do only consider those copies in the instantiated component. Nevertheless in descendant SkeletonNodes only a link to the original instantiation
     * in the original component is stored. This Multimap keeps track for which originals we have instantiations in  'origToInstanceEnvironment'
     */
    private Multimap<SkeletonNode, SNode> skeletonNodeToOrig = ArrayListMultimap.create();

    /**
     * Maps copies of AST nodes (created during instantiation) to their original node.
     */
    private Map<SNode, SNode> instanceToOrig = Maps.newHashMap();

    private void add(SkeletonNode skn, Map<SNode, SNode> origToInstance) {
      MapSequence.fromMap(this.origToInstanceEnvironment).putAll(origToInstance);
      this.skeletonNodeToOrig.putAll(skn, MapSequence.fromMap(origToInstance).keySet());

      SetSequence.fromSet(MapSequence.fromMap(origToInstance).mappingsSet()).visitAll((it) -> MapSequence.fromMap(instanceToOrig).put(it.value(), it.key()));
    }

    /**
     * Once a SkeletonNode during the traversal is done we need to remove any effects to the environment, i.e. the mapping of 
     * originals to copied instantiations.
     * 
     * @param skn skeletonNode
     */
    private void remove(SkeletonNode skn) {
      Collection<SNode> originalsToBeRemoved = this.skeletonNodeToOrig.removeAll(skn);
      for (SNode o : CollectionSequence.fromCollection(originalsToBeRemoved)) {
        MapSequence.fromMap(this.origToInstanceEnvironment).removeKey(o);
      }
    }

    private Optional<SNode> instanceFor(SNode orig) {
      return Optional.ofNullable(MapSequence.fromMap(this.origToInstanceEnvironment).get(orig));
    }

    private Map<SNode, SNode> instanceToOrig() {
      return Collections.unmodifiableMap(this.instanceToOrig);
    }
  }


  public void markComponentsNotReferencedStaticallyForDeletion(final INodeMapper nodeMapper) {
    HashSet<SNode> instantiatedOriginales = Sets.newHashSet(this.instanceToOriginal().values());
    Set<SNode> candidates = Sets.difference(instantiatedOriginales, this.componentStaticReferenced);
    SetSequence.fromSet(this.detachments).addSequence(SetSequence.fromSet(candidates).select((it) -> nodeMapper.mapOrig2Actual(it)));
    this.componentStaticReferenced.clear();
  }
}
