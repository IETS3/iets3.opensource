package org.iets3.variability.artifacts.base.behavior;

/*Generated by MPS */

import java.util.Collection;
import org.jetbrains.mps.openapi.model.SNode;
import com.google.common.collect.Lists;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import java.util.Optional;
import java.util.List;
import org.iets3.variability.artifacts.base.plugin.ArtifactHelper;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public abstract class AbstractSkeletonTreeBuilder implements ISkeletonTreeBuilder {
  protected final SkelNodeMap skelnodeMap;
  protected SkelTreeBuildUtil stbu = SkelTreeBuildUtil.instance;

  protected AbstractSkeletonTreeBuilder(SkelNodeMap snm) {
    this.skelnodeMap = snm;
  }

  /**
   * returns a collection of environments which each defines an horizontal entry in the table
   */
  protected Collection<SkeletonEnvironment> makeSkeletonEnvironmentForTabularVarPoint(SNode n, SkeletonNode parent, ArtifactPath path, SNode ivaaScope) {
    // tabular variation point, create skeleton nodes for all options 
    Collection<SkeletonEnvironment> newSkeletonEnvs = Lists.newArrayList();
    for (SNode vp : Sequence.fromIterable(ITabularVarPoint__BehaviorDescriptor.items_idWVQivijUir.invoke(n))) {
      SNode cn = IVariationPointBase__BehaviorDescriptor.artifactNode_id3q2wVepCV0v.invoke(vp);
      SkeletonNode p = createSkeletonNodeVP(cn, cn, vp, parent, path);
      CollectionSequence.fromCollection(newSkeletonEnvs).addElement(new SkeletonEnvironment(cn, p, ivaaScope, path));
    }

    // create a skeleton node for the ITabularVarPoint's default
    SNode dn = ITabularVarPoint__BehaviorDescriptor.defaultNode_idWVQivijUjF.invoke(n);
    if ((dn != null)) {
      SkeletonNode p = createSkeletonNodeTabular(dn, path, n, parent);
      CollectionSequence.fromCollection(newSkeletonEnvs).addElement(new SkeletonEnvironment(dn, p, ivaaScope, path));
    }
    return newSkeletonEnvs;
  }

  protected Optional<SNode> varpointFor(SNode n) {
    List<SNode> varPoints = Sequence.fromIterable(ArtifactHelper.getVariationPoints(n)).where((it) -> !(SNodeOperations.isInstanceOf(it, CONCEPTS.IConfigListVarPoint$l9))).toList();
    if (ListSequence.fromList(varPoints).count() > 1) {
      throw new RuntimeException("More than one variation point on one node is unsupported (node: " + BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(n) + ").");
    }
    return Optional.ofNullable(ListSequence.fromList(varPoints).first());
  }


  protected SkeletonNode createSkeletonNodeVP(SNode n, SNode target, SNode varPoint, SkeletonNode parent, ArtifactPath path) {
    return finish(target, path, parent, new SkeletonNode(n, varPoint, parent, path));
  }

  private SkeletonNode createSkeletonNodeTabular(SNode n, ArtifactPath path, SNode tabularVP, SkeletonNode parent) {
    return finish(n, path, parent, new SkeletonNode(n, parent, tabularVP, path));
  }

  private SkeletonNode finish(SNode n, ArtifactPath path, SkeletonNode parent, SkeletonNode newNode) {
    skelnodeMap.put(n, path, newNode);
    if (parent != null) {
      ListSequence.fromList(parent.getChildren()).addElement(newNode);
    }
    return newNode;
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept IConfigListVarPoint$l9 = MetaAdapterFactory.getInterfaceConcept(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x23e80284f237bef8L, "org.iets3.variability.artifacts.base.structure.IConfigListVarPoint");
  }
}
