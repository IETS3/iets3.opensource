package org.iets3.variability.artifacts.base.behavior;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import java.util.Optional;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.iets3.variability.featuremodel.base.plugin.DotExpressionUtil;
import com.google.common.collect.Lists;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.iets3.variability.featuremodel.base.plugin.FeatureModelTraversal;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.iets3.variability.artifacts.base.plugin.ArtifactHelper;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SConcept;

public class ArtifactPathFeatureExpressionResolver implements IFeatureExpressionResolver {

  private final SNode ivaa;
  private final List<SNode> includePath;

  public ArtifactPathFeatureExpressionResolver(SNode ap, final List<SNode> includePath) {
    this.ivaa = ap;
    this.includePath = includePath;
  }

  @Override
  public Optional<SNode> expressionFor(SNode feature) {
    Optional<SNode> commonPath = commonPath(this.includePath, feature);
    commonPath.ifPresent((SNode de) -> SLinkOperations.setTarget(DotExpressionUtil.headOf(de), LINKS.expr$CW3E, createArtifactRootFeatureRefExpr_yg3h4e_a0a0a0a1a6(ArtifactPathFeatureExpressionResolver.this.ivaa)));
    return (Optional<SNode>) commonPath;
  }

  private Optional<SNode> commonPath(List<SNode> path, SNode feature) {
    // Given a Path a1.a2....an and a feature we find feature ai such that there is a path 
    // a1....ai...feature such that the index i is maximal.
    List<SNode> pathCopy = Lists.newLinkedList(path);
    while (ListSequence.fromList(pathCopy).isNotEmpty()) {
      SNode ftn = ListSequence.fromList(pathCopy).removeLastElement();
      List<List<SNode>> pathsBetween = FeatureModelTraversal.findAllPathsToSubFeatureInclusive(ftn, feature, true);
      assert ListSequence.fromList(pathsBetween).count() <= 1 : "Only 1 Path between " + SPropertyOperations.getString(ftn, PROPS.name$MnvL) + " and " + SPropertyOperations.getString(feature, PROPS.name$MnvL) + " with Path " + pathCopy + " allowed, but are " + pathsBetween;
      if (ListSequence.fromList(pathsBetween).count() == 1) {
        pathCopy.addAll(ListSequence.fromList(pathsBetween).first());
        SNode toDotExpression = DotExpressionUtil.toDotExpression(pathCopy);
        assert toDotExpression != null;
        return Optional.<SNode>of(toDotExpression);
      }
    }
    return Optional.<SNode>empty();
  }

  public SNode toDotExpressionWithArtifactRoot(List<SNode> ftns, List<SNode> prefix) {
    List<SNode> result = Lists.newLinkedList();
    ListSequence.fromList(result).addSequence(ListSequence.fromList(prefix));

    for (SNode ftn : ListSequence.fromList(ftns).reversedList()) {
      SNode ivaa = ArtifactHelper.getIVAA(ftn);
      if (ivaa != null) {
        SNode afr = createArtifactRootFeatureRefExpr_yg3h4e_a0a0b0d0k(ivaa);
        ListSequence.fromList(result).insertElement(0, ftn);
        SNode dotExpression = DotExpressionUtil.toDotExpression(result);
        SLinkOperations.setTarget(dotExpression, LINKS.expr$CW3E, afr);
        return dotExpression;
      } else {
        ListSequence.fromList(result).insertElement(0, ftn);
      }
    }
    return null;
  }
  private static SNode createArtifactRootFeatureRefExpr_yg3h4e_a0a0a0a1a6(SNode p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.ArtifactRootFeatureRefExpr$aP);
    n0.setReferenceTarget(LINKS.context$4gIx, p0);
    return n0.getResult();
  }
  private static SNode createArtifactRootFeatureRefExpr_yg3h4e_a0a0b0d0k(SNode p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.ArtifactRootFeatureRefExpr$aP);
    n0.setReferenceTarget(LINKS.context$4gIx, p0);
    return n0.getResult();
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink expr$CW3E = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x3b256bb6ae8048d8L, 0x3b256bb6ae8048d9L, "expr");
    /*package*/ static final SReferenceLink context$4gIx = MetaAdapterFactory.getReferenceLink(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x4bb1b8d806f75799L, 0x740cca37d2d84781L, "context");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept ArtifactRootFeatureRefExpr$aP = MetaAdapterFactory.getConcept(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x4bb1b8d806f75799L, "org.iets3.variability.artifacts.base.structure.ArtifactRootFeatureRefExpr");
  }
}
