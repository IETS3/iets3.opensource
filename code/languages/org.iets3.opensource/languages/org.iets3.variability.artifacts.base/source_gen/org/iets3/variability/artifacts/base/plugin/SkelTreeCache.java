package org.iets3.variability.artifacts.base.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import org.iets3.variability.artifacts.base.behavior.SkeletonTree;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.iets3.variability.artifacts.base.behavior.IVariabilityAwareArtifact__BehaviorDescriptor;
import org.iets3.variability.artifacts.base.behavior.HashUtil;

/**
 * Cache skeleton tree for a given IVAA and its IVAA group.
 * 
 * The cached skeleton tree is stored as user object at its IVAA
 * and has to be recomputed when the ASTs in the IVAA's context 
 * have changed.
 */
public class SkelTreeCache {
  private static final String STC_KEY = "SkelTreeCache_DATA";

  private static final CacheStatistics statistics = new CacheStatistics();

  /**
   * Reset cached skeleton tree for a given IVAA.
   * 
   * @param ivaaMain the IVAA for which the cache should be cleared
   */
  public static void reset(SNode ivaaMain) {
    ivaaMain.putUserObject(STC_KEY, null);
  }

  /**
   * Get cached skeleton tree for a given IVAA or recomputed it.
   * 
   * @param ivaaMain the IVAA for which the skeleton tree is needed
   * @return the resulting skeleton tree
   */
  public static SkeletonTree get(SNode ivaaMain) {
    Iterable<SNode> group = Sequence.fromIterable(Sequence.<SNode>singleton(ivaaMain)).concat(Sequence.fromIterable(IVariabilityAwareArtifact__BehaviorDescriptor.getDirectDependenciesTransitive_id7ecvLRWIH6_.invoke(ivaaMain)));
    return get(ivaaMain, group);
  }

  /**
   * Get cached skeleton tree for a given IVAA and its group, or recompute it.
   * 
   * This method can be used if the artifact group has been computed before.
   * 
   * @param ivaaMain the main IVAA of the group
   * @param artifactGroup the main IVAA and all the IVAAs it depends on (transitively)
   * @return the resulting skeleton tree
   */
  public static SkeletonTree get(SNode ivaaMain, Iterable<SNode> artifactGroup) {
    statistics.countCall();
    int currentHash = HashUtil.computeHash(artifactGroup);

    Object data = ivaaMain.getUserObject(SkelTreeCache.STC_KEY);
    if (data != null && data instanceof SkelTreeCache) {
      // we have a cached instance, check if it is still valid
      SkelTreeCache cache = (SkelTreeCache) data;
      if (cache.isHash(currentHash)) {
        // the cache is still valid
        return cache.getSkeltree();
      }
    }

    // either no cache or the existing cache is already invalid
    SkeletonTree skeltree = IArtifactAlgorithms.instance().skeletonTreeBuilder().buildTree(ivaaMain);
    statistics.countMiss();
    SkelTreeCache cache = new SkelTreeCache(skeltree, currentHash);
    ivaaMain.putUserObject(STC_KEY, cache);
    return skeltree;
  }

  public static ICacheStatistics statistics() {
    return SkelTreeCache.statistics;
  }


  private SkeletonTree skeltree;
  private int hash;

  private SkelTreeCache(SkeletonTree skeltree, int hashcode) {
    this.skeltree = skeltree;
    this.hash = hashcode;
  }

  public boolean isHash(int hashcode) {
    return this.hash == hashcode;
  }

  public SkeletonTree getSkeltree() {
    return this.skeltree;
  }
}
