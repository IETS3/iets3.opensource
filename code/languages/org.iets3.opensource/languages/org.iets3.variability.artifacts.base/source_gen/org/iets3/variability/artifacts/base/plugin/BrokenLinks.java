package org.iets3.variability.artifacts.base.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import java.util.Collection;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.iets3.variability.featuremodel.base.plugin.DotExpressionUtil;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.baseLanguage.logging.rt.LogContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import com.google.common.collect.Lists;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import java.util.Objects;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class BrokenLinks {

  /**
   * Fix references to contents of nodes which have been instantiated during variability filtering.
   * 
   * Instantiated nodes might be duplicated during variability filtering. If this is the case,
   * references to their content will break. These content references will always be built by
   * referencing the instance node and identifying the actual content node from there. 
   * Thus, we can detect these cases by looking for references to instance nodes.
   * 
   * @param instanceNode a node which represents an instance of something which might have been cloned
   * @param candidateReferrers all nodes which might refer to the instance and its "contents"
   */
  public static void fixReferencesToContentsOf(SNode instanceNode, Collection<SNode> candidateReferrers) {
    List<SNode> candidatesReferencingInstanceNode = filterWithLinksTo(candidateReferrers, instanceNode);
    if (ListSequence.fromList(candidatesReferencingInstanceNode).isEmpty()) {
      return;
    }

    for (SNode crn : ListSequence.fromList(candidatesReferencingInstanceNode)) {
      // we assume that the reference to the instance will be part of a DotEx, and
      // the broken link will be the target of the DotEx
      {
        final SNode de = SNodeOperations.getParent(crn);
        if (SNodeOperations.isInstanceOf(de, CONCEPTS.DotExpression$jp)) {
          BrokenLinks.fixDotExpression(de, defaultResolver());
          continue;
        }
      }
      fixTarget(crn);
    }
  }

  public static void fixDotExpression(SNode de, final _FunctionTypes._return_P2_E0<? extends SNode, ? super Collection<SNode>, ? super String> resolver) {
    // fix references in nested DotExpressions from innermost to outermost
    ListSequence.fromList(flattenNestedDotEx(de)).visitAll((dotExpression) -> {
      // usually the target of the DotExpression only consists of just one reference
      SNode target = SLinkOperations.getTarget(dotExpression, LINKS.target$u23F);
      for (SReference reference : Sequence.fromIterable(target.getReferences())) {
        BrokenLinks.fixReference(target, reference, resolver);
      }
    });
  }

  /**
   * Convert a nested DotExpression into a sequential list from innermost DotEx to outermost DotEx.
   */
  private static List<SNode> flattenNestedDotEx(SNode de) {
    return ListSequence.fromList(DotExpressionUtil.splitDotExpression(DotExpressionUtil.topAncestorOf(de))).reversedList();
  }

  public static void fixTarget(SNode target) {
    for (SReference reference : Sequence.fromIterable(target.getReferences())) {
      BrokenLinks.fixReference(target, reference);
    }
  }

  public static void fixReference(SNode target, SReference reference) {
    fixReference(target, reference, defaultResolver());
  }

  private static _FunctionTypes._return_P2_E0<? extends SNode, ? super Collection<SNode>, ? super String> defaultResolver() {
    return (candidates, searchPattern) -> resolveCandidate(CollectionSequence.fromCollection(candidates).toList(), searchPattern);
  }

  public static void fixReference(SNode target, SReference reference, _FunctionTypes._return_P2_E0<? extends SNode, ? super Collection<SNode>, ? super String> resolver) {
    SNode refTarget = target.getReferenceTarget(SLinkOperations.getRefLink(reference));
    String searchPattern = BrokenLinks.searchPattern(refTarget);
    List<SNode> refCands = BrokenLinks.candidatesFromScope(reference, target, searchPattern);
    SNode resolvedRef = resolver.invoke(refCands, searchPattern);
    if (resolvedRef != null) {
      target.setReferenceTarget(SLinkOperations.getRefLink(reference), resolvedRef);
    } else {
      LogContext.with(BrokenLinks.class, null, null, null).warning("Could not fix link target " + SNodeOperations.present(target));
    }
  }

  private static String searchPattern(SNode refTarget) {
    {
      final SNode inc = refTarget;
      if (SNodeOperations.isInstanceOf(inc, CONCEPTS.INamedConcept$Kd)) {
        return SPropertyOperations.getString(inc, PROPS.name$MnvL);
      }
    }
    return (refTarget != null ? refTarget.toString() : null);
  }

  private static SNode resolveCandidate(List<SNode> cands, final String pattern) {
    if (ListSequence.fromList(cands).count() == 1) {
      return ListSequence.fromList(cands).getElement(0);
    }
    if (ListSequence.fromList(cands).count() > 1) {
      return ListSequence.fromList(cands).findFirst((it) -> (SNodeOperations.present(it) + "").equals(pattern));
    }
    return null;
  }

  private static List<SNode> candidatesFromScope(SReference r, SNode target, String searchPattern) {
    return Lists.newLinkedList(SLinkOperations.getRefLink(r).getScope(target).getAvailableElements(searchPattern));
  }


  public static List<SNode> filterWithLinksTo(Collection<SNode> nodes, final SNode refTarget) {
    return CollectionSequence.fromCollection(nodes).where((final SNode n) -> {
      // check if n contains any reference pointing to the refTarget node
      Collection<SReferenceLink> referenceLinks = n.getConcept().getReferenceLinks();
      return CollectionSequence.fromCollection(referenceLinks).any((link) -> isLinkedTo(n, link, refTarget));
    }).toList();
  }

  /**
   * Check if referenceHolder node links to the refTargetQuery node via the given reference link
   * 
   * @param referenceHolder node with possible reference
   * @param link specifies reference of referenceHolder
   * @param refTargetQuery node to be queried
   * @return true iff referenceHolder references referenceTargetQuery by link
   */
  private static boolean isLinkedTo(SNode referenceHolder, SReferenceLink link, SNode refTargetQuery) {
    return Objects.equals(referenceHolder.getReferenceTarget(link), refTargetQuery);
  }

  /**
   * Get all Expression nodes in a model which are the left side of a DotExpression, but not a DotExpression themselves.
   * 
   * @param m the given model
   * @return the expression nodes with the above property
   */
  public static Iterable<SNode> referrersOfClonedInstanceForDotExpression(SModel m) {
    return ListSequence.fromList(SModelOperations.nodes(m, CONCEPTS.Expression$D_)).where((it) -> SNodeOperations.isInstanceOf(SNodeOperations.getParent(it), CONCEPTS.DotExpression$jp) && !(SNodeOperations.isInstanceOf(it, CONCEPTS.DotExpression$jp))).toList();
  }

  public static class BrokenLinksData {
    public final SNode originalNode;
    public final SNode ivaa;

    public BrokenLinksData(SNode originalNode, SNode ivaa) {
      this.originalNode = originalNode;
      this.ivaa = ivaa;
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept DotExpression$jp = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7cef88020a0f4249L, "org.iets3.core.expr.base.structure.DotExpression");
    /*package*/ static final SInterfaceConcept INamedConcept$Kd = MetaAdapterFactory.getInterfaceConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, "jetbrains.mps.lang.core.structure.INamedConcept");
    /*package*/ static final SConcept Expression$D_ = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x670d5e92f854a047L, "org.iets3.core.expr.base.structure.Expression");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink target$u23F = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7cef88020a0f4249L, 0x7cef88020a0f424bL, "target");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }
}
