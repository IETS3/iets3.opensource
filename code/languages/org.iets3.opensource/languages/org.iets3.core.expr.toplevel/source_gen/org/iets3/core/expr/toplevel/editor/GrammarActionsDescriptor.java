package org.iets3.core.expr.toplevel.editor;

/*Generated by MPS */

import com.mbeddr.mpsutil.grammarcells.runtime.AbstractGrammarActionDescriptor;
import com.mbeddr.mpsutil.grammarcells.runtime.IGrammarActionsDescriptor;
import java.util.List;
import jetbrains.mps.openapi.editor.menus.substitute.SubstituteMenuItem;
import jetbrains.mps.openapi.editor.menus.substitute.SubstituteMenuContext;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.editor.menus.EditorMenuDescriptorBase;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.model.SNode;
import com.mbeddr.mpsutil.grammarcells.runtime.GrammarCellsUtil;
import jetbrains.mps.openapi.editor.EditorContext;
import org.iets3.core.expr.base.plugin.EditorCustomizationConfigHelper;
import com.mbeddr.mpsutil.grammarcells.runtime.FlagSubstituteMenuItem;
import com.mbeddr.mpsutil.grammarcells.runtime.DefaultFlagModelAccess;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.SNodePointer;
import com.mbeddr.mpsutil.grammarcells.runtime.menu.GrammarCellsSubstituteMenuItem;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.action.SNodeFactoryOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.editor.runtime.selection.SelectionUtil;
import jetbrains.mps.editor.runtime.cells.CellIdManager;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.lang.editor.menus.substitute.DefaultSubstituteMenuLookup;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.lang.editor.menus.substitute.ReferenceScopeSubstituteMenuItem;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import jetbrains.mps.lang.editor.menus.substitute.SubstituteMenuItemWrapper;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.action.NodeFactoryManager;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuItem;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuContext;
import jetbrains.mps.lang.editor.menus.transformation.MenuLocations;
import jetbrains.mps.openapi.editor.cells.SubstituteAction;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.smodel.action.NodeSubstituteActionsFactoryContext;
import com.mbeddr.mpsutil.grammarcells.runtime.IToken;
import com.mbeddr.mpsutil.grammarcells.runtime.IRule;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public class GrammarActionsDescriptor extends AbstractGrammarActionDescriptor implements IGrammarActionsDescriptor {

  public static final GrammarActionsDescriptor INSTANCE = new GrammarActionsDescriptor();

  @Override
  public List<SubstituteMenuItem> getActions(final SubstituteMenuContext _context, final SAbstractConcept expectedOutputConceptExactly) {
    final List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());

    _context.getEditorMenuTrace().pushTraceInfo();
    _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("org.iets3.core.expr.toplevel.editor.GrammarActionsDescriptor.getActions", null));
    try {
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());

          {
            final SConcept outputConcept = CONCEPTS.Function$iC;

            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConceptExactly))) {
              final SNode parentNode = _context.getParentNode();
              final SNode substitutedNode = _context.getCurrentTargetNode();
              for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(outputConcept, _context.getModel(), Function_Editor.class, _context.getEditorContext())) {
                EditorContext editorContext = _context.getEditorContext();
                boolean applicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                applicable &= new Object() {
                  public boolean query() {
                    return EditorCustomizationConfigHelper.getConfig().isFlagCellSubstitutionActivated(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Function$iC, PROPS.ext$atYv), subconcept, substitutedNode, parentNode, editorContext);
                  }
                }.query();
                if (applicable) {
                  ListSequence.fromList(result).addElement(new FlagSubstituteMenuItem(parentNode, _context.getCurrentTargetNode(), subconcept, "ext", _context, new DefaultFlagModelAccess(PROPS.ext$atYv)) {
                    @Nullable
                    @Override
                    public String getDescriptionText(@NotNull String pattern) {
                      String originalText = super.getDescriptionText(pattern);
                      EditorContext editorContext = _context.getEditorContext();
                      String descriptiontext = EditorCustomizationConfigHelper.getConfig().getFlagCellDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Function$iC, PROPS.ext$atYv), originalText, editorContext);
                      return ((descriptiontext != null && descriptiontext.length() > 0) ? descriptiontext : "an extension function");
                    }
                  });
                }
              }
            }
          }

          return result;
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "RecordMember", new SNodePointer("r:1d6bd88a-7393-4b32-b0e6-2d8b3094776e(org.iets3.core.expr.toplevel.editor)", "8811147530084454329")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.RecordMember$l3)) {
              final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.RecordMember$l3, _context.getModel(), RecordMember_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  isApplicable &= new Object() {
                    public boolean query(SAbstractConcept expectedConcept) {
                      return EditorCustomizationConfigHelper.getConfig().isWrapperCellSubstitutionActivated(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.RecordMember$l3, PROPS.name$MnvL), expectedConcept, null, null);
                    }
                  }.query(expectedOutputConcept);
                  if (isApplicable) {
                    ListSequence.fromList(result).addElement(new GrammarCellsSubstituteMenuItem(_context) {
                      private SProperty myProperty = PROPS.name$MnvL;

                      public String getMatchingText(String pattern) {
                        return pattern;
                      }
                      @Override
                      public String getDescriptionText(@NotNull String pattern) {
                        String originalText = super.getDescriptionText(pattern);
                        SNode wrappedNode = null;
                        SAbstractConcept wrappedConcept = getOutputConcept();
                        EditorContext editorContext = _context.getEditorContext();
                        String descriptiontext = EditorCustomizationConfigHelper.getConfig().getWrapperCellSubstitutionDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.RecordMember$l3, PROPS.name$MnvL), wrappedNode, wrappedConcept, subconcept, originalText, editorContext);
                        return ((descriptiontext != null && descriptiontext.length() > 0) ? descriptiontext : originalText);
                      }
                      @Override
                      public boolean canExecute(@NotNull String pattern) {
                        if ((pattern == null || pattern.length() == 0)) {
                          return false;
                        }
                        return GrammarCellsUtil.isValidPropertyValue(myProperty, expectedOutputConceptExactly, pattern);
                      }
                      @Override
                      public boolean canExecuteStrictly(@NotNull String pattern) {
                        return canExecute(pattern);
                      }

                      @Override
                      public SNode createNode(@NotNull String pattern) {
                        SNode newNode = SNodeFactoryOperations.createNewNode(expectedOutputConceptExactly, null);
                        SPropertyOperations.assign(newNode, PROPS.name$MnvL, GrammarCellsUtil.toInternalPropertyValue(myProperty, pattern));

                        new Object() {
                          public void postProcess(SNode node, EditorContext editorContext, SNode parentNode) {
                            EditorCustomizationConfigHelper.getConfig().wrapperCellSubstitutionPostProcess(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.RecordMember$l3, PROPS.name$MnvL), node, editorContext);
                          }
                        }.postProcess(newNode, _context.getEditorContext(), _context.getParentNode());
                        return newNode;
                      }


                      @Override
                      public void select(@NotNull SNode newNode, @NotNull String pattern) {
                        super.select(newNode, pattern);
                      }

                      @Override
                      public SAbstractConcept getOutputConcept() {
                        return CONCEPTS.RecordMember$l3;
                      }
                    });
                  }
                }

              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where((it) -> it != null).toList();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());


          return result;
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());


          return result;
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "EnumLiteral", new SNodePointer("r:1d6bd88a-7393-4b32-b0e6-2d8b3094776e(org.iets3.core.expr.toplevel.editor)", "4556655060346182240")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.EnumLiteral$S9)) {
              final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.EnumLiteral$S9, _context.getModel(), EnumLiteral_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  isApplicable &= new Object() {
                    public boolean query(SAbstractConcept expectedConcept) {
                      return EditorCustomizationConfigHelper.getConfig().isWrapperCellSubstitutionActivated(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.EnumLiteral$S9, PROPS.name$MnvL), expectedConcept, null, null);
                    }
                  }.query(expectedOutputConcept);
                  if (isApplicable) {
                    ListSequence.fromList(result).addElement(new GrammarCellsSubstituteMenuItem(_context) {
                      private SProperty myProperty = PROPS.name$MnvL;

                      public String getMatchingText(String pattern) {
                        return pattern;
                      }
                      @Override
                      public String getDescriptionText(@NotNull String pattern) {
                        String originalText = super.getDescriptionText(pattern);
                        SNode wrappedNode = null;
                        SAbstractConcept wrappedConcept = getOutputConcept();
                        EditorContext editorContext = _context.getEditorContext();
                        String descriptiontext = EditorCustomizationConfigHelper.getConfig().getWrapperCellSubstitutionDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.EnumLiteral$S9, PROPS.name$MnvL), wrappedNode, wrappedConcept, subconcept, originalText, editorContext);
                        return ((descriptiontext != null && descriptiontext.length() > 0) ? descriptiontext : originalText);
                      }
                      @Override
                      public boolean canExecute(@NotNull String pattern) {
                        if ((pattern == null || pattern.length() == 0)) {
                          return false;
                        }
                        return GrammarCellsUtil.isValidPropertyValue(myProperty, expectedOutputConceptExactly, pattern);
                      }
                      @Override
                      public boolean canExecuteStrictly(@NotNull String pattern) {
                        return canExecute(pattern);
                      }

                      @Override
                      public SNode createNode(@NotNull String pattern) {
                        SNode newNode = SNodeFactoryOperations.createNewNode(expectedOutputConceptExactly, null);
                        SPropertyOperations.assign(newNode, PROPS.name$MnvL, GrammarCellsUtil.toInternalPropertyValue(myProperty, pattern));

                        new Object() {
                          public void postProcess(SNode node, EditorContext editorContext, SNode parentNode) {
                            EditorCustomizationConfigHelper.getConfig().wrapperCellSubstitutionPostProcess(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.EnumLiteral$S9, PROPS.name$MnvL), node, editorContext);
                          }
                        }.postProcess(newNode, _context.getEditorContext(), _context.getParentNode());
                        return newNode;
                      }


                      @Override
                      public void select(@NotNull SNode newNode, @NotNull String pattern) {
                        super.select(newNode, pattern);
                      }

                      @Override
                      public SAbstractConcept getOutputConcept() {
                        return CONCEPTS.EnumLiteral$S9;
                      }
                    });
                  }
                }

              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where((it) -> it != null).toList();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "ProjectMember", new SNodePointer("r:1d6bd88a-7393-4b32-b0e6-2d8b3094776e(org.iets3.core.expr.toplevel.editor)", "8293738266742229483")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.ProjectMember$2l)) {
              final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.ProjectMember$2l, _context.getModel(), ProjectMember_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  isApplicable &= new Object() {
                    public boolean query(SAbstractConcept expectedConcept) {
                      return EditorCustomizationConfigHelper.getConfig().isWrapperCellSubstitutionActivated(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.ProjectMember$2l, PROPS.name$MnvL), expectedConcept, null, null);
                    }
                  }.query(expectedOutputConcept);
                  if (isApplicable) {
                    ListSequence.fromList(result).addElement(new GrammarCellsSubstituteMenuItem(_context) {
                      private SProperty myProperty = PROPS.name$MnvL;

                      public String getMatchingText(String pattern) {
                        return pattern;
                      }
                      @Override
                      public String getDescriptionText(@NotNull String pattern) {
                        String originalText = super.getDescriptionText(pattern);
                        SNode wrappedNode = null;
                        SAbstractConcept wrappedConcept = getOutputConcept();
                        EditorContext editorContext = _context.getEditorContext();
                        String descriptiontext = EditorCustomizationConfigHelper.getConfig().getWrapperCellSubstitutionDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.ProjectMember$2l, PROPS.name$MnvL), wrappedNode, wrappedConcept, subconcept, originalText, editorContext);
                        return ((descriptiontext != null && descriptiontext.length() > 0) ? descriptiontext : originalText);
                      }
                      @Override
                      public boolean canExecute(@NotNull String pattern) {
                        if ((pattern == null || pattern.length() == 0)) {
                          return false;
                        }
                        return GrammarCellsUtil.isValidPropertyValue(myProperty, expectedOutputConceptExactly, pattern);
                      }
                      @Override
                      public boolean canExecuteStrictly(@NotNull String pattern) {
                        return canExecute(pattern);
                      }

                      @Override
                      public SNode createNode(@NotNull String pattern) {
                        SNode newNode = SNodeFactoryOperations.createNewNode(expectedOutputConceptExactly, null);
                        SPropertyOperations.assign(newNode, PROPS.name$MnvL, GrammarCellsUtil.toInternalPropertyValue(myProperty, pattern));

                        new Object() {
                          public void postProcess(SNode node, EditorContext editorContext, SNode parentNode) {
                            EditorCustomizationConfigHelper.getConfig().wrapperCellSubstitutionPostProcess(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.ProjectMember$2l, PROPS.name$MnvL), node, editorContext);
                          }
                        }.postProcess(newNode, _context.getEditorContext(), _context.getParentNode());
                        return newNode;
                      }


                      @Override
                      public void select(@NotNull SNode newNode, @NotNull String pattern) {
                        SelectionUtil.selectLabelCellAnSetCaret(_context.getEditorContext(), newNode, "*" + CellIdManager.createPropertyId("name"), -1);
                      }

                      @Override
                      public SAbstractConcept getOutputConcept() {
                        return CONCEPTS.ProjectMember$2l;
                      }
                    });
                  }
                }

              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where((it) -> it != null).toList();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "RecordTypeAdapter", new SNodePointer("r:1d6bd88a-7393-4b32-b0e6-2d8b3094776e(org.iets3.core.expr.toplevel.editor)", "5070313213710414434")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.RecordTypeAdapter$nb)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.IRecordType$ka;
              for (final SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.RecordTypeAdapter$nb, _context.getModel(), RecordTypeAdapter_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  final SContainmentLink aggregation = LINKS.type$MFr_;

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);


                  if (isApplicable) {
                    // get all available actions
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.type$MFr_).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    // Filter based on grammar.rule conditions
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new _FunctionTypes._return_P1_E0<Boolean, SubstituteMenuItem>() {
                      public Boolean invoke(SubstituteMenuItem it) {
                        // Need to check constraints again for concrete type
                        boolean isApplicable = GrammarCellsUtil.canBeChildForSubstitute(subconcept, _context, it.getOutputConcept(), aggregation);
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        isApplicable &= new Object() {
                          public boolean query(SAbstractConcept expectedConcept) {
                            return EditorCustomizationConfigHelper.getConfig().isWrapperCellSubstitutionActivated(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.RecordTypeAdapter$nb, LINKS.type$MFr_), expectedConcept, wrappedConcept, editorContext);
                          }
                        }.query(expectedOutputConcept);
                        return isApplicable;
                      }
                    }).toList();

                    // Create wrapper objects for items
                    wrappedActions = ListSequence.fromList(wrappedActions).select((final SubstituteMenuItem it) -> {
                      final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                      SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                        private SNode wrappedNode;
                        @Override
                        public SNode createNode(@NotNull String pattern) {
                          SNode nodeToWrap = super.createNode(pattern);
                          wrappedNode = nodeToWrap;
                          // use setupNode after setting wrapped element to allow access to the wrapped element in node factories
                          SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                          SLinkOperations.setTarget(wrapper, LINKS.type$MFr_, SNodeOperations.cast(nodeToWrap, CONCEPTS.IRecordType$ka));
                          NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                          new Object() {
                            public void postprocess(SNode node, EditorContext editorContext, SNode parentNode) {
                              EditorCustomizationConfigHelper.getConfig().wrapperCellSubstitutionPostProcess(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.RecordTypeAdapter$nb, LINKS.type$MFr_), node, editorContext);
                            }
                          }.postprocess(wrapper, _context.getEditorContext(), _context.getParentNode());
                          return wrapper;
                        }
                        @Override
                        public String getDescriptionText(@NotNull final String pattern) {
                          String originalText = ((_FunctionTypes._return_P0_E0<String>) () -> {
                            String description = it.getDescriptionText(pattern);
                            return ((description != null && description.length() > 0) ? description : it.getOutputConcept().getName());
                          }).invoke();
                          SNode wrappedNode = null;
                          SAbstractConcept wrappedConcept = super.getOutputConcept();
                          EditorContext editorContext = _context.getEditorContext();
                          String descriptiontext = EditorCustomizationConfigHelper.getConfig().getWrapperCellSubstitutionDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.RecordTypeAdapter$nb, LINKS.type$MFr_), wrappedNode, wrappedConcept, subconcept, originalText, editorContext);
                          return ((descriptiontext != null && descriptiontext.length() > 0) ? descriptiontext : originalText);
                        }
                        @Override
                        public SAbstractConcept getOutputConcept() {
                          return outputConcept;
                        }

                        @Override
                        public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                          GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                        }
                      };
                      return wrapper;
                    }).toList();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where((it) -> it != null).toList();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "AbstractFunctionAdapter", new SNodePointer("r:1d6bd88a-7393-4b32-b0e6-2d8b3094776e(org.iets3.core.expr.toplevel.editor)", "411710798109576823")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.AbstractFunctionAdapter$Ob)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.Function$iC;
              for (final SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.AbstractFunctionAdapter$Ob, _context.getModel(), AbstractFunctionAdapter_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  final SContainmentLink aggregation = LINKS.fun$NLoa;

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);


                  if (isApplicable) {
                    // get all available actions
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.fun$NLoa).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    // Filter based on grammar.rule conditions
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new _FunctionTypes._return_P1_E0<Boolean, SubstituteMenuItem>() {
                      public Boolean invoke(SubstituteMenuItem it) {
                        // Need to check constraints again for concrete type
                        boolean isApplicable = GrammarCellsUtil.canBeChildForSubstitute(subconcept, _context, it.getOutputConcept(), aggregation);
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        isApplicable &= new Object() {
                          public boolean query(SAbstractConcept expectedConcept) {
                            return EditorCustomizationConfigHelper.getConfig().isWrapperCellSubstitutionActivated(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.AbstractFunctionAdapter$Ob, LINKS.fun$NLoa), expectedConcept, wrappedConcept, editorContext);
                          }
                        }.query(expectedOutputConcept);
                        return isApplicable;
                      }
                    }).toList();

                    // Create wrapper objects for items
                    wrappedActions = ListSequence.fromList(wrappedActions).select((final SubstituteMenuItem it) -> {
                      final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                      SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                        private SNode wrappedNode;
                        @Override
                        public SNode createNode(@NotNull String pattern) {
                          SNode nodeToWrap = super.createNode(pattern);
                          wrappedNode = nodeToWrap;
                          // use setupNode after setting wrapped element to allow access to the wrapped element in node factories
                          SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                          SLinkOperations.setTarget(wrapper, LINKS.fun$NLoa, SNodeOperations.cast(nodeToWrap, CONCEPTS.Function$iC));
                          NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                          new Object() {
                            public void postprocess(SNode node, EditorContext editorContext, SNode parentNode) {
                              EditorCustomizationConfigHelper.getConfig().wrapperCellSubstitutionPostProcess(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.AbstractFunctionAdapter$Ob, LINKS.fun$NLoa), node, editorContext);
                            }
                          }.postprocess(wrapper, _context.getEditorContext(), _context.getParentNode());
                          return wrapper;
                        }
                        @Override
                        public String getDescriptionText(@NotNull final String pattern) {
                          String originalText = ((_FunctionTypes._return_P0_E0<String>) () -> {
                            String description = it.getDescriptionText(pattern);
                            return ((description != null && description.length() > 0) ? description : it.getOutputConcept().getName());
                          }).invoke();
                          SNode wrappedNode = null;
                          SAbstractConcept wrappedConcept = super.getOutputConcept();
                          EditorContext editorContext = _context.getEditorContext();
                          String descriptiontext = EditorCustomizationConfigHelper.getConfig().getWrapperCellSubstitutionDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.AbstractFunctionAdapter$Ob, LINKS.fun$NLoa), wrappedNode, wrappedConcept, subconcept, originalText, editorContext);
                          return ((descriptiontext != null && descriptiontext.length() > 0) ? descriptiontext : originalText);
                        }
                        @Override
                        public SAbstractConcept getOutputConcept() {
                          return outputConcept;
                        }

                        @Override
                        public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                          GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                        }
                      };
                      return wrapper;
                    }).toList();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where((it) -> it != null).toList();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "AbstractToplevelExprAdapter", new SNodePointer("r:1d6bd88a-7393-4b32-b0e6-2d8b3094776e(org.iets3.core.expr.toplevel.editor)", "3788552209995588114")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.AbstractToplevelExprAdapter$eq)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.IToplevelExprContent$AI;
              for (final SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.AbstractToplevelExprAdapter$eq, _context.getModel(), AbstractToplevelExprAdapter_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  final SContainmentLink aggregation = LINKS.toplevelExprContent$igxr;

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);


                  if (isApplicable) {
                    // get all available actions
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.toplevelExprContent$igxr).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    // Filter based on grammar.rule conditions
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new _FunctionTypes._return_P1_E0<Boolean, SubstituteMenuItem>() {
                      public Boolean invoke(SubstituteMenuItem it) {
                        // Need to check constraints again for concrete type
                        boolean isApplicable = GrammarCellsUtil.canBeChildForSubstitute(subconcept, _context, it.getOutputConcept(), aggregation);
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        isApplicable &= new Object() {
                          public boolean query(SAbstractConcept expectedConcept) {
                            return EditorCustomizationConfigHelper.getConfig().isWrapperCellSubstitutionActivated(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.AbstractToplevelExprAdapter$eq, LINKS.toplevelExprContent$igxr), expectedConcept, wrappedConcept, editorContext);
                          }
                        }.query(expectedOutputConcept);
                        return isApplicable;
                      }
                    }).toList();

                    // Create wrapper objects for items
                    wrappedActions = ListSequence.fromList(wrappedActions).select((final SubstituteMenuItem it) -> {
                      final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                      SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                        private SNode wrappedNode;
                        @Override
                        public SNode createNode(@NotNull String pattern) {
                          SNode nodeToWrap = super.createNode(pattern);
                          wrappedNode = nodeToWrap;
                          // use setupNode after setting wrapped element to allow access to the wrapped element in node factories
                          SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                          SLinkOperations.setTarget(wrapper, LINKS.toplevelExprContent$igxr, SNodeOperations.cast(nodeToWrap, CONCEPTS.IToplevelExprContent$AI));
                          NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                          new Object() {
                            public void postprocess(SNode node, EditorContext editorContext, SNode parentNode) {
                              EditorCustomizationConfigHelper.getConfig().wrapperCellSubstitutionPostProcess(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.AbstractToplevelExprAdapter$eq, LINKS.toplevelExprContent$igxr), node, editorContext);
                            }
                          }.postprocess(wrapper, _context.getEditorContext(), _context.getParentNode());
                          return wrapper;
                        }
                        @Override
                        public String getDescriptionText(@NotNull final String pattern) {
                          String originalText = ((_FunctionTypes._return_P0_E0<String>) () -> {
                            String description = it.getDescriptionText(pattern);
                            return ((description != null && description.length() > 0) ? description : it.getOutputConcept().getName());
                          }).invoke();
                          SNode wrappedNode = null;
                          SAbstractConcept wrappedConcept = super.getOutputConcept();
                          EditorContext editorContext = _context.getEditorContext();
                          String descriptiontext = EditorCustomizationConfigHelper.getConfig().getWrapperCellSubstitutionDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.AbstractToplevelExprAdapter$eq, LINKS.toplevelExprContent$igxr), wrappedNode, wrappedConcept, subconcept, originalText, editorContext);
                          return ((descriptiontext != null && descriptiontext.length() > 0) ? descriptiontext : originalText);
                        }
                        @Override
                        public SAbstractConcept getOutputConcept() {
                          return outputConcept;
                        }

                        @Override
                        public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                          GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                        }
                      };
                      return wrapper;
                    }).toList();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where((it) -> it != null).toList();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "AbstractFunctionLikeAdapter", new SNodePointer("r:1d6bd88a-7393-4b32-b0e6-2d8b3094776e(org.iets3.core.expr.toplevel.editor)", "336196204782304812")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.AbstractFunctionLikeAdapter$in)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.IFunctionLike$t6;
              for (final SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.AbstractFunctionLikeAdapter$in, _context.getModel(), AbstractFunctionLikeAdapter_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  final SContainmentLink aggregation = LINKS.functionLike$1qr0;

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);


                  if (isApplicable) {
                    // get all available actions
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.functionLike$1qr0).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    // Filter based on grammar.rule conditions
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new _FunctionTypes._return_P1_E0<Boolean, SubstituteMenuItem>() {
                      public Boolean invoke(SubstituteMenuItem it) {
                        // Need to check constraints again for concrete type
                        boolean isApplicable = GrammarCellsUtil.canBeChildForSubstitute(subconcept, _context, it.getOutputConcept(), aggregation);
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        isApplicable &= new Object() {
                          public boolean query(SAbstractConcept expectedConcept) {
                            return EditorCustomizationConfigHelper.getConfig().isWrapperCellSubstitutionActivated(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.AbstractFunctionLikeAdapter$in, LINKS.functionLike$1qr0), expectedConcept, wrappedConcept, editorContext);
                          }
                        }.query(expectedOutputConcept);
                        return isApplicable;
                      }
                    }).toList();

                    // Create wrapper objects for items
                    wrappedActions = ListSequence.fromList(wrappedActions).select((final SubstituteMenuItem it) -> {
                      final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                      SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                        private SNode wrappedNode;
                        @Override
                        public SNode createNode(@NotNull String pattern) {
                          SNode nodeToWrap = super.createNode(pattern);
                          wrappedNode = nodeToWrap;
                          // use setupNode after setting wrapped element to allow access to the wrapped element in node factories
                          SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                          SLinkOperations.setTarget(wrapper, LINKS.functionLike$1qr0, SNodeOperations.cast(nodeToWrap, CONCEPTS.IFunctionLike$t6));
                          NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                          new Object() {
                            public void postprocess(SNode node, EditorContext editorContext, SNode parentNode) {
                              EditorCustomizationConfigHelper.getConfig().wrapperCellSubstitutionPostProcess(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.AbstractFunctionLikeAdapter$in, LINKS.functionLike$1qr0), node, editorContext);
                            }
                          }.postprocess(wrapper, _context.getEditorContext(), _context.getParentNode());
                          return wrapper;
                        }
                        @Override
                        public String getDescriptionText(@NotNull final String pattern) {
                          String originalText = ((_FunctionTypes._return_P0_E0<String>) () -> {
                            String description = it.getDescriptionText(pattern);
                            return ((description != null && description.length() > 0) ? description : it.getOutputConcept().getName());
                          }).invoke();
                          SNode wrappedNode = null;
                          SAbstractConcept wrappedConcept = super.getOutputConcept();
                          EditorContext editorContext = _context.getEditorContext();
                          String descriptiontext = EditorCustomizationConfigHelper.getConfig().getWrapperCellSubstitutionDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.AbstractFunctionLikeAdapter$in, LINKS.functionLike$1qr0), wrappedNode, wrappedConcept, subconcept, originalText, editorContext);
                          return ((descriptiontext != null && descriptiontext.length() > 0) ? descriptiontext : originalText);
                        }
                        @Override
                        public SAbstractConcept getOutputConcept() {
                          return outputConcept;
                        }

                        @Override
                        public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                          GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                        }
                      };
                      return wrapper;
                    }).toList();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where((it) -> it != null).toList();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "QualifierRef", new SNodePointer("r:1d6bd88a-7393-4b32-b0e6-2d8b3094776e(org.iets3.core.expr.toplevel.editor)", "5250171600079090332")));
          try {
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where((it) -> it != null).toList();
        }
      }.query()));
    } finally {
      _context.getEditorMenuTrace().popTraceInfo();
    }

    return ListSequence.fromList(result).where((it) -> it != null).toList();
  }

  @Override
  protected List<TransformationMenuItem> doGetSideTransformActions(final TransformationMenuContext _context) {
    final List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());

    _context.getEditorMenuTrace().pushTraceInfo();
    _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("org.iets3.core.expr.toplevel.editor.GrammarActionsDescriptor.doGetSideTransformActions", null));
    try {
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "RecordMember", new SNodePointer("r:1d6bd88a-7393-4b32-b0e6-2d8b3094776e(org.iets3.core.expr.toplevel.editor)", "8811147530084454329")));
              try {
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where((it) -> it != null).toList();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "EnumLiteral", new SNodePointer("r:1d6bd88a-7393-4b32-b0e6-2d8b3094776e(org.iets3.core.expr.toplevel.editor)", "4556655060346182240")));
              try {
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where((it) -> it != null).toList();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "ProjectMember", new SNodePointer("r:1d6bd88a-7393-4b32-b0e6-2d8b3094776e(org.iets3.core.expr.toplevel.editor)", "8293738266742229483")));
              try {
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where((it) -> it != null).toList();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "RecordTypeAdapter", new SNodePointer("r:1d6bd88a-7393-4b32-b0e6-2d8b3094776e(org.iets3.core.expr.toplevel.editor)", "5070313213710414434")));
              try {
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where((it) -> it != null).toList();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "AbstractFunctionAdapter", new SNodePointer("r:1d6bd88a-7393-4b32-b0e6-2d8b3094776e(org.iets3.core.expr.toplevel.editor)", "411710798109576823")));
              try {
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where((it) -> it != null).toList();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "AbstractToplevelExprAdapter", new SNodePointer("r:1d6bd88a-7393-4b32-b0e6-2d8b3094776e(org.iets3.core.expr.toplevel.editor)", "3788552209995588114")));
              try {
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where((it) -> it != null).toList();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "AbstractFunctionLikeAdapter", new SNodePointer("r:1d6bd88a-7393-4b32-b0e6-2d8b3094776e(org.iets3.core.expr.toplevel.editor)", "336196204782304812")));
              try {
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where((it) -> it != null).toList();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "QualifierRef", new SNodePointer("r:1d6bd88a-7393-4b32-b0e6-2d8b3094776e(org.iets3.core.expr.toplevel.editor)", "5250171600079090332")));
              try {
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where((it) -> it != null).toList();
            }
          }.query(_context)));
        }
      }
    } finally {
      _context.getEditorMenuTrace().popTraceInfo();
    }

    return ListSequence.fromList(result).where((it) -> it != null).toList();
  }

  @Override
  public List<SubstituteAction> getConstantReplaceActions(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context, final List<IToken> elementsBefore, final List<IToken> elementsAfter) {
    final List<SubstituteAction> result = ListSequence.fromList(new ArrayList<SubstituteAction>());

    return ListSequence.fromList(result).where((it) -> it != null).toList();
  }

  @Override
  public List<IRule> getRules(final SModel contextModel) {
    final List<IRule> rules = ListSequence.fromList(new ArrayList<IRule>());

    final Set<SLanguage> visibleLanguages = GrammarCellsUtil.getVisibleLanguages(contextModel);


    return rules;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Function$iC = MetaAdapterFactory.getConcept(0x71934284d7d145eeL, 0xa0548c072591085fL, 0x427ce523083c44a3L, "org.iets3.core.expr.toplevel.structure.Function");
    /*package*/ static final SConcept RecordMember$l3 = MetaAdapterFactory.getConcept(0x71934284d7d145eeL, 0xa0548c072591085fL, 0x7a477bfec237e8b9L, "org.iets3.core.expr.toplevel.structure.RecordMember");
    /*package*/ static final SConcept EnumLiteral$S9 = MetaAdapterFactory.getConcept(0x71934284d7d145eeL, 0xa0548c072591085fL, 0x61fe216664a72ed1L, "org.iets3.core.expr.toplevel.structure.EnumLiteral");
    /*package*/ static final SConcept ProjectMember$2l = MetaAdapterFactory.getConcept(0x71934284d7d145eeL, 0xa0548c072591085fL, 0x73194702f12a0d28L, "org.iets3.core.expr.toplevel.structure.ProjectMember");
    /*package*/ static final SInterfaceConcept IRecordType$ka = MetaAdapterFactory.getInterfaceConcept(0x71934284d7d145eeL, 0xa0548c072591085fL, 0x3c10dabb94384796L, "org.iets3.core.expr.toplevel.structure.IRecordType");
    /*package*/ static final SConcept RecordTypeAdapter$nb = MetaAdapterFactory.getConcept(0x71934284d7d145eeL, 0xa0548c072591085fL, 0x465d5f01132db232L, "org.iets3.core.expr.toplevel.structure.RecordTypeAdapter");
    /*package*/ static final SConcept AbstractFunctionAdapter$Ob = MetaAdapterFactory.getConcept(0x71934284d7d145eeL, 0xa0548c072591085fL, 0x5b6b0ca1fa4e6b6L, "org.iets3.core.expr.toplevel.structure.AbstractFunctionAdapter");
    /*package*/ static final SInterfaceConcept IToplevelExprContent$AI = MetaAdapterFactory.getInterfaceConcept(0x71934284d7d145eeL, 0xa0548c072591085fL, 0x27b717d14a8b21f9L, "org.iets3.core.expr.toplevel.structure.IToplevelExprContent");
    /*package*/ static final SConcept AbstractToplevelExprAdapter$eq = MetaAdapterFactory.getConcept(0x71934284d7d145eeL, 0xa0548c072591085fL, 0x3493a42991cec5c8L, "org.iets3.core.expr.toplevel.structure.AbstractToplevelExprAdapter");
    /*package*/ static final SInterfaceConcept IFunctionLike$t6 = MetaAdapterFactory.getInterfaceConcept(0x9464fa065ab9409bL, 0x927464ab29588457L, 0x427ce523083b8a2fL, "org.iets3.core.expr.lambda.structure.IFunctionLike");
    /*package*/ static final SConcept AbstractFunctionLikeAdapter$in = MetaAdapterFactory.getConcept(0x71934284d7d145eeL, 0xa0548c072591085fL, 0x4aa68aac0c23aa4L, "org.iets3.core.expr.toplevel.structure.AbstractFunctionLikeAdapter");
  }

  private static final class PROPS {
    /*package*/ static final SProperty ext$atYv = MetaAdapterFactory.getProperty(0x9464fa065ab9409bL, 0x927464ab29588457L, 0x427ce523083b8a2fL, 0x27b717d14a8df4edL, "ext");
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink type$MFr_ = MetaAdapterFactory.getContainmentLink(0x71934284d7d145eeL, 0xa0548c072591085fL, 0x465d5f01132db232L, 0x465d5f01132db23cL, "type");
    /*package*/ static final SContainmentLink fun$NLoa = MetaAdapterFactory.getContainmentLink(0x71934284d7d145eeL, 0xa0548c072591085fL, 0x5b6b0ca1fa4e6b6L, 0x5b6b0ca1f838e57L, "fun");
    /*package*/ static final SContainmentLink toplevelExprContent$igxr = MetaAdapterFactory.getContainmentLink(0x71934284d7d145eeL, 0xa0548c072591085fL, 0x3493a42991cec5c8L, 0x3493a42991cee203L, "toplevelExprContent");
    /*package*/ static final SContainmentLink functionLike$1qr0 = MetaAdapterFactory.getContainmentLink(0x71934284d7d145eeL, 0xa0548c072591085fL, 0x4aa68aac0c23aa4L, 0x4aa68aac0c267f3L, "functionLike");
  }
}
