package org.iets3.core.expr.toplevel.structure;

/*Generated by MPS */

import jetbrains.mps.lang.smodel.LanguageConceptIndex;
import jetbrains.mps.lang.smodel.LanguageConceptIndexBuilder;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import org.jetbrains.mps.openapi.language.SAbstractConcept;

public final class LanguageConceptSwitch {
  private final LanguageConceptIndex myIndex;
  public static final int AbstractEnumSortOrder = 0;
  public static final int AbstractFunctionAdapter = 1;
  public static final int AbstractFunctionLikeAdapter = 2;
  public static final int AbstractToplevelExprAdapter = 3;
  public static final int AbstractTypeDeclaration = 4;
  public static final int AllLitList = 5;
  public static final int BuilderAdapter = 6;
  public static final int BuilderElement = 7;
  public static final int BuilderExpression = 8;
  public static final int Constant = 9;
  public static final int ConstantRef = 10;
  public static final int EmptyMember = 11;
  public static final int EmptyToplevelContent = 12;
  public static final int EnumDeclaration = 13;
  public static final int EnumIndexOp = 14;
  public static final int EnumIsInSelector = 15;
  public static final int EnumIsInTarget = 16;
  public static final int EnumIsTarget = 17;
  public static final int EnumLiteral = 18;
  public static final int EnumLiteralRef = 19;
  public static final int EnumSortByDeclaration = 20;
  public static final int EnumSortByLiteral = 21;
  public static final int EnumSortByValue = 22;
  public static final int EnumType = 23;
  public static final int EnumValueAccessor = 24;
  public static final int ExtensionFunctionCall = 25;
  public static final int FieldSetter = 26;
  public static final int FunRef = 27;
  public static final int Function = 28;
  public static final int FunctionCall = 29;
  public static final int GroupByOp = 30;
  public static final int GroupKeyTarget = 31;
  public static final int GroupMembersTarget = 32;
  public static final int GroupType = 33;
  public static final int IConstantScopeProvider = 34;
  public static final int IDeclarationExtensionContext = 35;
  public static final int IEnumScopeProvider = 36;
  public static final int IFunctionContainer = 37;
  public static final int IFunctionLikeContainer = 38;
  public static final int IFunctionScopeProvider = 39;
  public static final int IRecordDeclaration = 40;
  public static final int IRecordMember = 41;
  public static final int IRecordMemberScopeProvider = 42;
  public static final int IRecordScopeProvider = 43;
  public static final int IRecordType = 44;
  public static final int ITopLevelContainer = 45;
  public static final int IToplevelExprContent = 46;
  public static final int IToplevelExprContentContainer = 47;
  public static final int ITypedefScopeProvider = 48;
  public static final int InlineRecordMemberAccess = 49;
  public static final int InlineRecordType = 50;
  public static final int Library = 51;
  public static final int NewValueSetter = 52;
  public static final int OldMemberRef = 53;
  public static final int OldValueExpr = 54;
  public static final int ProjectIt = 55;
  public static final int ProjectMember = 56;
  public static final int ProjectOp = 57;
  public static final int QualifierRef = 58;
  public static final int RecordChangeTarget = 59;
  public static final int RecordComparisonOrder = 60;
  public static final int RecordDeclaration = 61;
  public static final int RecordLiteral = 62;
  public static final int RecordMember = 63;
  public static final int RecordMemberRefInConstraint = 64;
  public static final int RecordType = 65;
  public static final int RecordTypeAdapter = 66;
  public static final int ReferenceableFlag = 67;
  public static final int SectionMarker = 68;
  public static final int Typedef = 69;
  public static final int TypedefContractValExpr = 70;
  public static final int TypedefType = 71;

  public LanguageConceptSwitch() {
    LanguageConceptIndexBuilder builder = new LanguageConceptIndexBuilder(0x71934284d7d145eeL, 0xa0548c072591085fL);
    builder.put(0x6d72ecc16d953cfeL, AbstractEnumSortOrder);
    builder.put(0x5b6b0ca1fa4e6b6L, AbstractFunctionAdapter);
    builder.put(0x4aa68aac0c23aa4L, AbstractFunctionLikeAdapter);
    builder.put(0x3493a42991cec5c8L, AbstractToplevelExprAdapter);
    builder.put(0x78fde337e44ec630L, AbstractTypeDeclaration);
    builder.put(0x28e06ca064d916e8L, AllLitList);
    builder.put(0x465d5f01132db228L, BuilderAdapter);
    builder.put(0x465d5f01132dafdfL, BuilderElement);
    builder.put(0x465d5f01132dafd3L, BuilderExpression);
    builder.put(0x62632b96c1b50dccL, Constant);
    builder.put(0x78b257522b24f39L, ConstantRef);
    builder.put(0x520e8ad7ba4b2833L, EmptyMember);
    builder.put(0x78b257522c13353L, EmptyToplevelContent);
    builder.put(0x61fe216664a72eaeL, EnumDeclaration);
    builder.put(0x3031a8d5c8744c8L, EnumIndexOp);
    builder.put(0x6f1c76e8c8cb0fcdL, EnumIsInSelector);
    builder.put(0x6f1c76e8c8cb0187L, EnumIsInTarget);
    builder.put(0x5a9550a5f5da059dL, EnumIsTarget);
    builder.put(0x61fe216664a72ed1L, EnumLiteral);
    builder.put(0x61fe216664a736c5L, EnumLiteralRef);
    builder.put(0x6d72ecc16d953d05L, EnumSortByDeclaration);
    builder.put(0x6d72ecc16d953cffL, EnumSortByLiteral);
    builder.put(0x6d72ecc16d953d02L, EnumSortByValue);
    builder.put(0x61fe216664a730bbL, EnumType);
    builder.put(0x3f863cbc0146589aL, EnumValueAccessor);
    builder.put(0x27b717d14a8f82d7L, ExtensionFunctionCall);
    builder.put(0x465d5f01132dafecL, FieldSetter);
    builder.put(0x427ce52308460f7cL, FunRef);
    builder.put(0x427ce523083c44a3L, Function);
    builder.put(0x427ce5230842b3ecL, FunctionCall);
    builder.put(0x73194702f05f7592L, GroupByOp);
    builder.put(0x73194702f071c6daL, GroupKeyTarget);
    builder.put(0x73194702f07abfb8L, GroupMembersTarget);
    builder.put(0x73194702f05f0debL, GroupType);
    builder.put(0x62632b96c1cc3d70L, IConstantScopeProvider);
    builder.put(0x6157905d6177b58L, IDeclarationExtensionContext);
    builder.put(0x61fe216664a73143L, IEnumScopeProvider);
    builder.put(0x5b6b0ca1fa4d6ffL, IFunctionContainer);
    builder.put(0x4aa68aac0c23aa0L, IFunctionLikeContainer);
    builder.put(0x27b717d14a8a1613L, IFunctionScopeProvider);
    builder.put(0x85e1e1330497e6fL, IRecordDeclaration);
    builder.put(0x85e1e1330376a27L, IRecordMember);
    builder.put(0x6ced559c2460a9b5L, IRecordMemberScopeProvider);
    builder.put(0x7a477bfec23b9febL, IRecordScopeProvider);
    builder.put(0x3c10dabb94384796L, IRecordType);
    builder.put(0x171e34aef35c5c70L, ITopLevelContainer);
    builder.put(0x27b717d14a8b21f9L, IToplevelExprContent);
    builder.put(0x3493a42991cec5c5L, IToplevelExprContentContainer);
    builder.put(0x6b6d642f1741deb0L, ITypedefScopeProvider);
    builder.put(0x73194702f1771dbcL, InlineRecordMemberAccess);
    builder.put(0x73194702f12a0ccfL, InlineRecordType);
    builder.put(0x78b257522c0608fL, Library);
    builder.put(0x1156bc3bceb768f6L, NewValueSetter);
    builder.put(0xb6282c45313f471L, OldMemberRef);
    builder.put(0xb6282c453011bf4L, OldValueExpr);
    builder.put(0x73194702f1408997L, ProjectIt);
    builder.put(0x73194702f12a0d28L, ProjectMember);
    builder.put(0x73194702f12a0d24L, ProjectOp);
    builder.put(0x48dc5b40f074fef7L, QualifierRef);
    builder.put(0x1156bc3bceb768dbL, RecordChangeTarget);
    builder.put(0x373cc1802a0589c0L, RecordComparisonOrder);
    builder.put(0x7a477bfec237e8b6L, RecordDeclaration);
    builder.put(0x7a477bfec24be9a8L, RecordLiteral);
    builder.put(0x7a477bfec237e8b9L, RecordMember);
    builder.put(0xe377da7335bc308L, RecordMemberRefInConstraint);
    builder.put(0x7a477bfec237e8c2L, RecordType);
    builder.put(0x465d5f01132db232L, RecordTypeAdapter);
    builder.put(0x6bff9a8a7cd0a24cL, ReferenceableFlag);
    builder.put(0x6b6d642f171d6a46L, SectionMarker);
    builder.put(0x6b6d642f1741de68L, Typedef);
    builder.put(0x2e03fe8918a0f2abL, TypedefContractValExpr);
    builder.put(0x6b6d642f1741ded6L, TypedefType);
    myIndex = builder.seal();
  }

  /*package*/ int index(SConceptId cid) {
    return myIndex.index(cid);
  }

  public int index(SAbstractConcept concept) {
    return myIndex.index(concept);
  }
}
