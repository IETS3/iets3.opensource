package org.iets3.variability.configuration.base.behavior;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import org.jetbrains.mps.openapi.model.SNode;
import org.iets3.variability.featuremodel.base.behavior.FeatureModel__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.iets3.variability.configuration.base.plugin.FeatureModelConfigurationConstraintsUtil;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SConcept;

/**
 * TODO: Find a proper name for this class. Maybe refactor it, too.
 */
public class Traversals {
  private static final Logger LOG = Logger.getLogger(Traversals.class);

  /**
   * Transforms the tree at this node. Usually applied on a FeatureModelConfig.
   */
  public void adaptConfigToFeatureChanges(SNode config) {

    boolean containsCycle = (boolean) FeatureModel__BehaviorDescriptor.containsCycle_id3eg222GEqlF.invoke(SNodeOperations.getNodeAncestor(SLinkOperations.getTarget(config, LINKS.targetFeature$16lA), CONCEPTS.FeatureModel$X0, false, false));

    if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(config, LINKS.content$Wdfq), CONCEPTS.FeatureConfigurationErrorContent$W0) && !(containsCycle)) {
      SLinkOperations.setTarget(config, LINKS.content$Wdfq, FeatureModelConfigurationConstraintsUtil.configContentByFeature(SLinkOperations.getTarget(config, LINKS.targetFeature$16lA)));
    } else if (containsCycle) {
      SLinkOperations.setTarget(config, LINKS.content$Wdfq, createFeatureConfigurationErrorContent_m6cibu_a0a0a0d0b());
    } else {
      KeepInlineConfig rootActionOfAst = createActionAstFrom(config);
      debugInfoBefore(rootActionOfAst);

      ConfigurationExchange configurationExchange = new ConfigurationExchange();
      registerActionNodesByFeatureTo(configurationExchange, rootActionOfAst);
      alternativeActions(configurationExchange, rootActionOfAst);

      debugInfoAfter(rootActionOfAst);
      applyActionToParent(null, rootActionOfAst);
    }
  }


  /**
   * Will create a tree structure consisting of subclasses of Action. Each Action corresponds to a
   * transformation of the configuration-tree which is not yet carried out. 
   */
  private KeepInlineConfig createActionAstFrom(SNode config) {
    return new KeepInlineConfig(SNodeOperations.present(config) + "", SNodeOperations.cast(SLinkOperations.getTarget(config, LINKS.content$Wdfq), CONCEPTS.InlineFeatureConfigurationContent$P5), ChildActions.childActionsByConfig(config));
  }

  /**
   * At this point each Action knows if it will remove parts of the configuration-tree. 
   * In this call it will register those subtree-configurations for later reuse.
   */
  private void registerActionNodesByFeatureTo(ConfigurationExchange configurationExchange, Action rootAction) {
    rootAction.registerByFeature(configurationExchange);
  }

  /**
   * Some Actions will create new configuration-subtrees. In this call each Action has the possibility
   * to lookup if its sub-configuration is already available in the configuration exchange.
   * If it fails alternativeAction returns the original action. Otherwise an alternative action is returned.
   */
  private void alternativeActions(final ConfigurationExchange configurationExchange, Action action) {
    List<Action> transformedChildren = ListSequence.fromList((action.getChildren())).select((child) -> child.alternativeAction(configurationExchange)).toList();
    action.setChildren(transformedChildren);

    ListSequence.fromList(transformedChildren).visitAll((childAction) -> alternativeActions(configurationExchange, childAction));
  }


  /**
   * Apply each action recursively. This will transform the source configuration-tree to the final result.
   */
  private void applyActionToParent(SNode parent, Action action) {
    Iterable<SNode> confContentsForChildren = action.applyTo(parent);
    for (Action childAction : ListSequence.fromList(action.getChildren())) {
      for (SNode subContent : Sequence.fromIterable(confContentsForChildren)) {
        applyActionToParent(subContent, childAction);
      }
    }

    action.sortChildren();
  }

  /**
   * Print the tree, for debugging purposes.
   */
  public void print(final String indent, Action action) {
    if (LOG.isDebugLevel()) {
      LOG.debug(indent.length() + indent + action);
    }
    ListSequence.fromList(action.getChildren()).visitAll((it) -> print(indent + ">", it));
  }

  private void debugInfoAfter(KeepInlineConfig rootActionOfAst) {
    if (LOG.isDebugLevel()) {
      LOG.debug("--------AFTER Transforming---------");
    }
    print("", rootActionOfAst);
    if (LOG.isDebugLevel()) {
      LOG.debug("");
    }
  }

  private void debugInfoBefore(KeepInlineConfig rootActionOfAst) {
    if (LOG.isDebugLevel()) {
      LOG.debug("--------BEFORE Transforming--------");
    }
    print("", rootActionOfAst);
  }


  private static SNode createFeatureConfigurationErrorContent_m6cibu_a0a0a0d0b() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.FeatureConfigurationErrorContent$W0);
    return n0.getResult();
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink targetFeature$16lA = MetaAdapterFactory.getReferenceLink(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x302aa0c2ddab8940L, 0x5cf5c0d0479ec91eL, "targetFeature");
    /*package*/ static final SContainmentLink content$Wdfq = MetaAdapterFactory.getContainmentLink(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x302aa0c2ddab8940L, 0x5cf5c0d0479f4bc8L, "content");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept FeatureModel$X0 = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x375cadc47516a211L, "org.iets3.variability.featuremodel.base.structure.FeatureModel");
    /*package*/ static final SConcept FeatureConfigurationErrorContent$W0 = MetaAdapterFactory.getConcept(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x34aae17cd64425dbL, "org.iets3.variability.configuration.base.structure.FeatureConfigurationErrorContent");
    /*package*/ static final SConcept InlineFeatureConfigurationContent$P5 = MetaAdapterFactory.getConcept(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x5cf5c0d0479f4bfcL, "org.iets3.variability.configuration.base.structure.InlineFeatureConfigurationContent");
  }
}
