package org.iets3.variability.configuration.base.behavior;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import com.mbeddr.mpsutil.interpreter.rt.IEnvironment;
import org.iets3.variability.featuremodel.base.behavior.IUsingParamRef__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Objects;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.iets3.variability.featuremodel.base.behavior.IFeatureRefExpr__BehaviorDescriptor;
import org.iets3.core.expr.base.behavior.Expression__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SContainmentLink;

/**
 * Utility class for parsing an expression with a path to a feature and finding the corresponding configuration item.
 * 
 * Note: The FeatureExprInterpreter can do the same, but here the interpreter isn't needed if it is clear
 * that the expression is a dotted path to some feature.
 */
public class FeatureRefExprUtil {

  public static SNode resolveConfig(SNode contextAFC, SNode featureRefExpr, SNode subFeature) {
    SNode afc = resolveConfig_WithUsing(contextAFC, featureRefExpr);
    return check_xpxkqy_a1a1(afc, subFeature);
  }

  public static SNode resolveConfig(SNode contextAFC, SNode featureRefExpr) {
    return resolveConfig_WithUsing(contextAFC, featureRefExpr);
  }


  /**
   * Resolve a referenced config. For using-parameters, check interpreter environment.
   * 
   * @param contextAFC the context configuration where the referencing expression lives
   * @param featureRefExpr the referencing expression
   * @param env environment containing mapping from using-params to AFCs
   * @return the resolved config node
   */
  public static SNode resolveConfig(SNode contextAFC, SNode featureRefExpr, final IEnvironment env) {
    return resolveConfigAux(contextAFC, featureRefExpr, (upr) -> {
      Object obj = env.getInCurrent(IUsingParamRef__BehaviorDescriptor.param_id5QHstxV$XmW.invoke(upr));
      if (obj instanceof SNode) {
        {
          final SNode result = (as_xpxkqy_a0a0a0a0b0c0a0g(obj, SNode.class));
          if (SNodeOperations.isInstanceOf(result, CONCEPTS.AbstractFeatureConfiguration$3P)) {
            return result;
          }
        }
      }
      return null;
    });
  }

  /**
   * Resolve a referenced config. For using-parameters, check with-parameters of configuration.
   * 
   * @param contextAFC the context configuration where the referencing expression lives
   * @param expr the referencing expression
   * @return the resolved config node
   */
  private static SNode resolveConfig_WithUsing(final SNode contextAFC, SNode expr) {
    return resolveConfigAux(contextAFC, expr, (final SNode upr) -> {
      SNode actual = Sequence.fromIterable(FeatureModelConfiguration__BehaviorDescriptor.getValidUsedConfigs_id3j7vM_E99Ji.invoke(AbstractFeatureConfiguration__BehaviorDescriptor.configurationRoot_id6SMbav4Irm1.invoke(contextAFC))).findFirst((it) -> Objects.equals(SLinkOperations.getTarget(it, LINKS.param$pwLK), IUsingParamRef__BehaviorDescriptor.param_id5QHstxV$XmW.invoke(upr)));
      // if no actual param is found for this using-ref, we return null to indicate "undefined"
      if ((actual == null)) {
        return null;
      }
      return SLinkOperations.getTarget(actual, LINKS.config$SCsb);
    });
  }

  private static SNode resolveConfigAux(SNode contextAFC, SNode expr, _FunctionTypes._return_P1_E0<? extends SNode, ? super SNode> usingParamResolver) {
    // special handling for IUsingParamRefs (it might be a IFeatureRefExpr, so we catch it first)
    {
      final SNode upr = expr;
      if (SNodeOperations.isInstanceOf(upr, CONCEPTS.IUsingParamRef$MI)) {
        return usingParamResolver.invoke(upr);
      }
    }

    {
      final SNode frex = expr;
      if (SNodeOperations.isInstanceOf(frex, CONCEPTS.IFeatureRefExpr$Cn)) {
        return AbstractFeatureConfiguration__BehaviorDescriptor.findConfiguration_id4zfp5i3BhvO.invoke(contextAFC, IFeatureRefExpr__BehaviorDescriptor.feature_id3q2wVeoIYrV.invoke(frex));
      }
    }

    {
      final SNode dex = expr;
      if (SNodeOperations.isInstanceOf(dex, CONCEPTS.DotExpression$jp)) {
        SNode lhsAFC = resolveConfigAux(contextAFC, SLinkOperations.getTarget(dex, LINKS.expr$CW3E), usingParamResolver);
        if ((lhsAFC == null)) {
          return null;
        }
        {
          final SNode rhs = SLinkOperations.getTarget(dex, LINKS.target$u23F);
          if (SNodeOperations.isInstanceOf(rhs, CONCEPTS.SubFeatureDotTarget$5P)) {
            return AbstractFeatureConfiguration__BehaviorDescriptor.findConfiguration_id4zfp5i3BhvO.invoke(lhsAFC, SLinkOperations.getTarget(rhs, LINKS.feature$hhv5));
          }
        }
      }
    }

    throw new RuntimeException("Invalid feature expression '" + Expression__BehaviorDescriptor.renderReadable_id4Y0vh0cfqjE.invoke(expr) + "'");
  }
  private static SNode check_xpxkqy_a1a1(SNode checkedDotOperand, SNode subFeature) {
    if (null != checkedDotOperand) {
      return AbstractFeatureConfiguration__BehaviorDescriptor.findConfiguration_id4zfp5i3BhvO.invoke(checkedDotOperand, subFeature);
    }
    return null;
  }
  private static <T> T as_xpxkqy_a0a0a0a0b0c0a0g(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept AbstractFeatureConfiguration$3P = MetaAdapterFactory.getConcept(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x302aa0c2ddab8940L, "org.iets3.variability.configuration.base.structure.AbstractFeatureConfiguration");
    /*package*/ static final SInterfaceConcept IUsingParamRef$MI = MetaAdapterFactory.getInterfaceConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x5dad71d87b93d5a8L, "org.iets3.variability.featuremodel.base.structure.IUsingParamRef");
    /*package*/ static final SInterfaceConcept IFeatureRefExpr$Cn = MetaAdapterFactory.getInterfaceConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x368283b398bbe6d5L, "org.iets3.variability.featuremodel.base.structure.IFeatureRefExpr");
    /*package*/ static final SConcept DotExpression$jp = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7cef88020a0f4249L, "org.iets3.core.expr.base.structure.DotExpression");
    /*package*/ static final SConcept SubFeatureDotTarget$5P = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd85baccL, "org.iets3.variability.featuremodel.base.structure.SubFeatureDotTarget");
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink param$pwLK = MetaAdapterFactory.getReferenceLink(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x7d6d839c2865b139L, 0x7d6d839c2866af76L, "param");
    /*package*/ static final SReferenceLink config$SCsb = MetaAdapterFactory.getReferenceLink(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x7d6d839c2865b139L, 0x7d6d839c2866b1ceL, "config");
    /*package*/ static final SContainmentLink expr$CW3E = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x3b256bb6ae8048d8L, 0x3b256bb6ae8048d9L, "expr");
    /*package*/ static final SContainmentLink target$u23F = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7cef88020a0f4249L, 0x7cef88020a0f424bL, "target");
    /*package*/ static final SReferenceLink feature$hhv5 = MetaAdapterFactory.getReferenceLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd85baccL, 0x7cde27c7fd85bad9L, "feature");
  }
}
