package org.iets3.variability.configuration.base.plugin;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import org.jetbrains.mps.openapi.model.SNode;
import org.iets3.core.base.behavior.IResult;
import org.iets3.variability.configuration.base.behavior.FeatureModelConfiguration__BehaviorDescriptor;
import java.util.concurrent.CompletableFuture;
import java.util.List;
import org.iets3.variability.base.behavior.MpsActions;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.Optional;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicReference;
import com.intellij.openapi.application.ApplicationManager;
import java.util.Collection;
import jetbrains.mps.baseLanguage.logging.rt.LogContext;
import java.util.Collections;
import org.iets3.core.base.behavior.ICanStoreCheckResult__BehaviorDescriptor;
import org.apache.commons.lang3.tuple.Pair;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.iets3.variability.configuration.base.behavior.FeatureModelConfHashUtil;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.iets3.variability.configuration.base.behavior.ConfigRelationFinder;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.iets3.core.base.behavior.ICanRunCheckManually__BehaviorDescriptor;
import org.iets3.analysis.base.plugin.AsyncSolverTaskExecutor;
import org.iets3.analysis.solversupport.util.plugin.ISolvableSettingsModel;
import java.util.Map;
import org.iets3.variability.configuration.base.behavior.AbstractFeatureConfiguration__BehaviorDescriptor;
import jetbrains.mps.smodel.SNodeMatcher;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.iets3.analysis.solversupport.util.plugin.FixedValueCategory;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.iets3.variability.configuration.base.behavior.FeatureAttributeAssignment__BehaviorDescriptor;
import org.iets3.analysis.base.behavior.ISolvable__BehaviorDescriptor;
import org.iets3.core.base.behavior.IDetectNeedToRunManually__BehaviorDescriptor;
import org.iets3.analysis.base.behavior.AbstractSolverTask__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SEnumerationLiteral;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SEnumOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SConcept;

/**
 * Provides functionality for checking constraints of a FMC and deriving values (SelectionStates, AttributeValues) 
 * from them.
 */
public class ConfigurationSolverFacade {
  private static final Logger LOG = Logger.getLogger(ConfigurationSolverFacade.class);

  protected final SNode fmc;
  public ConfigurationSolverFacade(SNode fmc) {
    this.fmc = fmc;
  }

  public IResult runSolver() {
    FeatureModelConfiguration__BehaviorDescriptor.removeError_id5UDdUfokHMF.invoke(this.fmc);
    IResult solverResult = this.solverResult();
    FeatureModelConfiguration__BehaviorDescriptor.setComplete_id2pcB_fS8I0N.invoke(this.fmc);
    return solverResult;
  }

  public CompletableFuture<List<IResult>> solverResultsAsync(final MpsActions mpsActions) {
    final Wrappers._T<String> configInfo = new Wrappers._T<String>("");
    mpsActions.readAction(() -> configInfo.value = " for configuration '" + SPropertyOperations.getString(ConfigurationSolverFacade.this.fmc, PROPS.name$MnvL) + "'");
    if (LOG.isDebugLevel()) {
      LOG.debug("Async solver run requested" + configInfo.value);
    }

    mpsActions.writeAction(() -> FeatureModelConfiguration__BehaviorDescriptor.removeError_id5UDdUfokHMF.invoke(ConfigurationSolverFacade.this.fmc));

    CompletableFuture<List<IResult>> solverRunTransitiveFuture = this.runSolvableAsync(mpsActions).thenApplyAsync((final List<IResult> result) -> {
      Optional<IResult> failedCheck = result.stream().filter((IResult cr) -> !(cr.isOk())).findFirst();

      // Keep as AbstractFeatureConfiguration_Constraints loops infinite
      storeLastResult(result, failedCheck);
      final ConfigFixedValues configFixedValues = ConfigurationSolverFacade.this.configFixedValuesFor(mpsActions, result);

      // Threading primitives are useful to make a rendez-vous between the thread te current Future
      // runs in and the MPA-Applications-WriteThread
      final CountDownLatch latch = new CountDownLatch(1);
      // stores Futures running a SolverCheck to referrers of this FMC 
      final AtomicReference<CompletableFuture<Void>> referrersSolverCheck = new AtomicReference<CompletableFuture<Void>>(CompletableFuture.allOf());

      // Constraint to use an MPS-Thread for changing the model by MPS see: https://plugins.jetbrains.com/docs/intellij/threading-model.html#invoking-operations-on-edt-and-modality
      ApplicationManager.getApplication().invokeLaterOnWriteThread(() -> {
        try {
          if (LOG.isDebugLevel()) {
            LOG.debug("Updating solver results" + configInfo.value);
          }
          Collection<CompletableFuture<List<IResult>>> referrerSolverChecks = ConfigurationSolverFacade.this.updateSelectionsAttributeAssignments(mpsActions, result, configFixedValues);

          referrersSolverCheck.set(ConfigurationSolverFacade.this.makeWaitForAll(referrerSolverChecks));
        } catch (Throwable t) {
          if (LOG.isErrorLevel()) {
            LOG.error("Error running async solver [1]", t);
          }
          LogContext.with(ConfigurationSolverFacade.class, t, null, null).error("Error running solver async");
          mpsActions.writeAction(() -> FeatureModelConfiguration__BehaviorDescriptor.setComplete_id2pcB_fS8I0N.invoke(ConfigurationSolverFacade.this.fmc));
          throw new RuntimeException(t);
        } finally {
          // MPS-Thread done
          latch.countDown();
        }
      });
      try {
        // Wait for MPS Thread
        latch.await();
      } catch (InterruptedException e) {
        throw new RuntimeException(e);
      }

      // Build Future that after the referrers Futures completed return the result of the solvercheck of this FMC
      return referrersSolverCheck.get().thenCompose((p1) -> CompletableFuture.completedFuture(result));
    }).thenCompose((p1) -> p1);

    return solverRunTransitiveFuture.exceptionally((final Throwable t) -> {
      mpsActions.writeAction(() -> {
        FeatureModelConfiguration__BehaviorDescriptor.setComplete_id2pcB_fS8I0N.invoke(ConfigurationSolverFacade.this.fmc);
        if (LOG.isErrorLevel()) {
          LOG.error("Error running async solver [2]", t);
        }
        LogContext.with(ConfigurationSolverFacade.class, t, null, null).error("Error running solver async");
      });
      return Collections.<IResult>emptyList();
    });
  }

  private void storeLastResult(final List<? extends IResult> result, Optional<? extends IResult> failedCheck) {
    failedCheck.ifPresentOrElse((failed) -> ICanStoreCheckResult__BehaviorDescriptor.storeLastResult_id3R3AIvuq5Dp.invoke(ConfigurationSolverFacade.this.fmc, failed), () -> {
      if (result.size() > 0) {
        ICanStoreCheckResult__BehaviorDescriptor.storeLastResult_id3R3AIvuq5Dp.invoke(ConfigurationSolverFacade.this.fmc, result.get(0));
      } else {
        ICanStoreCheckResult__BehaviorDescriptor.storeLastResult_id3R3AIvuq5Dp.invoke(ConfigurationSolverFacade.this.fmc, IResult.make(IResult.MessageType.Error, "No solver result present.", Collections.<SNode>emptyList(), null));
      }
    });
  }

  private Collection<CompletableFuture<List<IResult>>> updateSelectionsAttributeAssignments(final MpsActions mpsAction, final Collection<IResult> allChecks, final ConfigFixedValues configFixedValues) {
    if (needsUpdate(mpsAction, configFixedValues)) {
      mpsAction.commandAction(() -> {
        ConfigurationSolverFacade.this.updateConfig(configFixedValues);

        Collection<Pair<SNode, SNode>> expressionForFeatureAttributeAssignmentAlreadySet = configFixedValues.expressionForFeatureAttributeAssignment();

        List<SNode> faas = CollectionSequence.fromCollection(expressionForFeatureAttributeAssignmentAlreadySet).select((it) -> it.getValue()).toList();
        optimizeDefaultAttributes(allChecks, faas);

        mpsAction.writeAction(new Runnable() {
          @Override
          public void run() {
            FeatureModelConfiguration__BehaviorDescriptor.updateAdaptHash_id2XyYtG$Jnmi.invoke(fmc);
            FeatureModelConfHashUtil.setHashOfSolverRelevantData(fmc);
          }
        });
      });

      // now go up the tree and find all referrers in the current module, they should update as well
      final Wrappers._T<List<SNode>> allReferrers = new Wrappers._T<List<SNode>>();
      mpsAction.readAction(() -> allReferrers.value = Sequence.fromIterable(ConfigRelationFinder.allReferrers(SNodeOperations.getModel(ConfigurationSolverFacade.this.fmc), ConfigurationSolverFacade.this.fmc)).toList());
      assert allReferrers.value != null;
      return ListSequence.fromList(allReferrers.value).select((it) -> new ConfigurationSolverFacade(it).solverResultsAsync(mpsAction)).toList();
    }
    return Collections.singletonList(CompletableFuture.completedFuture(Collections.<IResult>emptyList()));
  }

  private boolean needsUpdate(MpsActions mpsAction, final ConfigFixedValues configFixedValues) {
    final Wrappers._boolean updateChanges = new Wrappers._boolean(false);
    mpsAction.readAction(() -> updateChanges.value = ConfigurationSolverFacade.this.needsUpdateToSolverResult(configFixedValues));
    return updateChanges.value;
  }

  /**
   * override for the case of setting default values. Note that due to constraints
   * it might be the case that not all default values for attributes can be set. 
   * 
   * @param allChecks  
   * @param expressionForFeatureAttributeAssignmentAlreadySet  
   */
  protected void optimizeDefaultAttributes(Collection<IResult> allChecks, List<SNode> expressionForFeatureAttributeAssignmentAlreadySet) {
  }

  private CompletableFuture<List<IResult>> runSolvableAsync(MpsActions actions) {
    final Wrappers._boolean shouldBeChecked = new Wrappers._boolean();
    actions.readAction(() -> shouldBeChecked.value = (boolean) ICanRunCheckManually__BehaviorDescriptor.shouldBeChecked_id1996aX856sE.invoke(ConfigurationSolverFacade.this.fmc));
    if (shouldBeChecked.value) {
      CompletableFuture<List<IResult>> submitted = AsyncSolverTaskExecutor.submitISolvable(this.fmc, ISolvableSettingsModel.INSTANCE.timeout(), true);
      if (LOG.isDebugLevel()) {
        LOG.debug("Async solver task submitted (" + submitted + ")");
      }
      return submitted;
    } else {
      if (LOG.isDebugLevel()) {
        LOG.debug("Async solver aborted due to shouldBeChecked condition");
      }
    }
    return CompletableFuture.completedFuture(Collections.<IResult>emptyList());
  }


  private CompletableFuture<Void> makeWaitForAll(Collection<CompletableFuture<List<IResult>>> referrerSolverChecks) {
    CompletableFuture<?>[] toArray = referrerSolverChecks.toArray(new CompletableFuture<?>[0]);
    CompletableFuture<Void> allOf = CompletableFuture.allOf(toArray);
    return allOf;
  }

  /**
   * Implement if you need to provide values (SelectionState, FeatureAttributeValues) for the model
   * which have been determined by an underlying constraint solver.
   * 
   * @param mpsActions  
   * @param result  
   * @return  
   */
  protected ConfigFixedValues configFixedValuesFor(MpsActions mpsActions, Collection<IResult> result) {
    return new ConfigFixedValues();
  }

  private boolean needsUpdateToSolverResult(ConfigFixedValues configFixedValues) {
    int oldHash = (int) FeatureModelConfiguration__BehaviorDescriptor.hashOfSolverRelevantData_id2SUMz4mMQjh.invoke(fmc);
    int currentHash = (int) FeatureModelConfiguration__BehaviorDescriptor.computeHashOfSolverRelevantData_id2SUMz4mKzNq.invoke(fmc);

    if (currentHash != oldHash) {
      return true;
    }
    if (someSelectionStateChanged(configFixedValues)) {
      return true;
    }

    return hasAttributeValueChanged(configFixedValues);
  }

  private boolean hasAttributeValueChanged(ConfigFixedValues configFixedValues) {
    // check if some to a attribute assigned value changed
    final Map<SNode, SNode> attributeAssignment2Expression = configFixedValues.mapOfAttributeAssignmentToFixedValue();
    return ListSequence.fromList(AbstractFeatureConfiguration__BehaviorDescriptor.allAttributeAssignments_id58DfSnqtfhS.invoke(fmc)).any((attrAssign) -> {
      SNode newExpr = attributeAssignment2Expression.get(attrAssign);
      return (newExpr != null ? !(new SNodeMatcher().match(SLinkOperations.getTarget(attrAssign, LINKS.value$kgDc), newExpr)) : SLinkOperations.getTarget(attrAssign, LINKS.value$kgDc) != null);
    });
  }

  private boolean someSelectionStateChanged(ConfigFixedValues configFixedValues) {
    List<SNode> subFeatureConfigurations = ListSequence.fromList(AbstractFeatureConfiguration__BehaviorDescriptor.descendantConfigItems_id24slSGEQ$MS.invoke(fmc)).toList();

    final Map<SNode, FixedValueCategory> afc2FixedValue = (configFixedValues.mapOfConfigurationToFixedValue());

    return ListSequence.fromList(subFeatureConfigurations).any((it) -> {
      FixedValueCategory fvc = afc2FixedValue.get(it);
      return (fvc != null ? !(matches(SPropertyOperations.getEnum(it, PROPS.selectionState$zbc1), fvc)) : !(matches(SPropertyOperations.getEnum(it, PROPS.selectionState$zbc1), FixedValueCategory.NotFixed)));
    });
  }

  private String errorMessageForFailedFixedValues(String msg) {
    return (ListSequence.fromList(SNodeOperations.getNodeDescendants(fmc, CONCEPTS.AbstractFeatureConfiguration$3P, false, new SAbstractConcept[]{})).any((it) -> (boolean) AbstractFeatureConfiguration__BehaviorDescriptor.hasForcedSelection_id1wdBX7uVtPv.invoke(it)) ? "Forced selection prevents solver success: " + msg : msg);
  }


  private void unsetAutomaticAttributeAssignment() {
    ListSequence.fromList(SNodeOperations.getNodeDescendants(fmc, CONCEPTS.FeatureAttributeAssignment$1f, false, new SAbstractConcept[]{})).where((it) -> (boolean) FeatureAttributeAssignment__BehaviorDescriptor.automatic_idzJQZm70xzm.invoke(it)).visitAll((it) -> {
      SLinkOperations.setTarget(it, LINKS.value$kgDc, null);
      FeatureAttributeAssignment__BehaviorDescriptor.unsetAutomatic_id6jw22F99kPS.invoke(it);
    });

  }

  private void forcedChoiceToUserChoice() {
    Iterable<SNode> descFMC = (SNodeOperations.getNodeDescendants(fmc, CONCEPTS.FeatureConfiguration$x2, false, new SAbstractConcept[]{}));
    Sequence.fromIterable(descFMC).where((it) -> (boolean) AbstractFeatureConfiguration__BehaviorDescriptor.isForcedTrue_id7yoiok7KC7b.invoke(it)).visitAll((it) -> SPropertyOperations.setEnum(it, PROPS.selectionState$zbc1, 0x5db06c237c250a7cL, "userTrue"));
    Sequence.fromIterable(descFMC).where((it) -> (boolean) AbstractFeatureConfiguration__BehaviorDescriptor.isForcedFalse_id7yoiok7KEd_.invoke(it)).visitAll((it) -> SPropertyOperations.setEnum(it, PROPS.selectionState$zbc1, 0x5db06c237c250a81L, "userFalse"));
  }

  private void propagateToReferringConfigurations() {
    // now go up the tree and find all referrers in the current module, they should update as well
    for (SNode otherFMC : Sequence.fromIterable(ConfigRelationFinder.allReferrers(SNodeOperations.getModel(fmc), fmc))) {
      // Necessary so the solver does not abort
      SPropertyOperations.assign(otherFMC, PROPS.complete$4SB6, true);
      // ToDo triggers SolverTasks, but does not collect results of them. Goal: A global problem report of all SolverTask results 
      ISolvable__BehaviorDescriptor.runSolver_id7QODtLw3SMH.invoke(otherFMC);
    }
  }

  private void updateConfig(ConfigFixedValues configFixedValues) {
    configFixedValues.errorMessage().ifPresent((errMsg) -> {
      FeatureModelConfiguration__BehaviorDescriptor.showError_id5UDdUfokAGW.invoke(ConfigurationSolverFacade.this.fmc, ConfigurationSolverFacade.this.errorMessageForFailedFixedValues(errMsg));
      return;
    });
    SPropertyOperations.assign(fmc, PROPS.complete$4SB6, false);
    this.forcedChoiceToUserChoice();
    this.unsetAutomaticAttributeAssignment();

    updateState(configFixedValues);
    this.propagateToReferringConfigurations();
    IDetectNeedToRunManually__BehaviorDescriptor.updateHash_id6MJy$PGs_q4.invoke(this.fmc);

    SPropertyOperations.assign(this.fmc, PROPS.complete$4SB6, true);
  }


  private IResult solverResult() {
    if (!(SPropertyOperations.getBoolean(this.fmc, PROPS.complete$4SB6))) {
      return IResult.make(IResult.MessageType.Info, "Skipping: Check already running", Collections.<SNode>emptyList(), null);
    }
    SPropertyOperations.assign(this.fmc, PROPS.complete$4SB6, false);

    SNode solverTask = ISolvable__BehaviorDescriptor.createSolverTask_id4pkidg67Lgb.invoke(fmc);
    AbstractSolverTask__BehaviorDescriptor.finishAndCleanup_id7rOSrvnHe0i.invoke(solverTask);
    IResult result = AbstractSolverTask__BehaviorDescriptor.run_id7rOSrvnGeUQ.invoke(solverTask);
    ICanStoreCheckResult__BehaviorDescriptor.storeLastResult_id3R3AIvuq5Dp.invoke(this.fmc, result);
    MpsActions.Dummy mpsAction = new MpsActions.Dummy();
    ConfigFixedValues configFixedValues = this.configFixedValuesFor(mpsAction, Collections.singletonList(result));
    this.updateSelectionsAttributeAssignments(mpsAction, Collections.singletonList(result), configFixedValues);
    return result;
  }


  private static boolean matches(SEnumerationLiteral selectionState, FixedValueCategory fvc) {
    return fvc.equals(FixedValueCategory.FixedTrue) && FeatureSelectionStateUtil.isSelected(selectionState) || fvc.equals(FixedValueCategory.FixedFalse) && FeatureSelectionStateUtil.isDisSelected(selectionState) || fvc.equals(FixedValueCategory.NotFixed) && SEnumOperations.getMember(MetaAdapterFactory.getEnumeration(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x5db06c237c250a73L, "org.iets3.variability.featuremodel.base.structure.FeatureSelectionState"), 0x5db06c237c250a74L, "untouched").equals(selectionState);
  }

  protected static void updateState(ConfigFixedValues fv) {
    Collection<Pair<FixedValueCategory, SNode>> valuesForSelectionState = fv.fixedValueCategoryForSelectionState();
    adoptConfigSelectionStates(valuesForSelectionState);

    CommonBaseUtil.setAttributes(fv.expressionForFeatureAttributeAssignment());
  }

  private static void adoptConfigSelectionStates(Collection<Pair<FixedValueCategory, SNode>> valuesForSelectionState) {

    for (Pair<FixedValueCategory, SNode> valueToSelectionState : CollectionSequence.fromCollection(valuesForSelectionState)) {
      FixedValueCategory value = valueToSelectionState.getKey();
      SNode config = valueToSelectionState.getValue();
      if ((boolean) AbstractFeatureConfiguration__BehaviorDescriptor.withoutUserSelection_id4aYaOlg6lwY.invoke(config)) {
        SEnumerationLiteral selectionState = (value == FixedValueCategory.FixedFalse ? SEnumOperations.getMember(MetaAdapterFactory.getEnumeration(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x5db06c237c250a73L, "org.iets3.variability.featuremodel.base.structure.FeatureSelectionState"), 0x5db06c237c250a78L, "autoFalse") : (value == FixedValueCategory.FixedTrue ? SEnumOperations.getMember(MetaAdapterFactory.getEnumeration(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x5db06c237c250a73L, "org.iets3.variability.featuremodel.base.structure.FeatureSelectionState"), 0x5db06c237c250a75L, "autoTrue") : SEnumOperations.getMember(MetaAdapterFactory.getEnumeration(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x5db06c237c250a73L, "org.iets3.variability.featuremodel.base.structure.FeatureSelectionState"), 0x5db06c237c250a74L, "untouched")));
        SPropertyOperations.setEnum(config, PROPS.selectionState$zbc1, selectionState);
      }
    }
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty selectionState$zbc1 = MetaAdapterFactory.getProperty(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x302aa0c2ddab8940L, 0x526bcda9b5a2fcdbL, "selectionState");
    /*package*/ static final SProperty complete$4SB6 = MetaAdapterFactory.getProperty(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x5cf5c0d0479ec915L, 0x427f472315a4eeb9L, "complete");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink value$kgDc = MetaAdapterFactory.getContainmentLink(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x302aa0c2ddc5ae16L, 0x302aa0c2ddd1e2aaL, "value");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept AbstractFeatureConfiguration$3P = MetaAdapterFactory.getConcept(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x302aa0c2ddab8940L, "org.iets3.variability.configuration.base.structure.AbstractFeatureConfiguration");
    /*package*/ static final SConcept FeatureAttributeAssignment$1f = MetaAdapterFactory.getConcept(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x302aa0c2ddc5ae16L, "org.iets3.variability.configuration.base.structure.FeatureAttributeAssignment");
    /*package*/ static final SConcept FeatureConfiguration$x2 = MetaAdapterFactory.getConcept(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x5cf5c0d0479ec91dL, "org.iets3.variability.configuration.base.structure.FeatureConfiguration");
  }
}
