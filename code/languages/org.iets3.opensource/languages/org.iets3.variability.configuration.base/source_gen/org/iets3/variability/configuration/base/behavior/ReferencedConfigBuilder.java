package org.iets3.variability.configuration.base.behavior;

/*Generated by MPS */

import java.util.Optional;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.iets3.variability.featuremodel.base.behavior.FeatureModelInclude__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.iets3.core.expr.base.behavior.Expression__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SProperty;

public class ReferencedConfigBuilder {

  public static Optional<ReferencedConfig> create(final ConfigCursor configItem) {
    {
      final SNode fmcr = SLinkOperations.getTarget(configItem.asNode(), LINKS.content$Wdfq);
      if (SNodeOperations.isInstanceOf(fmcr, CONCEPTS.FeatureModelConfigurationRef$kq)) {
        final SNode referencedConfig = SLinkOperations.getTarget(fmcr, LINKS.config$VWuN);
        SNode fmi = SNodeOperations.cast(configItem.feature(), CONCEPTS.FeatureModelInclude$Iq);

        Iterable<ReferencedConfig.ActualParamAssignmentPair> assignments = ListSequence.fromList(SLinkOperations.getChildren(fmi, LINKS.actualParams$nrMf)).select((ap) -> computeAssignmentPair(configItem, referencedConfig, ap));
        return Optional.of(new ReferencedConfig(referencedConfig, assignments));
      }
    }
    return Optional.empty();
  }

  private static ReferencedConfig.ActualParamAssignmentPair computeAssignmentPair(ConfigCursor configItem, SNode referencedConfig, SNode actualParam) {

    // assignment #1: get configuration from with-parameter of referenced config (might be null if no with-parameter is given)
    SNode configUsedForParamLocally = check_2mrbao_a0c0d(FeatureModelConfiguration__BehaviorDescriptor.getActualParam_id2Kcps_m3SsC.invoke(referencedConfig, SLinkOperations.getTarget(actualParam, LINKS.param$KiX)));

    // assignment #2: resolve parameter via the chain of nested FMIs and their assigned using-param expressions
    ReferencedConfig.IProvidedConfig configProvidedByOuterConfiguration = resolveConfigFromActualParam(configItem, actualParam);

    // combine both assignment results (might be conflicting)
    return new ReferencedConfig.ActualParamAssignmentPair(actualParam, configUsedForParamLocally, configProvidedByOuterConfiguration);
  }

  private static ReferencedConfig.IProvidedConfig resolveConfigFromActualParam(ConfigCursor current, SNode ap) {
    ConfigCursor context = current.ancestorWithEffectiveFM();
    SNode rhs = SLinkOperations.getTarget(ap, LINKS.rhs$dDaf);

    // case 1: the actual param references a using-parameter
    {
      final SNode upref = rhs;
      if (SNodeOperations.isInstanceOf(upref, CONCEPTS.UsingParamRefExpr$Pc)) {
        SNode featureWithRoot = context.feature();
        SNode param = SLinkOperations.getTarget(upref, LINKS.param$FQy9);
        {
          final SNode fmi = featureWithRoot;
          if (SNodeOperations.isInstanceOf(fmi, CONCEPTS.FeatureModelInclude$Iq)) {
            // the actual param points to a using-parameter of the surrounding config,
            // follow the chain by resolving recursively
            SNode nextAP = FeatureModelInclude__BehaviorDescriptor.getActualParam_id2Kcps_lX6rb.invoke(fmi, param);
            return resolveConfigFromActualParam(context, nextAP);
          }
        }
        SNode configAP = FeatureModelConfiguration__BehaviorDescriptor.getActualParam_id2Kcps_m3SsC.invoke(context.myRoot(), param);
        return ReferencedConfig.IProvidedConfig.make(check_2mrbao_a0e0e0f(configAP), SPropertyOperations.getString(param, PROPS.name$MnvL), ReferencedConfig.UsingParamProvision.ProvidedByWithParams);
      }
    }

    // case 2: the actual param references some included config, which might also be nested
    ConfigCursor subItem = AbstractFeatureConfiguration__BehaviorDescriptor.asCursor_id2Kcps_lTuIP.invoke(FeatureRefExprUtil.resolveConfig(context.myRoot(), rhs));
    if (subItem.isInlinedConfig()) {
      // currently we do not need information about how the inline config looks like
      return ReferencedConfig.IProvidedConfig.make(null, Expression__BehaviorDescriptor.renderReadable_id4Y0vh0cfqjE.invoke(rhs), ReferencedConfig.UsingParamProvision.ProvidedByInclude);
    } else {
      Optional<ReferencedConfig> ref = create(subItem);
      if (ref.isPresent()) {
        return ReferencedConfig.IProvidedConfig.make(check_2mrbao_a0a0b0a8a5(ref.get()), Expression__BehaviorDescriptor.renderReadable_id4Y0vh0cfqjE.invoke(rhs), ReferencedConfig.UsingParamProvision.ProvidedByInclude);
      }
    }
    return null;
  }

  private static SNode check_2mrbao_a0c0d(SNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return SLinkOperations.getTarget(checkedDotOperand, LINKS.config$SCsb);
    }
    return null;
  }
  private static SNode check_2mrbao_a0e0e0f(SNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return SLinkOperations.getTarget(checkedDotOperand, LINKS.config$SCsb);
    }
    return null;
  }
  private static SNode check_2mrbao_a0a0b0a8a5(ReferencedConfig checkedDotOperand) {
    if (null != checkedDotOperand) {
      return checkedDotOperand.config();
    }
    return null;
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink content$Wdfq = MetaAdapterFactory.getContainmentLink(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x302aa0c2ddab8940L, 0x5cf5c0d0479f4bc8L, "content");
    /*package*/ static final SReferenceLink config$VWuN = MetaAdapterFactory.getReferenceLink(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x5cf5c0d0479eed6aL, 0x5cf5c0d0479eed6bL, "config");
    /*package*/ static final SContainmentLink actualParams$nrMf = MetaAdapterFactory.getContainmentLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x375cadc475172168L, 0x7d6d839c28c600f0L, "actualParams");
    /*package*/ static final SReferenceLink param$KiX = MetaAdapterFactory.getReferenceLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7d6d839c28c579b6L, 0x7d6d839c28c58576L, "param");
    /*package*/ static final SContainmentLink rhs$dDaf = MetaAdapterFactory.getContainmentLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7d6d839c28c579b6L, 0x7d6d839c28c58be5L, "rhs");
    /*package*/ static final SReferenceLink param$FQy9 = MetaAdapterFactory.getReferenceLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7d6d839c2837f1d4L, 0x7d6d839c2837fbe8L, "param");
    /*package*/ static final SReferenceLink config$SCsb = MetaAdapterFactory.getReferenceLink(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x7d6d839c2865b139L, 0x7d6d839c2866b1ceL, "config");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept FeatureModelConfigurationRef$kq = MetaAdapterFactory.getConcept(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x5cf5c0d0479eed6aL, "org.iets3.variability.configuration.base.structure.FeatureModelConfigurationRef");
    /*package*/ static final SConcept FeatureModelInclude$Iq = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x375cadc475172168L, "org.iets3.variability.featuremodel.base.structure.FeatureModelInclude");
    /*package*/ static final SConcept UsingParamRefExpr$Pc = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7d6d839c2837f1d4L, "org.iets3.variability.featuremodel.base.structure.UsingParamRefExpr");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }
}
