package org.iets3.variability.configuration.base.behavior;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import org.jetbrains.mps.openapi.model.SNode;
import com.mbeddr.mpsutil.interpreter.rt.ContextImpl;
import com.mbeddr.mpsutil.interpreter.rt.IContext;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.iets3.core.expr.base.shared.runtime.INixValue;
import com.mbeddr.mpsutil.interpreter.rt.IInterpreter;
import com.mbeddr.mpsutil.interpreter.rt.InterpreterEvaluationHelper;
import org.iets3.core.expr.base.behavior.Expression__BehaviorDescriptor;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import com.mbeddr.mpsutil.interpreter.rt.NullCoverageAnalyzer;
import com.mbeddr.mpsutil.interpreter.rt.InterpreterBaseException;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

/**
 * Helper class which should be used for evaluating
 * different kinds of feature expressions.
 */
public class FeatureExprEvaluator {
  private static final Logger LOG = Logger.getLogger(FeatureExprEvaluator.class);

  /**
   * This flag can be set to true for debugging, even without access to the sources.
   */
  public static boolean debug = false;

  /**
   * <p>Evaluate a feature reference expression.</p>
   * 
   * <p>Note that this method uses a plain interpreter context with
   * empty environment. Thus, it can only be used if no context
   * information is needed to evaluate the reference expression.</p>
   * 
   * @param expr the feature reference expression
   * @return the resulting feature configuration node, or null on error
   */
  public static SNode evaluateConfigReference(SNode expr) {
    return evaluateConfigReference(expr, new ContextImpl());
  }

  /**
   * <p>Evaluate a feature reference expression.</p>
   * 
   * @param expr the feature reference expression
   * @param context an interpreter context containing the necessary feature configurations
   * @return the resulting feature configuration node, or null on error
   */
  public static SNode evaluateConfigReference(SNode expr, IContext context) {
    Object result = eval(expr, context);
    if (result != null && result instanceof SNode) {
      SNode n = as_6fe2wy_a0a0a1a6(result, SNode.class);
      if (SNodeOperations.isInstanceOf(n, CONCEPTS.AbstractFeatureConfiguration$3P)) {
        return SNodeOperations.cast(n, CONCEPTS.AbstractFeatureConfiguration$3P);
      } else {
        if (LOG.isErrorLevel()) {
          LOG.error("Invalid concept '" + SNodeOperations.getConcept(n).getName() + "' for returned node in feature expression");
        }
      }
    }
    return null;
  }

  /**
   * <p>Evaluate a feature expression (i.e., a presence condition).</p>
   * 
   * <p>In order to evaluate feature selection states and feature
   * attribute values, a feature configuration has to be provided
   * via the context's environment. The environment has to contain
   * a mapping from a feature model to a corresponding configuration.</p>
   * 
   * @deprecated this method cannot distinguish between evaluation results "undefined" and "false", use evaluateConditionTernary instead
   * @param expr a boolean expression which might contain feature references
   * @param context the evaluation context
   * @return true, false, or null on error
   */
  @Deprecated
  public static Boolean evaluateCondition(SNode expr, IContext context) {
    Object result = eval(expr, context);

    // check result of evaluation
    if (result != null) {
      if (result instanceof Boolean) {
        // this is a boolean expression which might contain one or more features
        return as_6fe2wy_a0b0a0d0i(result, Boolean.class);
      } else if (result instanceof SNode) {
        // this is for expressions which are actually a single feature reference
        SNode n = as_6fe2wy_a0a1a0a0d0i(result, SNode.class);
        if (SNodeOperations.isInstanceOf(n, CONCEPTS.AbstractFeatureConfiguration$3P)) {
          // return feature's selection state
          return (boolean) AbstractFeatureConfiguration__BehaviorDescriptor.isSelected_id79zES$XKwaU.invoke(SNodeOperations.cast(n, CONCEPTS.AbstractFeatureConfiguration$3P));
        } else {
          if (LOG.isErrorLevel()) {
            LOG.error("Invalid concept '" + SNodeOperations.getConcept(n).getName() + "' for returned node in feature expression");
          }
        }
      } else {
        if (LOG.isErrorLevel()) {
          LOG.error("Invalid return type of feature expression");
        }
      }
    }

    //  catch-all return
    return null;
  }

  /**
   * <p>Evaluate a feature expression (i.e., a presence condition).</p>
   * 
   * <p>This method will handle expressions referencing features which are _untouched_ in the
   * supplied configuration. If the expression's result depends on one of those feature, the
   * result cannot be decided to either true or false. The method will return null in that case.</p>
   * 
   * <p>In order to evaluate feature selection states and feature
   * attribute values, a feature configuration has to be provided
   * via the context's environment. The environment has to contain
   * a mapping from a feature model to a corresponding configuration.</p>
   * 
   * @param expr a boolean expression which might contain feature references
   * @param context the evaluation context
   * @throws RuntimeException on various unexpected errors during expression evaluation
   * @return true, false, and null for "undefined"
   */
  public static Boolean evaluateConditionTernary(SNode expr, IContext context) throws RuntimeException {
    Object result = eval(expr, context);

    // check result of evaluation
    if (result != null) {
      if (result instanceof Boolean) {
        // this is a boolean expression which might contain one or more features
        return as_6fe2wy_a0b0a0d0k(result, Boolean.class);
      } else if (result instanceof SNode) {
        // this is for expressions which are actually a single feature reference
        SNode n = as_6fe2wy_a0a1a0a0d0k(result, SNode.class);
        {
          final SNode afc = (SNode) result;
          if (SNodeOperations.isInstanceOf(afc, CONCEPTS.AbstractFeatureConfiguration$3P)) {
            // return feature's ternary selection state
            return AbstractFeatureConfiguration__BehaviorDescriptor.getTriState_id1P_ZNIGdBN2.invoke(afc);
          }
        }
        throw new RuntimeException("Invalid concept '" + SNodeOperations.getConcept(n).getName() + "' for returned node in feature expression");
      } else if (result instanceof INixValue) {
        // expression depends on features which are still untouched
        return null;
      } else {
        if (LOG.isErrorLevel()) {
          LOG.error("Invalid return type of feature expression");
        }
      }
      throw new RuntimeException("Invalid return type of feature expression (was: " + result.getClass().getCanonicalName() + ")");
    }

    throw new RuntimeException("Feature expression could not be evaluated (returned null):" + SNodeOperations.present(expr));
  }

  /**
   * <p>Helper function which uses the interpreter to evaluate an expression.</p>
   * 
   * @param expr the expression to be evaluated
   * @param context a context for the interpreter
   * @return the result of the evaluation (or null on error)
   */
  private static Object eval(SNode expr, IContext context) {
    if (context == null) {
      return null;
    }
    // Expressions like Product. without a target causes the Interpreter to crash. 
    // It is a workaround as it is not possible to catch the Exception of the interpreter?!
    if (FeatureExprEvaluator.hasTargetWithoutTarget(expr)) {
      return null;
    }
    IInterpreter interpreter = InterpreterEvaluationHelper.getInterpreter("arithmetic");
    context.setRootInterpreter(interpreter);
    try {
      if (LOG.isDebugLevel()) {
        LOG.debug("EVALUATING" + Expression__BehaviorDescriptor.renderReadable_id4Y0vh0cfqjE.invoke(expr) + " WITH ENV " + context.getEnvironment());
      }
      // we have to push a new environment because interpreting DotExpressions
      // will add entries to the original environment
      Map<SNode, Object> newEnv = MapSequence.fromMap(new HashMap<SNode, Object>());
      context.pushEnvironment(expr, newEnv);

      // do actual evaluation
      Object result = interpreter.evaluate(expr, context, new NullCoverageAnalyzer(), null, true);
      if (LOG.isDebugLevel()) {
        LOG.debug("    EVAL RESULT " + Expression__BehaviorDescriptor.renderReadable_id4Y0vh0cfqjE.invoke(expr) + " TO " + result + " WITH ENV " + context.getEnvironment().getParentEnvironment());
      }
      return result;
    } catch (InterpreterBaseException e) {
      if (LOG.isErrorLevel()) {
        LOG.error("Interpreter exception while evaluating feature expression", e);
      }
      return null;
    } finally {
      // remove changed top environment
      context.popEnvironment(expr);
    }
  }

  private static boolean hasTargetWithoutTarget(SNode expr) {
    return ListSequence.fromList(SNodeOperations.getNodeDescendants(expr, CONCEPTS.IDotTarget$jS, true, new SAbstractConcept[]{})).any((it) -> SNodeOperations.getConcept(it).isAbstract());
  }
  private static <T> T as_6fe2wy_a0a0a1a6(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_6fe2wy_a0b0a0d0i(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_6fe2wy_a0a1a0a0d0i(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_6fe2wy_a0b0a0d0k(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_6fe2wy_a0a1a0a0d0k(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept AbstractFeatureConfiguration$3P = MetaAdapterFactory.getConcept(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x302aa0c2ddab8940L, "org.iets3.variability.configuration.base.structure.AbstractFeatureConfiguration");
    /*package*/ static final SInterfaceConcept IDotTarget$jS = MetaAdapterFactory.getInterfaceConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7cef88020a0f424aL, "org.iets3.core.expr.base.structure.IDotTarget");
  }
}
