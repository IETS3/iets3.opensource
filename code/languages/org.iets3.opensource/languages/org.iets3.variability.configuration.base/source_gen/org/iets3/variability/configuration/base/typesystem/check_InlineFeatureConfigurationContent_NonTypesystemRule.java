package org.iets3.variability.configuration.base.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.AbstractNonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.lang.typesystem.runtime.IsApplicableStatus;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.iets3.variability.configuration.base.behavior.FeatureModelConfiguration__BehaviorDescriptor;
import java.util.List;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.iets3.variability.featuremodel.base.behavior.AbstractFeature__BehaviorDescriptor;
import org.iets3.variability.featuremodel.base.behavior.FeatureTreeNode__BehaviorDescriptor;
import java.util.Objects;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.errors.IErrorReporter;
import jetbrains.mps.errors.BaseQuickFixProvider;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;

public class check_InlineFeatureConfigurationContent_NonTypesystemRule extends AbstractNonTypesystemRule_Runtime implements NonTypesystemRule_Runtime {
  public check_InlineFeatureConfigurationContent_NonTypesystemRule() {
  }
  public void applyRule(final SNode content, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {
    // if the config anyway shows the request "There were changes in the feature model. ...", we do not execute all the following checks
    SNode config = SNodeOperations.getNodeAncestor(content, CONCEPTS.FeatureModelConfiguration$nE, false, false);
    if ((config != null) && (boolean) FeatureModelConfiguration__BehaviorDescriptor.shouldAdaptToFM_id2XyYtG$KzQT.invoke(config)) {
      return;
    }

    List<SNode> subConfigs = SLinkOperations.getChildren(content, LINKS.subfeatureConfigurations$l9wi);
    if (ListSequence.fromList(subConfigs).isNotEmpty()) {
      // check inconsistency: non-unique references to the same targeFeature (e.g., by wrong manual merge)
      final SNode afc = SNodeOperations.as(SNodeOperations.getParent(content), CONCEPTS.AbstractFeatureConfiguration$3P);
      if ((afc != null)) {
        final Iterable<SNode> subFeatures = AbstractFeature__BehaviorDescriptor.subFeatures_id6GZHy357BW_.invoke(FeatureTreeNode__BehaviorDescriptor.effectiveFeature_id6GZHy352t67.invoke(SLinkOperations.getTarget(afc, LINKS.targetFeature$16lA)));
        if (SNodeOperations.isInstanceOf(afc, CONCEPTS.FeatureWithCardinalityConfiguration$iu)) {
          // duplicates are okay here, but we should check if the target features are correct
          for (SNode sc : ListSequence.fromList(subConfigs).where((it) -> !(Objects.equals(SLinkOperations.getTarget(it, LINKS.targetFeature$16lA), SLinkOperations.getTarget(afc, LINKS.targetFeature$16lA))))) {
            {
              final MessageTarget errorTarget = new NodeMessageTarget();
              IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(sc, "Inconsistent reference to cardinality feature, use quickfix to repair", "r:791971f5-b094-4342-a75c-0ce6c1b43e9d(org.iets3.variability.configuration.base.typesystem)", "6945424678034363598", null, errorTarget);
              {
                BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider("org.iets3.variability.configuration.base.typesystem.fix_InvalidReferenceToFeature_QuickFix", "6945424678034366262", false);
                intentionProvider.putArgument("fc", sc);
                intentionProvider.putArgument("problem", "inconsistent reference");
                _reporter_2309309498.addIntentionProvider(intentionProvider);
              }
            }
          }

          // for more checks on the number of cardinality features see check_FeatureWithCardinalityConfiguration
        } else {
          // feature without cardinality, check for inconsistency
          for (final SNode f : Sequence.fromIterable(subFeatures)) {
            Iterable<SNode> matches = ListSequence.fromList(subConfigs).where((it) -> Objects.equals(SLinkOperations.getTarget(it, LINKS.targetFeature$16lA), f));
            if (Sequence.fromIterable(matches).count() > 1) {
              Sequence.fromIterable(matches).visitAll((it) -> {
                {
                  final MessageTarget errorTarget = new NodeMessageTarget();
                  IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(it, "Non-unique reference to feature, use quickfix to repair", "r:791971f5-b094-4342-a75c-0ce6c1b43e9d(org.iets3.variability.configuration.base.typesystem)", "9159423170674871986", null, errorTarget);
                  {
                    BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider("org.iets3.variability.configuration.base.typesystem.fix_InvalidReferenceToFeature_QuickFix", "9159423170674990641", false);
                    intentionProvider.putArgument("fc", it);
                    intentionProvider.putArgument("problem", "non-unique reference");
                    _reporter_2309309498.addIntentionProvider(intentionProvider);
                  }
                }
              });
            }
          }
          for (SNode sc : ListSequence.fromList(subConfigs).where((it) -> !(Sequence.fromIterable(subFeatures).contains(SLinkOperations.getTarget(it, LINKS.targetFeature$16lA))))) {
            {
              final MessageTarget errorTarget = new NodeMessageTarget();
              IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(sc, "Inconsistent reference to feature, use quickfix to repair", "r:791971f5-b094-4342-a75c-0ce6c1b43e9d(org.iets3.variability.configuration.base.typesystem)", "6945424678034381175", null, errorTarget);
              {
                BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider("org.iets3.variability.configuration.base.typesystem.fix_InvalidReferenceToFeature_QuickFix", "6945424678034381178", false);
                intentionProvider.putArgument("fc", sc);
                intentionProvider.putArgument("problem", "inconsistent reference");
                _reporter_2309309498.addIntentionProvider(intentionProvider);
              }
            }
          }

        }
      }
    }
  }
  public SAbstractConcept getApplicableConcept() {
    return CONCEPTS.InlineFeatureConfigurationContent$P5;
  }
  public IsApplicableStatus isApplicableAndPattern(SNode argument) {
    return new IsApplicableStatus(argument.getConcept().isSubConceptOf(getApplicableConcept()), null);
  }
  public boolean overrides() {
    return false;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept FeatureModelConfiguration$nE = MetaAdapterFactory.getConcept(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x5cf5c0d0479ec915L, "org.iets3.variability.configuration.base.structure.FeatureModelConfiguration");
    /*package*/ static final SConcept AbstractFeatureConfiguration$3P = MetaAdapterFactory.getConcept(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x302aa0c2ddab8940L, "org.iets3.variability.configuration.base.structure.AbstractFeatureConfiguration");
    /*package*/ static final SConcept FeatureWithCardinalityConfiguration$iu = MetaAdapterFactory.getConcept(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x55c09a0155d9c97cL, "org.iets3.variability.configuration.base.structure.FeatureWithCardinalityConfiguration");
    /*package*/ static final SConcept InlineFeatureConfigurationContent$P5 = MetaAdapterFactory.getConcept(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x5cf5c0d0479f4bfcL, "org.iets3.variability.configuration.base.structure.InlineFeatureConfigurationContent");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink subfeatureConfigurations$l9wi = MetaAdapterFactory.getContainmentLink(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x5cf5c0d0479f4bfcL, 0x5cf5c0d0479ec91aL, "subfeatureConfigurations");
    /*package*/ static final SReferenceLink targetFeature$16lA = MetaAdapterFactory.getReferenceLink(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x302aa0c2ddab8940L, 0x5cf5c0d0479ec91eL, "targetFeature");
  }
}
