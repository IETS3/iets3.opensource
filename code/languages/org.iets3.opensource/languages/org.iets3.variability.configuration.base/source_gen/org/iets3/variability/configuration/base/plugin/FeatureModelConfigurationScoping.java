package org.iets3.variability.configuration.base.plugin;

/*Generated by MPS */

import jetbrains.mps.scope.Scope;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Objects;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.scope.FilteringScope;
import com.mbeddr.core.base.behavior.IVisibleElementProvider__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Optional;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.iets3.variability.featuremodel.base.behavior.FeatureTreeNode__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SProperty;

public class FeatureModelConfigurationScoping {

  public static Scope featureModelConfigScope(SNode context, final SNode requiredRoot) {
    return featureModelConfigScope(context, (fmc) -> !(Objects.equals(SLinkOperations.getTarget(fmc, LINKS.targetFeature$16lA), requiredRoot)));
  }

  public static Scope featureModelConfigScope(SNode context, final _FunctionTypes._return_P1_E0<? extends Boolean, ? super SNode> fmcIsExcluded) {
    return new FilteringScope(IVisibleElementProvider__BehaviorDescriptor.visibleContentsOfType_id79$zShlSHxZ.invoke(SNodeOperations.getNodeAncestor(context, CONCEPTS.IVisibleElementProvider$$O, true, false), CONCEPTS.FeatureModelConfiguration$nE)) {
      @Override
      public boolean isExcluded(SNode node) {
        return fmcIsExcluded.invoke(SNodeOperations.cast(node, CONCEPTS.FeatureModelConfiguration$nE));
      }
    };
  }

  public static Scope referenceScopeFor(SNode context, final SNode fc, final boolean includeExistingRef) {
    assert SNodeOperations.isInstanceOf(SLinkOperations.getTarget(fc, LINKS.targetFeature$16lA), CONCEPTS.FeatureModelInclude$Iq);
    // Find out if configuration inheritance is involved
    Optional<SNode> extendedConfigWithSameTargetFeatureMaybe = FeatureModelIncludeUtil.findExtendedConfigWithSameTargetFeature(fc);

    if (extendedConfigWithSameTargetFeatureMaybe.isPresent()) {
      final SNode mustExtend = extendedConfigWithSameTargetFeatureMaybe.get();
      return featureModelConfigScope(context, (final SNode fc2) -> !(isReplacementFor(fc2, fc, includeExistingRef) && extendable(fc2, mustExtend)));
    }

    return featureModelConfigScope(context, (final SNode fc2) -> !(isReplacementFor(fc2, fc, includeExistingRef)));
  }

  public static Scope usingScopeFor(SNode fmc, final SNode param, final SNode contextNode) {
    return usingScopeForHlp(fmc, param, contextNode).orElseGet(() -> unfilteredScope(param, contextNode));
  }

  public static boolean canHaveUsingSection(SNode fmc, SNode usedConfig) {
    return usingScopeForHlp(fmc, SLinkOperations.getTarget(usedConfig, LINKS.param$pwLK), usedConfig).map((scope) -> Sequence.fromIterable(scope.getAvailableElements(null)).isNotEmpty()).orElse(false);
  }

  private static Scope unfilteredScope(final SNode param, SNode contextNode) {
    return featureModelConfigScope(contextNode, (fmcParam) -> !(fitsToFeatureModel(fmcParam, SLinkOperations.getTarget(SLinkOperations.getTarget(param, LINKS.fm$Zpvv), LINKS.root$XEj1))));
  }

  private static boolean isReplacementFor(final SNode candidateFMC, final SNode fc, boolean includeExistingRef) {
    return fitsToFeatureModel(candidateFMC, FeatureTreeNode__BehaviorDescriptor.effectiveFeature_id6GZHy352t67.invoke(SLinkOperations.getTarget(fc, LINKS.targetFeature$16lA))) && (includeExistingRef || isAlreadyReferenced(candidateFMC, fc));
  }

  private static Optional<Scope> usingScopeForHlp(SNode fmc, SNode param, final SNode contextNode) {
    final SNode targetFeature = SLinkOperations.getTarget(SLinkOperations.getTarget(param, LINKS.fm$Zpvv), LINKS.root$XEj1);

    return findUsingExtension(param, fmc).map((final SNode mustExtendUsing) -> featureModelConfigScope(contextNode, (SNode usingCandidate) -> excludeFilterForUsing(usingCandidate, mustExtendUsing, targetFeature)));
  }

  private static Optional<SNode> findUsingExtension(SNode param, SNode fmc) {
    final SNode fmReferedByUsing = SLinkOperations.getTarget(param, LINKS.fm$Zpvv);
    final String usingName = SPropertyOperations.getString(param, PROPS.name$MnvL);
    if (usingName == null || (fmReferedByUsing == null)) {
      return Optional.empty();
    }
    // Holds a configuration which is extended
    Optional<SNode> extendedFMCMaybe = Optional.<SNode>of(fmc);
    // Holds already defined 'using' of 'extendedFMCMaybe'
    Optional<SNode> mustExtendUsingMaybe = Optional.empty();

    while (extendedFMCMaybe.isPresent() && mustExtendUsingMaybe.isEmpty()) {
      extendedFMCMaybe = FeatureModelIncludeUtil.findExtendedConfigWithSameTargetFeature(extendedFMCMaybe.get());
      mustExtendUsingMaybe = extendedFMCMaybe.flatMap((currentExtendedFMC) -> findUsingFor(currentExtendedFMC, fmReferedByUsing, usingName));
    }
    return mustExtendUsingMaybe;
  }

  private static Optional<SNode> findUsingFor(SNode currentFMC, final SNode fmReferedByUsing, final String usingName) {
    {
      final SNode fmcExtended = currentFMC;
      if (SNodeOperations.isInstanceOf(fmcExtended, CONCEPTS.FeatureModelConfiguration$nE)) {
        return Optional.ofNullable(ListSequence.fromList(SLinkOperations.getChildren(fmcExtended, LINKS.usedConfigs$WedD)).where((it) -> (Objects.equals(SLinkOperations.getTarget(SLinkOperations.getTarget(it, LINKS.param$pwLK), LINKS.fm$Zpvv), fmReferedByUsing) && Objects.equals(usingName, SPropertyOperations.getString(SLinkOperations.getTarget(it, LINKS.param$pwLK), PROPS.name$MnvL)))).select((it) -> SLinkOperations.getTarget(it, LINKS.config$SCsb)).first());
      }
    }
    return null;
  }

  private static boolean excludeFilterForUsing(SNode usingCandidate, SNode meu, SNode targetFeature) {
    return !(fitsToFeatureModel(usingCandidate, targetFeature)) || isCurrentUsing(usingCandidate, meu) || (!(extendsFeatureModelConfiguration(usingCandidate, meu)));
  }

  private static boolean isCurrentUsing(SNode usingCandidate, SNode usingCurrent) {
    return Objects.equals(usingCandidate, usingCurrent);
  }

  private static boolean isAlreadyReferenced(SNode candidateFmc, SNode referencing) {
    {
      final SNode fmcr = SLinkOperations.getTarget(referencing, LINKS.content$Wdfq);
      if (SNodeOperations.isInstanceOf(fmcr, CONCEPTS.FeatureModelConfigurationRef$kq)) {
        if (SLinkOperations.getTarget(fmcr, LINKS.config$VWuN) == candidateFmc) {
          return false;
        }
      }
    }
    return true;
  }

  private static boolean extendable(SNode candidate, SNode mustExtend) {
    // Nothing specified, can always be extended 
    {
      final SNode fmcb = SLinkOperations.getTarget(mustExtend, LINKS.content$Wdfq);
      if (SNodeOperations.isInstanceOf(fmcb, CONCEPTS.FeatureModelConfigurationBase$y8)) {
        return true;
      }
    }
    // FMC specified, check if it i extendable
    {
      final SNode fmcr = SLinkOperations.getTarget(mustExtend, LINKS.content$Wdfq);
      if (SNodeOperations.isInstanceOf(fmcr, CONCEPTS.FeatureModelConfigurationRef$kq)) {
        return extendsFeatureModelConfiguration(candidate, SLinkOperations.getTarget(fmcr, LINKS.config$VWuN));
      }
    }
    // Anything else is fixed
    return false;
  }

  private static boolean fitsToFeatureModel(SNode candidateFmc, SNode featureOfInclude) {
    return Objects.equals(SLinkOperations.getTarget(candidateFmc, LINKS.targetFeature$16lA), featureOfInclude);
  }

  private static boolean extendsFeatureModelConfiguration(SNode candidate, SNode mustExtendFMC) {
    // Traverse 'extendedConfig' upwards until match is found
    SNode currentFMC = candidate;
    while (currentFMC != null && currentFMC != mustExtendFMC) {
      currentFMC = check_xhtnr_a0a0c0fb(check_xhtnr_a0a0a2a13(currentFMC));
    }
    // if not found, not compatible with 'mustExtendFMC'
    return currentFMC == mustExtendFMC;
  }
  private static SNode check_xhtnr_a0a0c0fb(SNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return SLinkOperations.getTarget(checkedDotOperand, LINKS.config$ID3f);
    }
    return null;
  }
  private static SNode check_xhtnr_a0a0a2a13(SNode checkedDotOperand) {
    if (null != checkedDotOperand) {
      return SLinkOperations.getTarget(checkedDotOperand, LINKS.extendedFMC$tFbw);
    }
    return null;
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink targetFeature$16lA = MetaAdapterFactory.getReferenceLink(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x302aa0c2ddab8940L, 0x5cf5c0d0479ec91eL, "targetFeature");
    /*package*/ static final SReferenceLink param$pwLK = MetaAdapterFactory.getReferenceLink(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x7d6d839c2865b139L, 0x7d6d839c2866af76L, "param");
    /*package*/ static final SReferenceLink fm$Zpvv = MetaAdapterFactory.getReferenceLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x6b367b20f4b08715L, 0x6b367b20f4b33988L, "fm");
    /*package*/ static final SContainmentLink root$XEj1 = MetaAdapterFactory.getContainmentLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x375cadc47516a211L, 0x375cadc47516a30cL, "root");
    /*package*/ static final SContainmentLink usedConfigs$WedD = MetaAdapterFactory.getContainmentLink(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x5cf5c0d0479ec915L, 0x7d6d839c2865b7a7L, "usedConfigs");
    /*package*/ static final SReferenceLink config$SCsb = MetaAdapterFactory.getReferenceLink(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x7d6d839c2865b139L, 0x7d6d839c2866b1ceL, "config");
    /*package*/ static final SContainmentLink content$Wdfq = MetaAdapterFactory.getContainmentLink(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x302aa0c2ddab8940L, 0x5cf5c0d0479f4bc8L, "content");
    /*package*/ static final SReferenceLink config$VWuN = MetaAdapterFactory.getReferenceLink(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x5cf5c0d0479eed6aL, 0x5cf5c0d0479eed6bL, "config");
    /*package*/ static final SReferenceLink config$ID3f = MetaAdapterFactory.getReferenceLink(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x4617323a864bd036L, 0x4617323a864bd049L, "config");
    /*package*/ static final SContainmentLink extendedFMC$tFbw = MetaAdapterFactory.getContainmentLink(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x5cf5c0d0479ec915L, 0x4617323a864bd075L, "extendedFMC");
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept IVisibleElementProvider$$O = MetaAdapterFactory.getInterfaceConcept(0xd4280a54f6df4383L, 0xaa41d1b2bffa7eb1L, 0x6315bcc6eff580a3L, "com.mbeddr.core.base.structure.IVisibleElementProvider");
    /*package*/ static final SConcept FeatureModelConfiguration$nE = MetaAdapterFactory.getConcept(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x5cf5c0d0479ec915L, "org.iets3.variability.configuration.base.structure.FeatureModelConfiguration");
    /*package*/ static final SConcept FeatureModelInclude$Iq = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x375cadc475172168L, "org.iets3.variability.featuremodel.base.structure.FeatureModelInclude");
    /*package*/ static final SConcept FeatureModelConfigurationRef$kq = MetaAdapterFactory.getConcept(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x5cf5c0d0479eed6aL, "org.iets3.variability.configuration.base.structure.FeatureModelConfigurationRef");
    /*package*/ static final SConcept FeatureModelConfigurationBase$y8 = MetaAdapterFactory.getConcept(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x2e34d227ff954d8bL, "org.iets3.variability.configuration.base.structure.FeatureModelConfigurationBase");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }
}
