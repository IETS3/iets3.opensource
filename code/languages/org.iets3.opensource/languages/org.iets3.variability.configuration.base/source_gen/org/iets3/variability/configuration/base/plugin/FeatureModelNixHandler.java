package org.iets3.variability.configuration.base.plugin;

/*Generated by MPS */

import org.iets3.core.expr.base.plugin.DefaultNixHandler;
import java.util.Set;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import org.iets3.core.expr.base.runtime.runtime.NixSupport;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.iets3.variability.configuration.base.behavior.AbstractFeatureConfiguration__BehaviorDescriptor;
import org.iets3.core.expr.base.runtime.runtime.DefaultNix;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class FeatureModelNixHandler extends DefaultNixHandler {

  private static Set<SNode> visitedBefore = SetSequence.fromSet(new HashSet<SNode>());

  @Override
  public boolean allowNix() {
    return true;
  }

  @Override
  public int getPriorityLevel() {
    return 2000;
  }

  @Override
  public Object process(NixSupport s) {
    SNode op = s.node();
    if (SNodeOperations.isInstanceOf(op, CONCEPTS.LogicalNotExpression$QD)) {
      Object f0 = handleFeature(s, 0);
      if (f0 != null) {
        return f0;
      }
    } else if (SNodeOperations.isInstanceOf(op, CONCEPTS.LogicalOrExpression$J2) || SNodeOperations.isInstanceOf(op, CONCEPTS.LogicalAndExpression$m8)) {
      // the interpreter for logical and/or contains a special logic for short-circuit evaluation
      // we have to circumvent this by using the visitedBefore state in order to achieve the proper ternary logic
      if (!(SetSequence.fromSet(visitedBefore).contains(op))) {
        // step 1: check left operand (right operand will be a constant boolean value)
        Object f0 = handleFeature(s, 0);
        if (f0 != null) {
          // the left operand is a feature with value "untouched"
          SetSequence.fromSet(visitedBefore).addElement(op);
          return f0;
        }
        Object f1 = handleFeature(s, 1);
        if (f1 != null) {
          return f1;
        }
      } else {
        // step 2: left operand is FeatureNix, check right operand
        SetSequence.fromSet(visitedBefore).removeElement(op);
        Object rhs = s.get(1);

        SNode c1 = getFeatureConfig(rhs);
        if ((c1 == null)) {
          // right operand is a boolean value or nix
          if (rhs instanceof Boolean) {
            return evalUnderLHSisNix(s, (Boolean) rhs, op);
          }
          // if right operand is a nix, we just pass it on
        } else {
          // right operand is a feature reference
          return evalUnderLHSisNix(s, AbstractFeatureConfiguration__BehaviorDescriptor.getTriState_id1P_ZNIGdBN2.invoke(c1), op);
        }
      }
    } else if (SNodeOperations.isInstanceOf(op, CONCEPTS.LogicalImpliesExpression$87)) {
      // ternary logic for "implies" with untouched/nix (Kleene K3)
      // this completely overrides the implementation in the original interpreter!
      Boolean l = eval(s, 0);
      if (l != null && !(l)) {
        return s.overrideResult(true);
      }
      Boolean r = eval(s, 1);
      if (r != null && r) {
        return s.overrideResult(true);
      }
      if (l == null || r == null) {
        return s.overrideResult(new DefaultNix());
      }
      return s.overrideResult(false);
    } else if (SNodeOperations.isInstanceOf(op, CONCEPTS.LogicalIffExpression$mP) || SNodeOperations.isInstanceOf(op, CONCEPTS.EqualsExpression$k4) || SNodeOperations.isInstanceOf(op, CONCEPTS.NotEqualsExpression$kz)) {

      Object f0 = handleFeature(s, 0);
      if (f0 != null) {
        return f0;
      }
      Object f1 = handleFeature(s, 1);
      if (f1 != null) {
        return f1;
      }
    }

    // delegate to super class: set overall result to nix, if any operand is nix 
    return super.process(s);
  }


  /**
   * evaluate boolean rhs-value if lhs-value is Nix
   */
  private Object evalUnderLHSisNix(NixSupport s, Boolean v1, SNode op) {
    if (SNodeOperations.isInstanceOf(op, CONCEPTS.LogicalOrExpression$J2)) {
      return s.overrideResult((v1 == null || !(v1) ? new FeatureNix() : true));
    } else {
      return s.overrideResult((v1 == null || v1 ? new FeatureNix() : false));
    }
  }

  private Boolean eval(NixSupport s, int i) {
    Object obj = s.get(i);
    if (obj instanceof Boolean) {
      return (Boolean) obj;
    } else {
      SNode afc = getFeatureConfig(obj);
      if ((afc != null)) {
        return AbstractFeatureConfiguration__BehaviorDescriptor.getTriState_id1P_ZNIGdBN2.invoke(afc);
      } else {
        return null;
      }
    }
  }

  private Object handleFeature(NixSupport s, int i) {
    SNode afc = getFeatureConfig(s.get(i));
    if ((afc != null)) {
      Boolean val = AbstractFeatureConfiguration__BehaviorDescriptor.getTriState_id1P_ZNIGdBN2.invoke(afc);
      if (val == null) {
        // feature is untouched, result of whole operation is undefined
        return s.overrideResult(new FeatureNix());
      } else {
        // replace feature reference by actual boolean value from configuration
        s.setReplacement(i, val);
      }
    }
    return null;
  }

  private SNode getFeatureConfig(Object val) {
    if (val instanceof SNode) {
      {
        final SNode afc = (SNode) val;
        if (SNodeOperations.isInstanceOf(afc, CONCEPTS.AbstractFeatureConfiguration$3P)) {
          return afc;
        }
      }
    }
    return null;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept LogicalNotExpression$QD = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cd0f6aL, "org.iets3.core.expr.base.structure.LogicalNotExpression");
    /*package*/ static final SConcept LogicalOrExpression$J2 = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cbdcbbL, "org.iets3.core.expr.base.structure.LogicalOrExpression");
    /*package*/ static final SConcept LogicalAndExpression$m8 = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cbdd39L, "org.iets3.core.expr.base.structure.LogicalAndExpression");
    /*package*/ static final SConcept LogicalImpliesExpression$87 = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x15035178cd135185L, "org.iets3.core.expr.base.structure.LogicalImpliesExpression");
    /*package*/ static final SConcept NotEqualsExpression$kz = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cc6dcaL, "org.iets3.core.expr.base.structure.NotEqualsExpression");
    /*package*/ static final SConcept LogicalIffExpression$mP = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x753e449f1c7cd7bcL, "org.iets3.core.expr.base.structure.LogicalIffExpression");
    /*package*/ static final SConcept EqualsExpression$k4 = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cc6dc9L, "org.iets3.core.expr.base.structure.EqualsExpression");
    /*package*/ static final SConcept AbstractFeatureConfiguration$3P = MetaAdapterFactory.getConcept(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x302aa0c2ddab8940L, "org.iets3.variability.configuration.base.structure.AbstractFeatureConfiguration");
  }
}
