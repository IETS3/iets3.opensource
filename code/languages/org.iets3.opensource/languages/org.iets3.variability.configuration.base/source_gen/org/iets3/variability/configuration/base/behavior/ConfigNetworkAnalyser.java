package org.iets3.variability.configuration.base.behavior;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import com.mbeddr.mpsutil.common.util.Traversal;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.ide.httpsupport.runtime.base.HttpSupportUtil;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class ConfigNetworkAnalyser {

  private static final String REFERENCE_RELATION_COLOR = "black";
  private static final String USING_RELATION_COLOR = "green";

  public static String computeNetworkGraph(SNode start) {
    final ConfigRelationFinder relationFinder = new ConfigRelationFinder(SNodeOperations.getModel(start));
    final StringBuffer sb = new StringBuffer();
    final Set<SNode> generated = SetSequence.fromSet(new HashSet<SNode>());

    sb.append("digraph G {\n");
    genNode(start, true, sb);

    // generate upper part (incoming references)
    Traversal.doBreadthFirst(start, (final SNode current) -> {
      if (!(SetSequence.fromSet(generated).contains(current))) {
        genNode(current, false, sb);
      }
      Sequence.fromIterable(relationFinder.referencing(current)).visitAll((it) -> genLink(it, current, REFERENCE_RELATION_COLOR, sb));
      Sequence.fromIterable(relationFinder.using(current)).visitAll((it) -> genLink(it, current, USING_RELATION_COLOR, sb));
      return relationFinder.allReferrers(current);
    });

    // generate lower part (outgoing references)
    Traversal.doBreadthFirst(start, (final SNode current) -> {
      if (!(SetSequence.fromSet(generated).contains(current))) {
        genNode(current, false, sb);
      }
      Sequence.fromIterable(ConfigRelationFinder.referencedBy(current)).visitAll((it) -> genLink(current, it, REFERENCE_RELATION_COLOR, sb));
      Sequence.fromIterable(ConfigRelationFinder.usedBy(current)).visitAll((it) -> genLink(current, it, USING_RELATION_COLOR, sb));
      return ConfigRelationFinder.referencedOrUsedBy(current);
    });

    sb.append("}\n");
    return sb.toString();
  }

  private static void genNode(SNode fmc, boolean isCenter, StringBuffer sb) {
    String label = SPropertyOperations.getString(fmc, PROPS.name$MnvL) + " : " + SPropertyOperations.getString(FeatureModelConfiguration__BehaviorDescriptor.getFeatureModel_id7PHwTKCuj99.invoke(fmc), PROPS.name$MnvL);
    String url = HttpSupportUtil.getURL(fmc);
    String emph = (isCenter ? ", style=filled, fillcolor=\"lightyellow\"" : "");
    sb.append("  " + SPropertyOperations.getString(fmc, PROPS.name$MnvL) + " [label=\"" + label + "\", href=\"" + url + "\"" + emph + "];\n");
  }

  private static void genLink(SNode from, SNode to, String col, StringBuffer sb) {
    sb.append("  " + SPropertyOperations.getString(from, PROPS.name$MnvL) + " -> " + SPropertyOperations.getString(to, PROPS.name$MnvL) + " [color=\"" + col + "\"];\n");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }
}
