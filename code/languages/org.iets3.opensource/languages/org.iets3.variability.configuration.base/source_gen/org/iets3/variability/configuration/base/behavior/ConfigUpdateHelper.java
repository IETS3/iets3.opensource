package org.iets3.variability.configuration.base.behavior;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.IAttributeDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SEnumOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.iets3.analysis.base.behavior.ISolvable__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.iets3.core.base.behavior.IResult;
import java.util.concurrent.CompletableFuture;
import java.util.List;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SContainmentLink;

/**
 * This class uses the ISolvable generic interface, but not a specific solver implementation.
 * Thus, it should stay in org.iets3.variability.configuration.base.
 */
public class ConfigUpdateHelper {

  /**
   * Update configuration according to latest changes of its feature model.
   * 
   * @param config the (probably outdated) configuration
   */
  public static void propagateFeatureModelChangesToConfigAsync(final SNode config) {
    withSolverSuspended(config, config, () -> new Traversals().adaptConfigToFeatureChanges(config));
    if (!((new IAttributeDescriptor.NodeAttribute(CONCEPTS.SolveControl$Vn).get(config) != null) && SEnumOperations.isMember(SPropertyOperations.getEnum(new IAttributeDescriptor.NodeAttribute(CONCEPTS.SolveControl$Vn).get(config), PROPS.mode$kQof), 0x3a7ea77800f377a4L))) {
      ISolvable__BehaviorDescriptor.runManuallyAsync_id7QODtLvTFnz.invoke(config);
    }
  }

  public static void propagateFeatureModelChangesToConfig(final SNode config) {
    withSolverSuspended(config, config, () -> new Traversals().adaptConfigToFeatureChanges(config));
  }

  public static void withSolverSuspended(SNode config, SNode expected, Runnable runnable) {
    SPropertyOperations.assign(config, PROPS.complete$4SB6, false);
    SPropertyOperations.assign(expected, PROPS.complete$4SB6, false);

    try {
      runnable.run();
    } finally {
      if ((SLinkOperations.getTarget(config, LINKS.extendedFMC$tFbw) == null)) {
        FeatureModelConfiguration__BehaviorDescriptor.updateAdaptHash_id2XyYtG$Jnmi.invoke(config);
      }

      // now we finally set complete==true in order ensure the final invocation of the solver
      SPropertyOperations.assign(config, PROPS.complete$4SB6, true);
      SPropertyOperations.assign(expected, PROPS.complete$4SB6, true);
    }
  }

  public static void withSolverSuspended(SNode config, Runnable runnable) {
    boolean originalFlag = SPropertyOperations.getBoolean(config, PROPS.complete$4SB6);
    SPropertyOperations.assign(config, PROPS.complete$4SB6, false);

    // set the flag to the original value even if an exception occurred
    try {
      runnable.run();
    } finally {
      SPropertyOperations.assign(config, PROPS.complete$4SB6, originalFlag);
    }

    // do not call solver
  }

  public static IResult withSolverDelayedSync(SNode config, Runnable runnable) {
    boolean originalFlag = SPropertyOperations.getBoolean(config, PROPS.complete$4SB6);
    SPropertyOperations.assign(config, PROPS.complete$4SB6, false);

    // set the flag to the original value even if an exception occurred
    try {
      runnable.run();
    } finally {
      SPropertyOperations.assign(config, PROPS.complete$4SB6, originalFlag);
    }

    // run the solver only if no exception occurred
    return (IResult) ISolvable__BehaviorDescriptor.runSolver_id7QODtLw3SMH.invoke(config);
  }

  public static CompletableFuture<List<IResult>> withSolverDelayed(SNode config, Runnable runnable) {
    boolean originalFlag = SPropertyOperations.getBoolean(config, PROPS.complete$4SB6);
    SPropertyOperations.assign(config, PROPS.complete$4SB6, false);

    // set the flag to the original value even if an exception occurred
    try {
      runnable.run();
    } finally {
      SPropertyOperations.assign(config, PROPS.complete$4SB6, originalFlag);
    }

    // this will execute the solver (only if no exception occurred), but only if originalCompleteFlag was true
    FeatureModelConfiguration__BehaviorDescriptor.removeError_id5UDdUfokHMF.invoke(config);
    return (CompletableFuture<List<IResult>>) ISolvable__BehaviorDescriptor.runManuallyAsync_id7QODtLvTFnz.invoke(config);
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept SolveControl$Vn = MetaAdapterFactory.getConcept(0xdb8bd0353f5141d8L, 0x8fed954c202d18beL, 0x3a7ea77800f376f5L, "org.iets3.analysis.base.structure.SolveControl");
  }

  private static final class PROPS {
    /*package*/ static final SProperty mode$kQof = MetaAdapterFactory.getProperty(0xdb8bd0353f5141d8L, 0x8fed954c202d18beL, 0x3a7ea77800f376f5L, 0x3a7ea77800f377b0L, "mode");
    /*package*/ static final SProperty complete$4SB6 = MetaAdapterFactory.getProperty(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x5cf5c0d0479ec915L, 0x427f472315a4eeb9L, "complete");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink extendedFMC$tFbw = MetaAdapterFactory.getContainmentLink(0x71226ee2bbc445d2L, 0xa41d20b97237156cL, 0x5cf5c0d0479ec915L, 0x4617323a864bd075L, "extendedFMC");
  }
}
