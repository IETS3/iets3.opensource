package org.iets3.core.plugin.plugin;

/*Generated by MPS */

import com.mbeddr.mpsutil.projectview.runtime.IProjectViewDescriptor;
import java.util.List;
import com.mbeddr.mpsutil.projectview.runtime.IViewDescriptor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import com.mbeddr.mpsutil.projectview.runtime.AbstractViewDescriptor;
import java.util.Map;
import com.mbeddr.mpsutil.projectview.runtime.ElementId;
import com.mbeddr.mpsutil.projectview.runtime.IViewElementDescriptor;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.LinkedHashMap;
import com.mbeddr.mpsutil.projectview.runtime.AbstractViewElementDescriptor;
import org.jetbrains.mps.openapi.model.SModel;
import com.mbeddr.mpsutil.projectview.runtime.ViewElement;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import com.mbeddr.mpsutil.projectview.runtime.ViewId;
import jetbrains.mps.project.Project;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.annotations.Nullable;
import javax.swing.Icon;
import com.intellij.icons.AllIcons;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.ide.icons.GlobalIconManager;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public class ProjectViewDescriptor implements IProjectViewDescriptor {
  public static final ProjectViewDescriptor INSTANCE = new ProjectViewDescriptor();
  private final List<IViewDescriptor> myViews = ListSequence.fromList(new ArrayList<IViewDescriptor>());

  public ProjectViewDescriptor() {
    ListSequence.fromList(myViews).addElement(new AbstractViewDescriptor() {
      private Map<ElementId, IViewElementDescriptor> myElements = MapSequence.fromMap(new LinkedHashMap<ElementId, IViewElementDescriptor>(16, (float) 0.75, false));
      {
        addElement(new AbstractViewElementDescriptor<SModel>() {
          @Override
          public String getLabel(ViewElement element) {
            return SModelOperations.getModelName(((SModel) element.getObject(new ElementId("specModel", new ViewId("org.iets3.core.plugin.plugin.SpecExplorer")))));
          }
          @Override
          public boolean isAbstract() {
            return false;
          }
          @Override
          public boolean isOverride() {
            return false;
          }
          @Override
          public Iterable<ViewElement<SModel>> queryElements(final Project mpsProject, final ViewElement parentElement, final ViewId contextView) {
            final ElementId descriptorId = new ElementId("specModel", new ViewId("org.iets3.core.plugin.plugin.SpecExplorer"));
            ViewElement element = parentElement;
            Object queryResult = SpecExplorerHelper.getSpecModels(mpsProject);

            Iterable<SModel> rawSequence = (queryResult instanceof Iterable ? ((Iterable<SModel>) queryResult) : Sequence.<SModel>singleton(((SModel) queryResult)));

            return Sequence.fromIterable(rawSequence).where((it) -> it != null).select((it) -> new ViewElement<SModel>(it, descriptorId, mpsProject, parentElement, contextView));
          }
          @Override
          public ElementId getId() {
            return new ElementId("specModel", new ViewId("org.iets3.core.plugin.plugin.SpecExplorer"));
          }
          @Nullable
          @Override
          public Icon getIcon(ViewElement element) {
            Project mpsProject = element.getProject();
            return AllIcons.Nodes.Static;
          }
          @Override
          public boolean isAssignable(Project mpsProject, ViewElement<SModel> element) {
            return super.isAssignable(mpsProject, element) && element.getObject() instanceof SModel;
          }
          @Override
          public Class getOutputType() {
            return SModel.class;
          }
        });
        addElement(new AbstractViewElementDescriptor<SNode>() {
          @Override
          public ElementId getParentId() {
            return new ElementId("specModel", new ViewId("org.iets3.core.plugin.plugin.SpecExplorer"));
          }
          @Override
          public String getLabel(ViewElement element) {
            return SPropertyOperations.getString(((SNode) element.getObject(new ElementId("root", new ViewId("org.iets3.core.plugin.plugin.SpecExplorer")))), PROPS.name$MnvL);
          }
          @Override
          public boolean isAbstract() {
            return true;
          }
          @Override
          public boolean isOverride() {
            return false;
          }
          @Override
          public ElementId getId() {
            return new ElementId("root", new ViewId("org.iets3.core.plugin.plugin.SpecExplorer"));
          }
          @Nullable
          @Override
          public Icon getIcon(ViewElement element) {
            Project mpsProject = element.getProject();
            return GlobalIconManager.getInstance().getIconFor(((SNode) element.getObject(new ElementId("root", new ViewId("org.iets3.core.plugin.plugin.SpecExplorer")))));
          }
          @Override
          public boolean isAssignable(Project mpsProject, ViewElement<SNode> element) {
            return super.isAssignable(mpsProject, element) && SNodeOperations.isInstanceOf(element.getObject(), CONCEPTS.ISpecRoot$SE);
          }
          @Override
          public Class getOutputType() {
            return SNode.class;
          }
          @Override
          public Boolean loadLazy(ViewElement<SNode> element) {
            Project mpsProject = element.getProject();
            return false;
          }
        });
      }

      public void addElement(IViewElementDescriptor element) {
        MapSequence.fromMap(myElements).put(element.getId(), element);
      }
      protected ViewId getViewId() {
        return getId();
      }
      @Override
      public ViewId getId() {
        return new ViewId("org.iets3.core.plugin.plugin.SpecExplorer");
      }
      @Override
      public List<IViewElementDescriptor> getElements() {
        return Sequence.fromIterable(MapSequence.fromMap(myElements).values()).toList();
      }
      @Override
      public IViewElementDescriptor getElement(ElementId id) {
        return MapSequence.fromMap(myElements).get(id);
      }
      @Override
      public String getLabel() {
        return ((_FunctionTypes._return_P0_E0<String>) () -> {
          SpecConfig config = SpecConfigHelper.getConfig();
          if (config != null && config.activateSpecExplorer()) {
            return "Specification";
          } else {
            return null;
          }
        }).invoke();
      }
      @Override
      public int getPriority() {
        return 6;
      }
      @Override
      public Icon getIcon() {
        return AllIcons.Nodes.Static;
      }
    });
  }

  @Override
  public Iterable<IViewDescriptor> getViewDescriptors() {
    return myViews;
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept ISpecRoot$SE = MetaAdapterFactory.getInterfaceConcept(0x7b68d745a7b848b9L, 0xbd9c05c0f8725a35L, 0x6c4f9fd23e57eb38L, "org.iets3.core.base.structure.ISpecRoot");
  }
}
