package org.iets3.variability.featuremodel.base.behavior;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.util.List;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class FeatureTreeNodeExpressionUtil {

  public static Iterable<SNode> findConstraintsInvolvingThisFeature(Iterable<SNode> constraints, final _FunctionTypes._return_P1_E0<? extends Boolean, ? super SNode> predicate) {
    // Within an ExpressionConstraint we seek FeatureRefExpr and/or SubDotTragets which are left-most with respect to a DotExpression. Thus we have the parent-check.
    return Sequence.fromIterable(constraints).where((it) -> featureInFeatureRefExpr(it, predicate) || featureInDotExpression(predicate, it));
  }

  private static boolean featureInFeatureRefExpr(SNode constr, final _FunctionTypes._return_P1_E0<? extends Boolean, ? super SNode> features) {
    return ListSequence.fromList(SNodeOperations.getNodeDescendants(constr, CONCEPTS.FeatureRefExpr$Ys, true, new SAbstractConcept[]{})).where((it) -> !(SNodeOperations.isInstanceOf(SNodeOperations.getParent(it), CONCEPTS.DotExpression$jp))).any((it) -> features.invoke(SLinkOperations.getTarget(it, LINKS.feature$3d5y)));
  }

  private static boolean featureInDotExpression(final _FunctionTypes._return_P1_E0<? extends Boolean, ? super SNode> features, SNode constr) {
    List<SNode> descendants = SNodeOperations.getNodeDescendants(constr, CONCEPTS.DotExpression$jp, true, new SAbstractConcept[]{});
    return Sequence.fromIterable(SNodeOperations.ofConcept(ListSequence.fromList(descendants).where((it) -> !(SNodeOperations.isInstanceOf(SNodeOperations.getParent(it), CONCEPTS.DotExpression$jp))).select((it) -> SLinkOperations.getTarget(it, LINKS.target$u23F)), CONCEPTS.SubFeatureDotTarget$5P)).any((it) -> features.invoke(SLinkOperations.getTarget(it, LINKS.feature$hhv5)));
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept FeatureRefExpr$Ys = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd81d2eeL, "org.iets3.variability.featuremodel.base.structure.FeatureRefExpr");
    /*package*/ static final SConcept DotExpression$jp = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7cef88020a0f4249L, "org.iets3.core.expr.base.structure.DotExpression");
    /*package*/ static final SConcept SubFeatureDotTarget$5P = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd85baccL, "org.iets3.variability.featuremodel.base.structure.SubFeatureDotTarget");
  }

  private static final class LINKS {
    /*package*/ static final SReferenceLink feature$3d5y = MetaAdapterFactory.getReferenceLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd81d2eeL, 0x7cde27c7fd81d2f8L, "feature");
    /*package*/ static final SContainmentLink target$u23F = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7cef88020a0f4249L, 0x7cef88020a0f424bL, "target");
    /*package*/ static final SReferenceLink feature$hhv5 = MetaAdapterFactory.getReferenceLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd85baccL, 0x7cde27c7fd85bad9L, "feature");
  }
}
