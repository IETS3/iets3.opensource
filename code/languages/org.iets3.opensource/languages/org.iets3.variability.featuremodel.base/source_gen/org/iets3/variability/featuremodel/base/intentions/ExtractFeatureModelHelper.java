package org.iets3.variability.featuremodel.base.intentions;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import org.iets3.variability.base.behavior.IVariabilityContainer__BehaviorDescriptor;
import org.iets3.variability.featuremodel.base.behavior.FeatureTreeNode__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import io.vavr.Tuple3;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.iets3.variability.featuremodel.base.behavior.AbstractFeature__BehaviorDescriptor;
import java.util.LinkedList;
import com.google.common.collect.Lists;
import org.iets3.variability.featuremodel.base.behavior.ICanHaveSubFeature__BehaviorDescriptor;
import org.iets3.variability.featuremodel.base.behavior.ICanHaveAttribute__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.Objects;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.smodel.SModelInternal;
import org.iets3.variability.featuremodel.base.behavior.ICanBeCheckStateInitalized__BehaviorDescriptor;
import java.util.Set;
import org.iets3.variability.featuremodel.base.plugin.DotExpressionUtil;
import io.vavr.Tuple;
import org.apache.commons.collections4.SetUtils;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.Collection;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import com.google.common.collect.Sets;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class ExtractFeatureModelHelper {
  public static boolean maySplit(SNode originalFeature) {
    // the variability container of the current feature model has to able to store the extracted feature model,
    // and the originalFeature has to support manipulating its subfeatures
    return (boolean) IVariabilityContainer__BehaviorDescriptor.mayAdd_id3D4yX3IOARB.invoke(FeatureTreeNode__BehaviorDescriptor.variabilityContainer_id3D4yX3IZ4Gx.invoke(originalFeature), CONCEPTS.FeatureModel$X0) && SNodeOperations.isInstanceOf(originalFeature, CONCEPTS.ICanHaveSubFeature$Cu);
  }

  public static SNode split(SNode originalFeature) {
    SNode varCont = FeatureTreeNode__BehaviorDescriptor.variabilityContainer_id3D4yX3IZ4Gx.invoke(originalFeature);
    SNode fm = SNodeOperations.getNodeAncestor(originalFeature, CONCEPTS.FeatureModel$X0, false, false);
    if ((varCont != null) && (fm != null)) {
      Iterable<Tuple3<SNode, SNode, Boolean>> pushDownConstraintsAndShortendConstraints = Sequence.fromIterable(pushDownConstraints(SLinkOperations.getChildren(fm, LINKS.constraints$SJXp), originalFeature)).toList();

      if (!(SNodeOperations.isInstanceOf(originalFeature, CONCEPTS.ICanHaveSubFeature$Cu))) {
        throw new RuntimeException("The feature to be split must allow manipulating its subfeatures.");
      }

      // Remember the nodes children
      Iterable<SNode> subFeatures = AbstractFeature__BehaviorDescriptor.subFeatures_id6GZHy357BW_.invoke(originalFeature);
      LinkedList<SNode> bufferedChildren = Lists.newLinkedList(AbstractFeature__BehaviorDescriptor.subFeatures_id6GZHy357BW_.invoke(originalFeature));

      // Remove children from node
      ICanHaveSubFeature__BehaviorDescriptor.clearSubFeatures_id5U58I912QvU.invoke(SNodeOperations.cast(originalFeature, CONCEPTS.ICanHaveSubFeature$Cu));
      SNode copyFeature = SNodeOperations.copyNode(originalFeature);
      {
        final SNode icha = originalFeature;
        if (SNodeOperations.isInstanceOf(icha, CONCEPTS.ICanHaveAttribute$n8)) {
          Iterable<SNode> oldAttributes = ICanHaveAttribute__BehaviorDescriptor.attributes_id176p2Bjl1TH.invoke(icha);
          final SNode ichaNew = SNodeOperations.cast(copyFeature, CONCEPTS.ICanHaveAttribute$n8);
          Sequence.fromIterable(ICanHaveAttribute__BehaviorDescriptor.attributes_id176p2Bjl1TH.invoke(ichaNew)).visitAll((it) -> ICanHaveAttribute__BehaviorDescriptor.remove_id1wX6IAfr11e.invoke(ichaNew, it));
          Sequence.fromIterable(oldAttributes).visitAll((it) -> ICanHaveAttribute__BehaviorDescriptor.add_id3PTkJkrWfl0.invoke(ichaNew, it));
        }
      }

      // Add children of node to the copy -> preserves references.
      ICanHaveSubFeature__BehaviorDescriptor.addSubFeatures_id5U58I90Qhsq.invoke(SNodeOperations.cast(copyFeature, CONCEPTS.ICanHaveSubFeature$Cu), bufferedChildren);

      // Create separate FeatureModel with node-copy as root
      SLinkOperations.setTarget(copyFeature, LINKS.cardinality$EsDt, null);
      SNode fmNew = createFeatureModel_h6nu8h_a0s0c0c(copyFeature);
      SPropertyOperations.assignEnum(fmNew, PROPS.visualization$7Wge, SPropertyOperations.getEnum(fm, PROPS.visualization$7Wge));
      int idx = ListSequence.fromList(IVariabilityContainer__BehaviorDescriptor.getContents_id22kx7U4Ix5a.invoke(varCont)).indexOf(fm);
      SLinkOperations.getChildren(fm, LINKS.constraints$SJXp).removeAll(Sequence.fromIterable(pushDownConstraintsAndShortendConstraints).select((it) -> it._1()).toList());
      List<SNode> substitutes = Sequence.fromIterable(pushDownConstraintsAndShortendConstraints).select((it) -> (it._3() ? it._1() : it._2())).toList();

      substituteRefToOriginalFeatureByReftoCopyFeature(substitutes, originalFeature, copyFeature);

      SLinkOperations.getChildren(fmNew, LINKS.constraints$SJXp).addAll(substitutes);
      IVariabilityContainer__BehaviorDescriptor.addContent_id22kx7U4IoRa.invoke(varCont, ((int) (idx + 1)), fmNew);
      IVariabilityContainer__BehaviorDescriptor.addContent_id22kx7U4IoRa.invoke(varCont, ((int) (idx + 1)), createEmptyVariabilityContent_h6nu8h_b0a82a2a2());

      SNode fmi = createFeatureModelInclude_h6nu8h_a0eb0c0c(fmNew);
      return replace(originalFeature, fmi);
    }
    return null;
  }

  private static void substituteRefToOriginalFeatureByReftoCopyFeature(List<SNode> pushDownConstraints, SNode originalFeature, SNode copyFeature) {
    for (SNode c : ListSequence.fromList(pushDownConstraints)) {
      for (SNode fre : ListSequence.fromList(SNodeOperations.getNodeDescendants(c, CONCEPTS.FeatureRefExpr$Ys, true, new SAbstractConcept[]{}))) {
        if (Objects.equals(SLinkOperations.getTarget(fre, LINKS.feature$3d5y), originalFeature)) {
          SLinkOperations.setTarget(fre, LINKS.feature$3d5y, copyFeature);
        }
      }
    }
  }

  private static SNode replace(final SNode node, SNode fmi) {
    // Inspired by RefactoringRuntime.replaceWithNewConcept. Omits copying of properties and children as FMI does not have them.
    ((jetbrains.mps.smodel.SNode) ((SNode) fmi)).setId(((jetbrains.mps.smodel.SNode) ((SNode) node)).getNodeId());

    for (SReference ref : Sequence.fromIterable(node.getReferences())) {
      fmi.setReferenceTarget(ref.getLink(), ref.getTargetNode());
    }

    if (SNodeOperations.getModel(node) instanceof SModelInternal) {
      if (!(as_h6nu8h_a0a0a0a5a6_0(SNodeOperations.getModel(node), SModelInternal.class).importedLanguageIds().contains(SNodeOperations.getConcept(fmi).getLanguage()))) {
        as_h6nu8h_a0a0a0a5a6(SNodeOperations.getModel(node), SModelInternal.class).addLanguage(SNodeOperations.getConcept(fmi).getLanguage());
      }
    }
    final SNode result = SNodeOperations.replaceWithAnother(node, fmi);
    ListSequence.fromList(SNodeOperations.getNodeDescendants(result, null, true, new SAbstractConcept[]{})).translate((it) -> SNodeOperations.getReferences(it)).where((it) -> SLinkOperations.getTargetNode(it) == node).visitAll((it) -> it.getSourceNode().setReferenceTarget(it.getLink(), result));

    ICanBeCheckStateInitalized__BehaviorDescriptor.setDefaultCheckState_id1GMgmu$Up$S.invoke(fmi, SPropertyOperations.getEnum(node, PROPS.defaultState$z3_z));
    SLinkOperations.setTarget(fmi, LINKS.cardinality$EsDt, SLinkOperations.getTarget(node, LINKS.cardinality$EsDt));
    SPropertyOperations.assign(fmi, PROPS.isMandatory$LBat, SPropertyOperations.getBoolean(node, PROPS.isMandatory$LBat));
    return result;
  }


  /**
   * 1. tests constraints whether their referenced features are completely contained in the sub feature model subtree rooted at feature ().
   * 2. tests the SHORTENED constraints whether their referenced features are completely contained in the sub feature model subtree rooted at feature.
   * 
   * @param constraints set of constraints
   * @param feature feature node
   * @return A Triple-list <1,2,3> where 1 is a Constraint, 2 the Shortened Constrain  and 3 indiactes  if for constraints holds (*). For any Triple we heave that (*) holds for 2.
   */
  private static Iterable<Tuple3<SNode, SNode, Boolean>> pushDownConstraints(List<SNode> constraints, SNode feature) {
    final Set<SNode> descendantFeatures = subfeaturesOf(feature);

    return Sequence.fromIterable((ListSequence.fromList(constraints).select((it) -> {
      SNode copy = SNodeOperations.copyNode(it);
      {
        final SNode econ = copy;
        if (SNodeOperations.isInstanceOf(econ, CONCEPTS.ExpressionConstraint$Nn)) {
          DotExpressionUtil.shortenDotExpressions(SLinkOperations.getTarget(econ, LINKS.expr$K5rT));
        }
      }
      return Tuple.of(it, copy);
    }))).where((it) -> isIn(featuresOf(it._2()), descendantFeatures)).select((it) -> Tuple.of(it._1(), it._2(), isIn(featuresOf(it._1()), descendantFeatures)));
  }


  private static boolean isIn(Set<SNode> testMe, Set<SNode> testSet) {
    return SetUtils.intersection(testMe, testSet).size() == SetSequence.fromSet(testMe).count();
  }

  private static Set<SNode> subfeaturesOf(SNode feature) {
    Set<SNode> result = SetSequence.fromSet(new HashSet<SNode>());
    subfeaturesOfHlp(feature, result);
    SetSequence.fromSet(result).removeElement(feature);
    return result;
  }

  private static void subfeaturesOfHlp(SNode feature, Collection<SNode> result) {
    if (CollectionSequence.fromCollection(result).contains(feature)) {
      return;
    }
    CollectionSequence.fromCollection(result).addElement(feature);
    for (SNode child : Sequence.fromIterable(AbstractFeature__BehaviorDescriptor.subFeatures_id6GZHy357BW_.invoke(FeatureTreeNode__BehaviorDescriptor.effectiveFeature_id6GZHy352t67.invoke(feature)))) {
      subfeaturesOfHlp(child, result);
    }
  }


  private static Set<SNode> featuresOf(SNode constraint) {
    return Sets.<SNode>newHashSet(ListSequence.fromList(SNodeOperations.getNodeDescendants(constraint, CONCEPTS.FeatureRefExpr$Ys, true, new SAbstractConcept[]{})).select((it) -> SLinkOperations.getTarget(it, LINKS.feature$3d5y)).union(ListSequence.fromList(SNodeOperations.getNodeDescendants(constraint, CONCEPTS.SubFeatureDotTarget$5P, true, new SAbstractConcept[]{})).select((it) -> SLinkOperations.getTarget(it, LINKS.feature$hhv5))));
  }
  private static SNode createFeatureModel_h6nu8h_a0s0c0c(SNode p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.FeatureModel$X0);
    n0.forChild(LINKS.root$XEj1).initNode(p0, CONCEPTS.AbstractFeature$T, true);
    return n0.getResult();
  }
  private static SNode createEmptyVariabilityContent_h6nu8h_b0a82a2a2() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.EmptyVariabilityContent$Xk);
    return n0.getResult();
  }
  private static SNode createFeatureModelInclude_h6nu8h_a0eb0c0c(SNode p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.FeatureModelInclude$Iq);
    n0.setReferenceTarget(LINKS.fm$EY24, p0);
    return n0.getResult();
  }
  private static <T> T as_h6nu8h_a0a0a0a5a6(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_h6nu8h_a0a0a0a5a6_0(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept ICanHaveSubFeature$Cu = MetaAdapterFactory.getInterfaceConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x1b324167a470b175L, "org.iets3.variability.featuremodel.base.structure.ICanHaveSubFeature");
    /*package*/ static final SConcept FeatureModel$X0 = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x375cadc47516a211L, "org.iets3.variability.featuremodel.base.structure.FeatureModel");
    /*package*/ static final SInterfaceConcept ICanHaveAttribute$n8 = MetaAdapterFactory.getInterfaceConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0xfa39f86f2537cf8L, "org.iets3.variability.featuremodel.base.structure.ICanHaveAttribute");
    /*package*/ static final SConcept FeatureRefExpr$Ys = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd81d2eeL, "org.iets3.variability.featuremodel.base.structure.FeatureRefExpr");
    /*package*/ static final SConcept ExpressionConstraint$Nn = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd7eea4dL, "org.iets3.variability.featuremodel.base.structure.ExpressionConstraint");
    /*package*/ static final SConcept SubFeatureDotTarget$5P = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd85baccL, "org.iets3.variability.featuremodel.base.structure.SubFeatureDotTarget");
    /*package*/ static final SConcept AbstractFeature$T = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x6b3fb620c4f9ac90L, "org.iets3.variability.featuremodel.base.structure.AbstractFeature");
    /*package*/ static final SConcept EmptyVariabilityContent$Xk = MetaAdapterFactory.getConcept(0x9b66c5c938bf4315L, 0xa96f9f4e212c69cbL, 0x375cadc47514d908L, "org.iets3.variability.base.structure.EmptyVariabilityContent");
    /*package*/ static final SConcept FeatureModelInclude$Iq = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x375cadc475172168L, "org.iets3.variability.featuremodel.base.structure.FeatureModelInclude");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink constraints$SJXp = MetaAdapterFactory.getContainmentLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x375cadc47516a211L, 0x4c647e983b096ecdL, "constraints");
    /*package*/ static final SContainmentLink cardinality$EsDt = MetaAdapterFactory.getContainmentLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x375cadc475172167L, 0x375cadc47519250cL, "cardinality");
    /*package*/ static final SReferenceLink feature$3d5y = MetaAdapterFactory.getReferenceLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd81d2eeL, 0x7cde27c7fd81d2f8L, "feature");
    /*package*/ static final SContainmentLink expr$K5rT = MetaAdapterFactory.getContainmentLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd7eea4dL, 0x7cde27c7fd7eea4eL, "expr");
    /*package*/ static final SReferenceLink feature$hhv5 = MetaAdapterFactory.getReferenceLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd85baccL, 0x7cde27c7fd85bad9L, "feature");
    /*package*/ static final SContainmentLink root$XEj1 = MetaAdapterFactory.getContainmentLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x375cadc47516a211L, 0x375cadc47516a30cL, "root");
    /*package*/ static final SReferenceLink fm$EY24 = MetaAdapterFactory.getReferenceLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x375cadc475172168L, 0x375cadc475172169L, "fm");
  }

  private static final class PROPS {
    /*package*/ static final SProperty visualization$7Wge = MetaAdapterFactory.getProperty(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x375cadc47516a211L, 0x598dc612d79f0521L, "visualization");
    /*package*/ static final SProperty defaultState$z3_z = MetaAdapterFactory.getProperty(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x375cadc475172167L, 0x74046bf85651dafaL, "defaultState");
    /*package*/ static final SProperty isMandatory$LBat = MetaAdapterFactory.getProperty(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x375cadc475172167L, 0x375cadc475182d76L, "isMandatory");
  }
}
