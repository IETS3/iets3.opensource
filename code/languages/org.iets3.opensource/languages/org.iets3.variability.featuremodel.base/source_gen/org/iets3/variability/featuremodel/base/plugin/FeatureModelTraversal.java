package org.iets3.variability.featuremodel.base.plugin;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Objects;
import java.util.Set;
import java.util.Collections;
import org.iets3.variability.featuremodel.base.behavior.FeatureTreeNode__BehaviorDescriptor;
import com.google.common.collect.Sets;
import com.google.common.collect.Lists;
import java.util.Arrays;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.iets3.variability.featuremodel.base.behavior.AbstractFeature__BehaviorDescriptor;
import java.util.stream.Stream;
import java.util.function.BiFunction;
import com.google.common.collect.Streams;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;

public class FeatureModelTraversal {
  private static final Logger LOG = Logger.getLogger(FeatureModelTraversal.class);
  public static List<List<SNode>> findAllPathsToSubFeature(SNode from, SNode to) {
    return FeatureModelTraversal.findAllPathsToSubFeature(from, to, (String s, SNode n) -> {
    });
  }


  public static List<List<SNode>> findAllPathsToSubFeature(SNode from, SNode to, boolean shorten) {
    List<List<SNode>> allPaths = FeatureModelTraversal.findAllPathsToSubFeature(from, to, (String s, SNode n) -> {
    });
    return (shorten ? ListSequence.fromList(allPaths).select((it) -> DotExpressionUtil.shortenPath(it)).toList() : allPaths);
  }

  public static List<List<SNode>> findAllPathsToSubFeatureInclusive(SNode from, SNode to, boolean shorten) {
    List<List<SNode>> findAllPathsToSubFeature = findAllPathsToSubFeature(from, to, shorten);

    for (List<SNode> path : ListSequence.fromList(findAllPathsToSubFeature)) {
      path.add(0, from);
    }
    return findAllPathsToSubFeature;
  }

  /**
   * 
   * 
   * @param from start
   * @param to end
   * @param reportError callback to indicate cyclic feature models
   * @return all paths starting at 'from' ending in 'to' containing all 'FeatureTreeNodes' in between as list. Does not include 'from' (i.e  a1,a2,a3..,end  where a1 is a direct child of 'from')
   */
  public static List<List<SNode>> findAllPathsToSubFeature(SNode from, SNode to, boolean shorten, _FunctionTypes._void_P2_E0<? super String, ? super SNode> reportError) {
    List<List<SNode>> allPaths = FeatureModelTraversal.allPathsToSubFeatureHlp(from, to, SetSequence.fromSet(new HashSet<SNode>()), reportError);
    return (shorten ? ListSequence.fromList(allPaths).select((it) -> DotExpressionUtil.shortenPath(it)).toList() : allPaths);
  }

  public static List<List<SNode>> prunePaths(List<List<SNode>> paths, final SNode targetFeature) {
    return ListSequence.fromList(paths).select((path) -> prunePath(targetFeature, path)).toList();
  }

  public static List<SNode> prunePath(final SNode targetFeature, final List<SNode> path) {
    // Keep only FeatureModelIncludes, as they suffice to represent an unique path through the FeatureModel
    // Keep also the last item if it is not a FeatureModelConfiguration as it is the 'subFeature' and is removed otherwise
    return ListSequence.fromList(path).where((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.FeatureModelInclude$Iq) || (Objects.equals(it, ListSequence.fromList(path).last()) && !(SNodeOperations.isInstanceOf(targetFeature, CONCEPTS.FeatureModelInclude$Iq)))).toList();
  }

  /**
   * 
   * 
   * @param from start
   * @param to end
   * @param reportError callback to indicate cyclic feature models
   * @return all paths starting at 'from' ending in 'to' containing all 'FeatureTreeNodes' in between as list. Does not include 'from' (i.e  a1,a2,a3..,end  where a1 is a direct child of 'from')
   */
  public static List<List<SNode>> findAllPathsToSubFeature(SNode from, SNode to, _FunctionTypes._void_P2_E0<? super String, ? super SNode> reportError) {
    return FeatureModelTraversal.allPathsToSubFeatureHlp(from, to, SetSequence.fromSet(new HashSet<SNode>()), reportError);
  }

  private static List<List<SNode>> allPathsToSubFeatureHlp(SNode from, SNode to, Set<SNode> seenNodesOnDepthFirst, _FunctionTypes._void_P2_E0<? super String, ? super SNode> reportError) {
    if (FeatureModelTraversal.checkForCycle(seenNodesOnDepthFirst, from, reportError)) {
      return Collections.emptyList();
    }

    if (Objects.equals(from, to) || Objects.equals(FeatureTreeNode__BehaviorDescriptor.effectiveFeature_id6GZHy352t67.invoke(from), to)) {
      Set<SNode> found = Sets.newHashSet(from, FeatureTreeNode__BehaviorDescriptor.effectiveFeature_id6GZHy352t67.invoke(from));
      seenNodesOnDepthFirst.removeAll(found);
      return Lists.<List<SNode>>newArrayList(Arrays.asList(Lists.<SNode>newLinkedList()));
    }

    List<List<SNode>> result = FeatureModelTraversal.recursiveDescent(from, reportError, seenNodesOnDepthFirst, to);
    seenNodesOnDepthFirst.remove(from);
    return result;
  }

  private static List<List<SNode>> recursiveDescent(SNode from, final _FunctionTypes._void_P2_E0<? super String, ? super SNode> reportError, final Set<SNode> seenNodesOnDepthFirst, final SNode to) {
    return Sequence.fromIterable(AbstractFeature__BehaviorDescriptor.subFeatures_id6GZHy357BW_.invoke(FeatureTreeNode__BehaviorDescriptor.effectiveFeature_id6GZHy352t67.invoke(from))).translate((final SNode sub) -> {
      List<List<SNode>> allPathsToSubFeature = allPathsToSubFeatureHlp(sub, to, seenNodesOnDepthFirst, reportError);
      ListSequence.fromList(allPathsToSubFeature).visitAll((it) -> ListSequence.fromList(it).insertElement(0, FeatureTreeNode__BehaviorDescriptor.effectiveFeature_id6GZHy352t67.invoke(sub)));
      if (!(Objects.equals(sub, FeatureTreeNode__BehaviorDescriptor.effectiveFeature_id6GZHy352t67.invoke(sub)))) {
        // FeatureModelInclude is also considered
        ListSequence.fromList(allPathsToSubFeature).visitAll((it) -> ListSequence.fromList(it).insertElement(0, sub));
      }
      return allPathsToSubFeature;
    }).toList();
  }

  private static boolean checkForCycle(Set<SNode> seenNodesOnDepthFirst, SNode from, _FunctionTypes._void_P2_E0<? super String, ? super SNode> reportError) {
    if (!(seenNodesOnDepthFirst.add(from))) {
      reportError.invoke("Cycle detected", from);
      return true;
    }
    return false;
  }

  public static boolean dotExpressionConstraintContainsFMI(SNode constraint, SNode fmRootFeature, final SNode fmi) {
    List<SNode> dotExpressionToList = dotExpressionToList(constraint);
    if (ListSequence.fromList(dotExpressionToList).isNotEmpty()) {
      dotExpressionToList.add(0, fmRootFeature);
      return isFMIOnPathBetween(dotExpressionToList, fmi);
    }
    return false;
  }

  private static Stream<Boolean> twoSlidingWindow(List<SNode> dotExpressionToList, BiFunction<SNode, SNode, Boolean> windowTransformer) {
    List<SNode> orig = dotExpressionToList;
    List<SNode> skkippedFirst = orig.subList(1, ListSequence.fromList(dotExpressionToList).count());
    return Streams.<SNode,SNode,Boolean>zip(orig.stream(), skkippedFirst.stream(), windowTransformer);
  }

  private static BiFunction<SNode, SNode, Boolean> isOnPathBetween(final SNode fmi) {
    return new BiFunction<SNode, SNode, Boolean>() {
      @Override
      public Boolean apply(SNode p1, SNode p2) {
        if (Objects.equals(p1, fmi) || Objects.equals(p2, fmi)) {
          return true;
        }
        List<List<SNode>> findAllPathsToSubFeature = FeatureModelTraversal.findAllPathsToSubFeature(p1, p2);
        return ListSequence.fromList(findAllPathsToSubFeature).any((it) -> ListSequence.fromList(it).contains(fmi));
      }
    };
  }

  public static boolean isFMIOnPathBetween(List<SNode> dotExpressionToList, final SNode fmi) {
    return twoSlidingWindow(dotExpressionToList, isOnPathBetween(fmi)).anyMatch((Boolean isSuccessful) -> isSuccessful);
  }

  public static List<SNode> dotExpressionToList(SNode dotExpression) {
    SNode expr = SLinkOperations.getTarget(dotExpression, LINKS.expr$CW3E);
    {
      final SNode fre = expr;
      if (SNodeOperations.isInstanceOf(fre, CONCEPTS.FeatureRefExpr$Ys)) {
        {
          final SNode sfdt = SLinkOperations.getTarget(dotExpression, LINKS.target$u23F);
          if (SNodeOperations.isInstanceOf(sfdt, CONCEPTS.SubFeatureDotTarget$5P)) {
            return Lists.newLinkedList(Lists.newArrayList(SLinkOperations.getTarget(fre, LINKS.feature$3d5y), SLinkOperations.getTarget(sfdt, LINKS.feature$hhv5)));
          }
        }
      }
    }
    {
      final SNode dte = expr;
      if (SNodeOperations.isInstanceOf(dte, CONCEPTS.DotExpression$jp)) {
        List<SNode> dotExpressionToList = dotExpressionToList(dte);
        SNode target = SLinkOperations.getTarget(dotExpression, LINKS.target$u23F);
        {
          final SNode sfdt = target;
          if (SNodeOperations.isInstanceOf(sfdt, CONCEPTS.SubFeatureDotTarget$5P)) {
            ListSequence.fromList(dotExpressionToList).addElement(SLinkOperations.getTarget(sfdt, LINKS.feature$hhv5));
          }
        }
        return dotExpressionToList;
      }
    }
    return ListSequence.fromList(new ArrayList<SNode>());
  }




  /**
   * 
   * 
   * @param feature start node
   * @param includeSelf include yourself in the result
   * @return find all descendant subfeatures including features in referenced feature model inlcudes.
   */
  public static List<SNode> findAllDirectlyReferenzableSubFeatures(SNode feature, boolean includeSelf) {
    return findAllDirectlyReferenzableSubFeaturesHlp(feature, includeSelf, Integer.MAX_VALUE);
  }
  /**
   * 
   * 
   * @param feature start node
   * @param includeSelf include yourself in the result
   * @param maxElements stop search if that many nodes are encountered.
   * @return find all descendant subfeatures including features in referenced feature model inlcudes.
   */
  public static List<SNode> findAllDirectlyReferenzableSubFeatures(SNode feature, boolean includeSelf, int maxElements) {
    return findAllDirectlyReferenzableSubFeaturesHlp(feature, includeSelf, maxElements);
  }

  /**
   * 
   * 
   * @param feature start node
   * @param includeSelf include yourself in the result
   * @param maxElements stop search if that many nodes are encountered.
   * @return find all descendant subfeatures including features in referenced feature model inlcudes.
   */
  private static List<SNode> findAllDirectlyReferenzableSubFeaturesHlp(SNode feature, boolean includeSelf, int maxElements) {
    List<SNode> result = ListSequence.fromList(new LinkedList<SNode>());
    if (includeSelf) {
      ListSequence.fromList(result).addElement(feature);
    }
    Queue<SNode> q = Lists.newLinkedList();
    q.addAll(Sequence.fromIterable(AbstractFeature__BehaviorDescriptor.subFeatures_id6GZHy357BW_.invoke(FeatureTreeNode__BehaviorDescriptor.effectiveFeature_id6GZHy352t67.invoke(feature))).where(new NotNullWhereFilter()).toList());
    int i = 0;
    while (!(q.isEmpty()) && i <= maxElements) {
      SNode firstNode = q.poll();
      ListSequence.fromList(result).addElement(firstNode);
      SNode ef = FeatureTreeNode__BehaviorDescriptor.effectiveFeature_id6GZHy352t67.invoke(firstNode);
      if (((SLinkOperations.getTarget(firstNode, LINKS.cardinality$EsDt) == null) && (SLinkOperations.getTarget(ef, LINKS.cardinality$EsDt) == null))) {
        Iterable<SNode> subFeatures = AbstractFeature__BehaviorDescriptor.subFeatures_id6GZHy357BW_.invoke(ef);
        if (subFeatures != null) {
          q.addAll(Sequence.fromIterable(subFeatures).toList());
        }
      }
      i++;
    }
    return result;
  }
  public static Iterable<List<SNode>> findAllPaths(SNode rootFeature, SNode subFeature) {

    SNode currentFeature = FeatureTreeNode__BehaviorDescriptor.effectiveFeature_id6GZHy352t67.invoke(rootFeature);

    List<List<SNode>> paths = FeatureModelTraversal.findAllPathsToSubFeature(currentFeature, subFeature, (String msg, SNode target) -> {
      if (LOG.isErrorLevel()) {
        LOG.error("ERROR: " + msg + "@" + target.getNodeId());
      }
    });
    return FeatureModelTraversal.prunePaths(paths, subFeature);
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept FeatureModelInclude$Iq = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x375cadc475172168L, "org.iets3.variability.featuremodel.base.structure.FeatureModelInclude");
    /*package*/ static final SConcept FeatureRefExpr$Ys = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd81d2eeL, "org.iets3.variability.featuremodel.base.structure.FeatureRefExpr");
    /*package*/ static final SConcept SubFeatureDotTarget$5P = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd85baccL, "org.iets3.variability.featuremodel.base.structure.SubFeatureDotTarget");
    /*package*/ static final SConcept DotExpression$jp = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7cef88020a0f4249L, "org.iets3.core.expr.base.structure.DotExpression");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink expr$CW3E = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x3b256bb6ae8048d8L, 0x3b256bb6ae8048d9L, "expr");
    /*package*/ static final SContainmentLink target$u23F = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7cef88020a0f4249L, 0x7cef88020a0f424bL, "target");
    /*package*/ static final SReferenceLink feature$3d5y = MetaAdapterFactory.getReferenceLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd81d2eeL, 0x7cde27c7fd81d2f8L, "feature");
    /*package*/ static final SReferenceLink feature$hhv5 = MetaAdapterFactory.getReferenceLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd85baccL, 0x7cde27c7fd85bad9L, "feature");
    /*package*/ static final SContainmentLink cardinality$EsDt = MetaAdapterFactory.getContainmentLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x375cadc475172167L, 0x375cadc47519250cL, "cardinality");
  }
}
