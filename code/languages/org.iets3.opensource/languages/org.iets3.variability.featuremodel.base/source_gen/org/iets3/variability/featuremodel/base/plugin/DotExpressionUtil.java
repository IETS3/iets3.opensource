package org.iets3.variability.featuremodel.base.plugin;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.function.Predicate;
import java.util.stream.Stream;
import java.util.stream.Collectors;
import java.util.function.Supplier;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.iets3.variability.featuremodel.base.behavior.IFeatureRefExpr__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.NotNullWhereFilter;
import org.apache.commons.lang3.Validate;
import com.google.common.collect.Lists;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.Optional;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public class DotExpressionUtil {

  /**
   * Convert a (nested) DotExpression to a list without any DotExpression nodes.
   * 
   * Example: A DotExpression "a.b.c" will be converted to a list [a, b, c].
   * 
   * @param dotEx the (maybe nested) DotExpression
   * @return a list with all its element expressions
   */
  public static List<SNode> linearizeDotExpression(SNode dotEx) {
    List<SNode> des = splitDotExpression(dotEx);
    return Sequence.fromIterable(Sequence.<SNode>singleton(SLinkOperations.getTarget(ListSequence.fromList(des).last(), LINKS.expr$CW3E))).union(ListSequence.fromList(des).reversedList().select((it) -> SLinkOperations.getTarget(it, LINKS.target$u23F))).toList();
  }

  /**
   * Traverse the 'expr' child of DotEspression as long it is a DotExpression.
   * Return a list of all 'expr' being DotExpressions
   * 
   * @param dotEx DoTexpression
   * @return list of DotExprssions
   */
  public static List<SNode> splitDotExpression(SNode dotEx) {
    Predicate<SNode> notNull = Predicate.not(Predicate.<SNode>isEqual(null));
    List<SNode> tailDotexprsExpressions = Stream.generate(DotExpressionUtil.transDotExpr(dotEx)).takeWhile(notNull).collect(Collectors.<SNode>toList());

    return Sequence.fromIterable(Sequence.<SNode>singleton(dotEx)).union(ListSequence.fromList(tailDotexprsExpressions)).toList();
  }

  private static Supplier<SNode> transDotExpr(SNode de) {
    final Wrappers._T<SNode> buffer = new Wrappers._T<SNode>(de);
    return () -> {
      buffer.value = SNodeOperations.as(SLinkOperations.getTarget(buffer.value, LINKS.expr$CW3E), CONCEPTS.DotExpression$jp);
      return buffer.value;
    };
  }

  public static List<SNode> toList(SNode dotExpression) {
    List<SNode> splitted = DotExpressionUtil.splitDotExpression(dotExpression);
    SNode lastExpr = SLinkOperations.getTarget(ListSequence.fromList(splitted).last(), LINKS.expr$CW3E);

    List<SNode> features = ListSequence.fromList(Sequence.fromIterable(SNodeOperations.ofConcept(ListSequence.fromList(splitted).select((it) -> SLinkOperations.getTarget(it, LINKS.target$u23F)), CONCEPTS.SubFeatureDotTarget$5P)).select((it) -> SLinkOperations.getTarget(it, LINKS.feature$hhv5)).toList()).reversedList();

    return Sequence.fromIterable(Sequence.<SNode>singleton(IFeatureRefExpr__BehaviorDescriptor.feature_id3q2wVeoIYrV.invoke(SNodeOperations.as(lastExpr, CONCEPTS.IFeatureRefExpr$Cn)))).union(ListSequence.fromList(features)).where(new NotNullWhereFilter()).toList();
  }

  public static SNode toDotExpression(Iterable<SNode> featurePath) {
    Validate.isTrue(Sequence.fromIterable(featurePath).count() >= 2, "Too few features given! Provide at least two features!");
    List<SNode> copiedPath = Lists.newLinkedList(featurePath);
    SNode first = ListSequence.fromList(copiedPath).removeElementAt(0);
    SNode head = createFeatureRefExpr_ehslcx_a0d0j(first);
    SNode expression = ListSequence.fromList(copiedPath).foldLeft(head, (SNode s, SNode it) -> createDotExpression_ehslcx_a0a0a0a4a9(s, createSubFeatureDotTarget_ehslcx_a0b0a0a0a0a4a9(it)));
    return SNodeOperations.cast(expression, CONCEPTS.DotExpression$jp);
  }

  /**
   * Reduce a list of feature nodes (representing a feature path) to only FeatureModelInclude nodes.
   * The last node (usually a feature reference) will be kept nevertheless.
   * 
   * @param path the input path (aka list of feature nodes)
   * @return a copy of the path, reduced as described above
   */
  public static List<SNode> shortenPath(List<SNode> path) {
    if (ListSequence.fromList(path).isEmpty()) {
      return path;
    }
    List<SNode> copyPath = Lists.newLinkedList(path);
    SNode last = ListSequence.fromList(copyPath).removeLastElement();
    List<SNode> resultPath = ListSequence.fromList(copyPath).removeWhere((it) -> !(SNodeOperations.isInstanceOf(it, CONCEPTS.FeatureModelInclude$Iq)));
    ListSequence.fromList(resultPath).addElement(last);
    return resultPath;
  }

  public static SNode shorten(SNode dotExpr, boolean keepFirst) {
    List<SNode> dotExprList = toList(dotExpr);
    SNode firstElement = null;
    if (keepFirst) {
      firstElement = ListSequence.fromList(dotExprList).removeElementAt(0);
    }
    List<SNode> onlyPath = shortenPath(dotExprList);
    if ((firstElement != null)) {
      onlyPath.add(0, firstElement);
    }
    return (ListSequence.fromList(onlyPath).count() > 1 ? toDotExpression(onlyPath) : createFeatureRefExpr_ehslcx_a0f0n(ListSequence.fromList(onlyPath).first()));
  }

  public static SNode shorten(SNode dotExpr) {
    List<SNode> onlyPath = shortenPath(toList(dotExpr));
    return (ListSequence.fromList(onlyPath).count() > 1 ? toDotExpression(onlyPath) : createFeatureRefExpr_ehslcx_a0b0p(ListSequence.fromList(onlyPath).first()));
  }


  public static void shortenDotExpressions(SNode expression) {
    List<SNode> descendants = SNodeOperations.getNodeDescendants(expression, CONCEPTS.DotExpression$jp, true, new SAbstractConcept[]{});
    // Find DotExpressions without and with FeatureAttributeDotTarget.
    List<SNode> canBeShortenedDotExpr = ListSequence.fromList(descendants).where((dotExpr) -> (!(SNodeOperations.isInstanceOf(SNodeOperations.getParent(dotExpr), CONCEPTS.DotExpression$jp)) && !(SNodeOperations.isInstanceOf(SLinkOperations.getTarget(dotExpr, LINKS.target$u23F), CONCEPTS.FeatureAttributeDotTarget$Ko)) || (SNodeOperations.isInstanceOf(SNodeOperations.getParent(dotExpr), CONCEPTS.DotExpression$jp) && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(dotExpr), CONCEPTS.DotExpression$jp), LINKS.target$u23F), CONCEPTS.FeatureAttributeDotTarget$Ko)))).toList();

    for (SNode dotExpr : ListSequence.fromList(canBeShortenedDotExpr)) {
      SNode shortendExpor = DotExpressionUtil.shorten(dotExpr);
      SNodeOperations.replaceWithAnother(dotExpr, shortendExpor);
    }
  }

  /**
   * Traverse the 'expr' child of DotEspression as long it is a DotExpression.
   * Return the last 'expr' being a DotExpression
   * 
   * @param de DotExpression
   * @return DotExpression
   */
  public static SNode headOf(SNode de) {
    SNode result = SLinkOperations.getTarget(de, LINKS.expr$CW3E);
    SNode lastDotEx = de;
    while (SNodeOperations.isInstanceOf(result, CONCEPTS.DotExpression$jp)) {
      lastDotEx = SNodeOperations.cast(result, CONCEPTS.DotExpression$jp);
      result = SLinkOperations.getTarget(lastDotEx, LINKS.expr$CW3E);
    }
    return lastDotEx;
  }


  /**
   * Traverse the parent-relation starting from a DotEpression upwards.
   * Stop up at the ancestor with no DotExpression as parent
   * 
   * @param de dotExpression
   * @return a ancester of de which is a Dotexpression
   */
  public static SNode topAncestorOf(SNode de) {
    SNode result = de;
    while (!(isTopAncestor(result))) {
      result = SNodeOperations.as(SNodeOperations.getParent(result), CONCEPTS.DotExpression$jp);
    }
    return result;
  }

  public static boolean isTopAncestor(SNode de) {
    return !(SNodeOperations.isInstanceOf(SNodeOperations.getParent(de), CONCEPTS.DotExpression$jp));
  }

  public static boolean isTopAncestorDotExpression(SNode n) {
    {
      final SNode dt = n;
      if (SNodeOperations.isInstanceOf(dt, CONCEPTS.DotExpression$jp)) {
        return isTopAncestor(dt);
      }
    }
    return false;
  }

  public static Optional<SNode> resolveTopAncestorDotExpression(SNode n) {
    {
      final SNode dt = n;
      if (SNodeOperations.isInstanceOf(dt, CONCEPTS.DotExpression$jp)) {
        if (isTopAncestor(dt)) {
          return Optional.of(dt);
        }
      }
    }
    return Optional.empty();
  }

  private static SNode createFeatureRefExpr_ehslcx_a0d0j(SNode p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.FeatureRefExpr$Ys);
    n0.setReferenceTarget(LINKS.feature$3d5y, p0);
    return n0.getResult();
  }
  private static SNode createDotExpression_ehslcx_a0a0a0a4a9(SNode p0, SNode p1) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.DotExpression$jp);
    n0.forChild(LINKS.expr$CW3E).initNode(p0, CONCEPTS.Expression$D_, true);
    n0.forChild(LINKS.target$u23F).initNode(p1, CONCEPTS.IDotTarget$jS, true);
    return n0.getResult();
  }
  private static SNode createSubFeatureDotTarget_ehslcx_a0b0a0a0a0a4a9(SNode p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.SubFeatureDotTarget$5P);
    n0.setReferenceTarget(LINKS.feature$hhv5, p0);
    return n0.getResult();
  }
  private static SNode createFeatureRefExpr_ehslcx_a0f0n(SNode p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.FeatureRefExpr$Ys);
    n0.setReferenceTarget(LINKS.feature$3d5y, p0);
    return n0.getResult();
  }
  private static SNode createFeatureRefExpr_ehslcx_a0b0p(SNode p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.FeatureRefExpr$Ys);
    n0.setReferenceTarget(LINKS.feature$3d5y, p0);
    return n0.getResult();
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink expr$CW3E = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x3b256bb6ae8048d8L, 0x3b256bb6ae8048d9L, "expr");
    /*package*/ static final SContainmentLink target$u23F = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7cef88020a0f4249L, 0x7cef88020a0f424bL, "target");
    /*package*/ static final SReferenceLink feature$hhv5 = MetaAdapterFactory.getReferenceLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd85baccL, 0x7cde27c7fd85bad9L, "feature");
    /*package*/ static final SReferenceLink feature$3d5y = MetaAdapterFactory.getReferenceLink(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd81d2eeL, 0x7cde27c7fd81d2f8L, "feature");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept DotExpression$jp = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7cef88020a0f4249L, "org.iets3.core.expr.base.structure.DotExpression");
    /*package*/ static final SConcept SubFeatureDotTarget$5P = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd85baccL, "org.iets3.variability.featuremodel.base.structure.SubFeatureDotTarget");
    /*package*/ static final SInterfaceConcept IFeatureRefExpr$Cn = MetaAdapterFactory.getInterfaceConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x368283b398bbe6d5L, "org.iets3.variability.featuremodel.base.structure.IFeatureRefExpr");
    /*package*/ static final SConcept FeatureModelInclude$Iq = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x375cadc475172168L, "org.iets3.variability.featuremodel.base.structure.FeatureModelInclude");
    /*package*/ static final SConcept FeatureAttributeDotTarget$Ko = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd968aaaL, "org.iets3.variability.featuremodel.base.structure.FeatureAttributeDotTarget");
    /*package*/ static final SConcept FeatureRefExpr$Ys = MetaAdapterFactory.getConcept(0x165f1d0525064544L, 0x895e1424f54166ecL, 0x7cde27c7fd81d2eeL, "org.iets3.variability.featuremodel.base.structure.FeatureRefExpr");
    /*package*/ static final SConcept Expression$D_ = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x670d5e92f854a047L, "org.iets3.core.expr.base.structure.Expression");
    /*package*/ static final SInterfaceConcept IDotTarget$jS = MetaAdapterFactory.getInterfaceConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x7cef88020a0f424aL, "org.iets3.core.expr.base.structure.IDotTarget");
  }
}
