package org.iets3.core.mapping.plugin;

/*Generated by MPS */

import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNode;

public abstract class AbstractTreeNode {
  private List<AbstractTreeNode> treeNodes = ListSequence.fromList(new ArrayList<AbstractTreeNode>());
  private AbstractTreeNode parent;
  private boolean isMapped = false;
  private String path = "";

  public void setParent(AbstractTreeNode parent) {
    this.parent = parent;
  }

  public AbstractTreeNode getParent() {
    return this.parent;
  }

  public boolean isRoot() {
    // when parent is undefined
    return this.parent == null;
  }

  public String getPath() {
    return this.path;
  }
  public String setPath(String path) {
    return this.path = path;
  }

  public void setMapped(boolean mapped) {
    this.isMapped = mapped;
  }
  public boolean isMapped() {
    return this.isMapped;
  }

  public List<AbstractTreeNode> getChildren() {
    return treeNodes;
  }

  /*package*/ boolean isSubTreeMapped() {
    return ListSequence.fromList(treeNodes).all((it) -> it.isMapped());
  }
  /*package*/ boolean isLeaf() {
    return ListSequence.fromList(treeNodes).isEmpty();
  }

  public abstract SNode getValue();


  public void calculatePath() {
    if (this.isLeaf()) {
      return;
    } else {
      ListSequence.fromList(this.getChildren()).visitAll((it) -> {
        TreeNode child = as_1maikx_a0a0a0a0a0a0a52(it, TreeNode.class);
        // set path in nodes
        child.setPath(child.getParent().getPath() + "." + child.getPath());
        child.calculatePath();
      });
    }
  }

  private static <T> T as_1maikx_a0a0a0a0a0a0a52(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
