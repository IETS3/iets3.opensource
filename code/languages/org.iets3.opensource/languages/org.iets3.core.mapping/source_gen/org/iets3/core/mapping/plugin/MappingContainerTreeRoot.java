package org.iets3.core.mapping.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import org.iets3.core.mapping.behavior.IMappingContainer__BehaviorDescriptor;

public abstract class MappingContainerTreeRoot extends AbstractTreeRoot {
  /*package*/ SNode mapContainer;
  public MappingContainerTreeRoot(SNode map) {
    mapContainer = map;
  }

  protected void computeMapCompletness() {
    boolean changed;
    do {
      changed = computeMappedNodes(this);
    } while (changed);
  }

  private boolean computeMappedNodes(AbstractTreeNode node) {
    boolean changed = false;
    if (!(node.isMapped())) {
      if (!(node.isLeaf())) {
        if (node.isSubTreeMapped()) {
          node.setMapped(true);
          changed = true;
        } else {
          for (AbstractTreeNode child : ListSequence.fromList(node.getChildren())) {
            boolean childrenChanged = computeMappedNodes(child);
            if (!(changed)) {
              changed = childrenChanged;
            }
          }
        }
      }
    } else {
      // node is mapped --> set all their children to mapped
      mapSubtrees(node);
    }
    return changed;
  }

  private void mapSubtrees(final AbstractTreeNode node) {
    node.setMapped(true);
    if (node.isLeaf()) {
      return;
    } else {
      ListSequence.fromList(node.getChildren()).visitAll((it) -> {
        TreeNode child = as_uoiq6x_a0a0a0a0a0a1a7(it, TreeNode.class);
        node.setMapped(true);
        mapSubtrees(child);
      });
    }
  }


  protected void markTree() {
    createPaths();
    markNodes();
  }


  private void markNodes() {
    // will use the impl. from subclass
    final List<String> mappingPaths = getMappingPaths(IMappingContainer__BehaviorDescriptor.mappingSection_id3GbuJrdLq2n.invoke(mapContainer));
    ListSequence.fromList(this.getChildren()).visitAll((it) -> {
      TreeNode node = as_uoiq6x_a0a0a0a0c0n(it, TreeNode.class);
      TreeNode.markNode(node, mappingPaths);
    });
  }

  protected abstract List<String> getMappingPaths(SNode mapSec);

  @Override
  public SNode getValue() {
    return mapContainer;
  }

  private static <T> T as_uoiq6x_a0a0a0a0a0a1a7(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_uoiq6x_a0a0a0a0c0n(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
