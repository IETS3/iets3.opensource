package org.iets3.core.mapping.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;

public class FunctionalComponentsTree extends Tree {

  private FunctionalComponentsTree() {
    // should never be called
  }

  protected FunctionalComponentsTree(SNode mappingContainer) {
    initTree(mappingContainer);
  }

  private void initTree(SNode mappingContainer) {
    this.treeRoot = FunctionalTreeRoot.fromMapping(mappingContainer);
  }

  public boolean isMappingComplete() {
    return getRoot().isMapped();
  }

  public List<String> computeMissingPaths() {
    if (!(isMappingComplete())) {
      return CompletenessHelper.missingPaths(getRoot());
    }
    return ListSequence.fromList(new ArrayList<String>());
  }
  public List<String> computeMissingPaths(AbstractTreeNode treeNode) {
    if (!(isMappingComplete())) {
      return CompletenessHelper.missingPaths(treeNode);
    }
    return ListSequence.fromList(new ArrayList<String>());
  }

  private static class CompletenessHelper {
    public static List<String> missingPaths(AbstractTreeNode node) {
      final List<String> missingPaths = ListSequence.fromList(new ArrayList<String>());
      if (!(node.isLeaf())) {
        ListSequence.fromList(node.getChildren()).visitAll((children) -> {
          if (!(children.isMapped())) {
            ListSequence.fromList(missingPaths).addElement(children.getPath());
          }
          ListSequence.fromList(missingPaths).addSequence(ListSequence.fromList(missingPaths(children)));
        });
      }
      return missingPaths;
    }
  }
}
