package org.iets3.core.expr.typetags.units.plugin;

/*Generated by MPS */

import org.iets3.core.expr.simpleTypes.plugin.SimpleTypesPrimitiveTypeMapper;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.typesystem.inference.SubtypingManager;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.iets3.core.expr.typetags.physunits.plugin.PhysUnitTypeHelper;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import com.google.common.collect.Multimap;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class UnitTypesPrimitiveTypeMapper extends SimpleTypesPrimitiveTypeMapper {

  @Override
  public int getPriorityLevel() {
    return super.getPriorityLevel() + 1;
  }

  /**
   * Computes the supertype with respect to the units in the provided type.
   * Creates runtime error types if not all types will have the same unit or if units types
   * are mixed with non-unit types.
   */
  @Override
  public SNode computeSupertype(List<SNode> types, boolean goToInfinity, SubtypingManager mgr) {
    boolean anyTypeHasAnOldUnit = ListSequence.fromList(types).any((it) -> UnitTypeHelper.hasSingleUnitSpecificationTag(it));
    boolean anyTypeHasANewUnit = ListSequence.fromList(types).any((it) -> PhysUnitTypeHelper.hasSingleUnitSpecificationTag(it));

    if (anyTypeHasAnOldUnit) {
      Iterable<SNode> typesWithUnit = ListSequence.fromList(types).where((it) -> UnitTypeHelper.hasSingleUnitSpecificationTag(it)).select((it) -> SNodeOperations.cast(it, CONCEPTS.TaggedType$O4));

      Multimap<SNode, SNode> unitSpec2TypesMap = UnitTypesPrimitiveTypeMapperHelper.createUnitSpec2TypesMap(typesWithUnit);

      List<SNode> taggedSuperTypes = new ArrayList<SNode>();
      for (SNode unitSpecification : unitSpec2TypesMap.keySet()) {
        Iterable<SNode> typesForUnit = SLinkOperations.collect(unitSpec2TypesMap.get(unitSpecification), LINKS.baseType$z6Mz);
        SNode superBaseType = super.computeSupertype(Sequence.fromIterable(typesForUnit).toList(), goToInfinity, mgr);
        SNode taggedSuperType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x186a8ed9947750b6L, "org.iets3.core.expr.typetags.structure.TaggedType"));
        SLinkOperations.setTarget(taggedSuperType, LINKS.baseType$z6Mz, SNodeOperations.as(superBaseType, CONCEPTS.Type$WK));
        ListSequence.fromList(SLinkOperations.getChildren(taggedSuperType, LINKS.tags$Lx_i)).addElement(SNodeOperations.copyNode(unitSpecification));
        ListSequence.fromList(taggedSuperTypes).addElement(taggedSuperType);
      }

      if (Sequence.fromIterable(typesWithUnit).count() < ListSequence.fromList(types).count()) {
        // not all types have units --> create runtime error type
        Iterable<SNode> typesWithoutUnitSpec = ListSequence.fromList(types).where((it) -> !(UnitTypeHelper.hasSingleUnitSpecificationTag(it)));
        SNode nonUnitsSuperType = super.computeSupertype(Sequence.fromIterable(typesWithoutUnitSpec).toList(), goToInfinity, mgr);
        List<SNode> typesInError = new ArrayList<SNode>();
        ListSequence.fromList(typesInError).addSequence(ListSequence.fromList(taggedSuperTypes));
        ListSequence.fromList(typesInError).addElement(nonUnitsSuperType);
        return UnitTypesPrimitiveTypeMapperHelper.createRuntimeErrorType(typesInError);
      }
      if (ListSequence.fromList(taggedSuperTypes).count() != 1) {
        // if we have multiple unit types, we have an error type 
        return UnitTypesPrimitiveTypeMapperHelper.createRuntimeErrorType(taggedSuperTypes);
      }

      // if we only have a single unit type, return it
      return ListSequence.fromList(taggedSuperTypes).first();

    } else if (anyTypeHasANewUnit) {
      Iterable<SNode> typesWithUnit = ListSequence.fromList(types).where((it) -> PhysUnitTypeHelper.hasSingleUnitSpecificationTag(it)).select((it) -> SNodeOperations.cast(it, CONCEPTS.TaggedType$O4));

      Multimap<SNode, SNode> unitSpec2TypesMap = org.iets3.core.expr.typetags.physunits.plugin.UnitTypesPrimitiveTypeMapperHelper.createUnitSpec2TypesMap(typesWithUnit);

      List<SNode> taggedSuperTypes = new ArrayList<SNode>();
      for (SNode unitSpecification : unitSpec2TypesMap.keySet()) {
        Iterable<SNode> typesForUnit = SLinkOperations.collect(unitSpec2TypesMap.get(unitSpecification), LINKS.baseType$z6Mz);
        SNode superBaseType = super.computeSupertype(Sequence.fromIterable(typesForUnit).toList(), goToInfinity, mgr);
        SNode taggedSuperType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x186a8ed9947750b6L, "org.iets3.core.expr.typetags.structure.TaggedType"));
        SLinkOperations.setTarget(taggedSuperType, LINKS.baseType$z6Mz, SNodeOperations.as(superBaseType, CONCEPTS.Type$WK));
        ListSequence.fromList(SLinkOperations.getChildren(taggedSuperType, LINKS.tags$Lx_i)).addElement(SNodeOperations.copyNode(unitSpecification));
        ListSequence.fromList(taggedSuperTypes).addElement(taggedSuperType);
      }

      if (Sequence.fromIterable(typesWithUnit).count() < ListSequence.fromList(types).count()) {
        // not all types have units --> create runtime error type
        Iterable<SNode> typesWithoutUnitSpec = ListSequence.fromList(types).where((it) -> !(PhysUnitTypeHelper.hasSingleUnitSpecificationTag(it)));
        SNode nonUnitsSuperType = super.computeSupertype(Sequence.fromIterable(typesWithoutUnitSpec).toList(), goToInfinity, mgr);
        List<SNode> typesInError = new ArrayList<SNode>();
        ListSequence.fromList(typesInError).addSequence(ListSequence.fromList(taggedSuperTypes));
        ListSequence.fromList(typesInError).addElement(nonUnitsSuperType);
        return org.iets3.core.expr.typetags.physunits.plugin.UnitTypesPrimitiveTypeMapperHelper.createRuntimeErrorType(typesInError);
      }
      if (ListSequence.fromList(taggedSuperTypes).count() != 1) {
        // if we have multiple unit types, we have an error type 
        return org.iets3.core.expr.typetags.physunits.plugin.UnitTypesPrimitiveTypeMapperHelper.createRuntimeErrorType(taggedSuperTypes);
      }

      // if we only have a single unit type, return it
      return ListSequence.fromList(taggedSuperTypes).first();
    } else {
      return super.computeSupertype(types, goToInfinity, mgr);
    }
  }



  private static final class CONCEPTS {
    /*package*/ static final SConcept TaggedType$O4 = MetaAdapterFactory.getConcept(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x186a8ed9947750b6L, "org.iets3.core.expr.typetags.structure.TaggedType");
    /*package*/ static final SConcept Type$WK = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x670d5e92f854a614L, "org.iets3.core.expr.base.structure.Type");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink baseType$z6Mz = MetaAdapterFactory.getContainmentLink(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x186a8ed9947750b6L, 0x186a8ed9947750b9L, "baseType");
    /*package*/ static final SContainmentLink tags$Lx_i = MetaAdapterFactory.getContainmentLink(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x71bf4701bdf46b3eL, 0x186a8ed9947750b7L, "tags");
  }
}
