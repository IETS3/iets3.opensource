package org.iets3.core.expr.typetags.units.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.BaseHelginsDescriptor;
import jetbrains.mps.lang.typesystem.runtime.InferenceRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.OverloadedOpsProvider_OneTypeSpecified;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.typesystem.inference.SubtypingManager;
import org.iets3.core.expr.typetags.units.plugin.UnitTypeHelper;
import jetbrains.mps.errors.IRuleConflictWarningProducer;
import jetbrains.mps.lang.typesystem.runtime.OverloadedOperationsTypesProvider;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.iets3.core.expr.typetags.units.behavior.UnitConversionUtil;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.iets3.core.expr.simpleTypes.behavior.NumberType__BehaviorDescriptor;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class TypesystemDescriptor extends BaseHelginsDescriptor {
  public TypesystemDescriptor() {
    {
      InferenceRule_Runtime inferenceRule = new typeof_ConvertExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_ConvertToTarget_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_StripUnitExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_ValExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new TypeDefsWithUnits_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_ConversionRule_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_ConversionSpecifier_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_ConvertExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_ConvertToTarget_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_LogExpressionHasNoUnits_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_PowExpressionUnits_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_ProductLoopExpressionHasNoUnits_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_StripUnitExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_b(CONCEPTS.AbsExpression$XP));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a(CONCEPTS.SqrtExpression$QN));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_d(CONCEPTS.PowerExpression$l7));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_e(CONCEPTS.UnaryMinusExpression$Gz));
    {
      OverloadedOpsProvider_OneTypeSpecified provider = new OverloadedOpsProvider_OneTypeSpecified() {
        {
          this.myOperandType = createAbstractTaggedType_3ist9o_a0a0a0a0a0a0a71a0();
          this.myOperationConcept = CONCEPTS.FractionExpression$NO;
          this.myTypeIsExact = false;
          this.myIsStrong = false;
          this.myRuleModelId = "r:bf3cd5a0-eefc-4fd9-b3a6-b57643c9d80c(org.iets3.core.expr.typetags.units.typesystem)";
          this.myRuleNodeId = "7396263120834015294";
        }
        public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
          return TypeChecker.getInstance().getRulesManager().getOperationType(createDivExpression_3ist9o_a0a0a1a0a0a0a0r0a(SNodeOperations.copyNode(SLinkOperations.getTarget(operation, LINKS.numerator$GF9U)), SNodeOperations.copyNode(SLinkOperations.getTarget(operation, LINKS.denominator$GFQX))), leftOperandType, rightOperandType);
        }
        public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
          return UnitTypeHelper.hasSingleUnitSpecificationTag(leftOperandType) || UnitTypeHelper.hasSingleUnitSpecificationTag(rightOperandType);
        }
        @Override
        public void reportConflict(IRuleConflictWarningProducer producer) {
          producer.produceWarning(myRuleModelId, myRuleNodeId);
        }
      };
      this.myOverloadedOperationsTypesProviders.add(provider);
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_b extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_b(SAbstractConcept concept) {
      this.myLeftOperandType = createAbstractTaggedType_3ist9o_a0a0a1();
      this.myRightOperandType = createRealType_3ist9o_a0b0a1();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = true;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:bf3cd5a0-eefc-4fd9-b3a6-b57643c9d80c(org.iets3.core.expr.typetags.units.typesystem)";
      this.myRuleNodeId = "2015716930041590656";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return SNodeOperations.copyNode(leftOperandType);
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return UnitTypeHelper.hasSingleUnitSpecificationTag(leftOperandType);
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createAbstractTaggedType_3ist9o_a0a0a1() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractTaggedType$oL);
      return n0.getResult();
    }
    private static SNode createRealType_3ist9o_a0b0a1() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_a extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_a(SAbstractConcept concept) {
      this.myLeftOperandType = createAbstractTaggedType_3ist9o_a0a0a2();
      this.myRightOperandType = createRealType_3ist9o_a0b0a2();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = true;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:bf3cd5a0-eefc-4fd9-b3a6-b57643c9d80c(org.iets3.core.expr.typetags.units.typesystem)";
      this.myRuleNodeId = "3773364508684704209";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      SNode unitSpecification = SNodeOperations.cast(ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(leftOperandType, CONCEPTS.TaggedType$O4), LINKS.tags$Lx_i)).first(), CONCEPTS.UnitSpecification$DK);
      SNode sqrtUnitSpecification = UnitConversionUtil.sqrt(unitSpecification);
      SNode sqrtExpressionType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x186a8ed9947750b6L, "org.iets3.core.expr.typetags.structure.TaggedType"));
      SLinkOperations.setTarget(sqrtExpressionType, LINKS.baseType$z6Mz, SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x46ff3b3d86d0e74cL, "org.iets3.core.expr.simpleTypes.structure.RealType")));
      ListSequence.fromList(SLinkOperations.getChildren(sqrtExpressionType, LINKS.tags$Lx_i)).addElement(sqrtUnitSpecification);
      return sqrtExpressionType;
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return UnitTypeHelper.hasSingleUnitSpecificationTag(leftOperandType);
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createAbstractTaggedType_3ist9o_a0a0a2() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractTaggedType$oL);
      return n0.getResult();
    }
    private static SNode createRealType_3ist9o_a0b0a2() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_d extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_d(SAbstractConcept concept) {
      this.myLeftOperandType = createAbstractTaggedType_3ist9o_a0a0a3();
      this.myRightOperandType = createNumberType_3ist9o_a0b0a3();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:bf3cd5a0-eefc-4fd9-b3a6-b57643c9d80c(org.iets3.core.expr.typetags.units.typesystem)";
      this.myRuleNodeId = "7396263120839122250";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      SNode unitSpecification = SNodeOperations.cast(ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(leftOperandType, CONCEPTS.TaggedType$O4), LINKS.tags$Lx_i)).first(), CONCEPTS.UnitSpecification$DK);
      int power = Math.toIntExact((long) NumberType__BehaviorDescriptor.intRange_id3p6$WoEzHkL.invoke(SNodeOperations.cast(rightOperandType, CONCEPTS.NumberType$n))._1());

      SNode powUnitSpecification = UnitConversionUtil.pow(unitSpecification, power);

      SNode powExpressionType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x186a8ed9947750b6L, "org.iets3.core.expr.typetags.structure.TaggedType"));
      SLinkOperations.setTarget(powExpressionType, LINKS.baseType$z6Mz, SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x46ff3b3d86d0e74cL, "org.iets3.core.expr.simpleTypes.structure.RealType")));
      ListSequence.fromList(SLinkOperations.getChildren(powExpressionType, LINKS.tags$Lx_i)).addElement(powUnitSpecification);
      return powExpressionType;

    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      Tuples._2<Long, Long> intRange = NumberType__BehaviorDescriptor.intRange_id3p6$WoEzHkL.invoke(SNodeOperations.cast(rightOperandType, CONCEPTS.NumberType$n));
      boolean rangeIsValue = MathExpressionsOpRulesHelper.rangeIsValue(SNodeOperations.cast(rightOperandType, CONCEPTS.NumberType$n));
      if (rangeIsValue) {
        boolean isIntValue = MathExpressionsOpRulesHelper.isIntValue((long) intRange._0());
        boolean hasSingleUnitSpecificationTag = UnitTypeHelper.hasSingleUnitSpecificationTag(leftOperandType);
        return isIntValue && hasSingleUnitSpecificationTag;
      }
      return false;
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createAbstractTaggedType_3ist9o_a0a0a3() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractTaggedType$oL);
      return n0.getResult();
    }
    private static SNode createNumberType_3ist9o_a0b0a3() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.NumberType$n);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_e extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_e(SAbstractConcept concept) {
      this.myLeftOperandType = createAbstractTaggedType_3ist9o_a0a0a4();
      this.myRightOperandType = createBaseConcept_3ist9o_a0b0a4();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:bf3cd5a0-eefc-4fd9-b3a6-b57643c9d80c(org.iets3.core.expr.typetags.units.typesystem)";
      this.myRuleNodeId = "8208891105595369331";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      SNode taggedType = SNodeOperations.cast(leftOperandType, CONCEPTS.TaggedType$O4);
      SNode negatedBaseType = TypeChecker.getInstance().getRulesManager().getOperationType(operation, SLinkOperations.getTarget(taggedType, LINKS.baseType$z6Mz), rightOperandType);
      SNode negatedTagedType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x186a8ed9947750b6L, "org.iets3.core.expr.typetags.structure.TaggedType"));
      ListSequence.fromList(SLinkOperations.getChildren(negatedTagedType, LINKS.tags$Lx_i)).addSequence(ListSequence.fromList(SLinkOperations.getChildren(taggedType, LINKS.tags$Lx_i)).select((it) -> SNodeOperations.copyNode(it)));
      if (SNodeOperations.isInstanceOf(negatedBaseType, CONCEPTS.Type$WK)) {
        // if the negated base type is not a type, the typesystem will issue an error later
        SLinkOperations.setTarget(negatedTagedType, LINKS.baseType$z6Mz, SNodeOperations.cast(negatedBaseType, CONCEPTS.Type$WK));
      }
      return negatedTagedType;
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return UnitTypeHelper.hasSingleUnitSpecificationTag(leftOperandType);
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createAbstractTaggedType_3ist9o_a0a0a4() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractTaggedType$oL);
      return n0.getResult();
    }
    private static SNode createBaseConcept_3ist9o_a0b0a4() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BaseConcept$gP);
      return n0.getResult();
    }
  }
  private static SNode createAbstractTaggedType_3ist9o_a0a0a0a0a0a0a71a0() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.AbstractTaggedType$oL);
    return n0.getResult();
  }
  private static SNode createDivExpression_3ist9o_a0a0a1a0a0a0a0r0a(SNode p0, SNode p1) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.DivExpression$us);
    n0.forChild(LINKS.left$zxUa).initNode(p0, CONCEPTS.Expression$D_, true);
    n0.forChild(LINKS.right$zBjx).initNode(p1, CONCEPTS.Expression$D_, true);
    return n0.getResult();
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept AbsExpression$XP = MetaAdapterFactory.getConcept(0x6fadc44e69c24a4aL, 0x9d167ebf5f8d3ba0L, 0x449e19d04e9bc799L, "org.iets3.core.expr.math.structure.AbsExpression");
    /*package*/ static final SConcept SqrtExpression$QN = MetaAdapterFactory.getConcept(0x6fadc44e69c24a4aL, 0x9d167ebf5f8d3ba0L, 0x449e19d04e9c8de8L, "org.iets3.core.expr.math.structure.SqrtExpression");
    /*package*/ static final SConcept PowerExpression$l7 = MetaAdapterFactory.getConcept(0x6fadc44e69c24a4aL, 0x9d167ebf5f8d3ba0L, 0x449e19d04e9c6144L, "org.iets3.core.expr.math.structure.PowerExpression");
    /*package*/ static final SConcept UnaryMinusExpression$Gz = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cdddbbL, "org.iets3.core.expr.base.structure.UnaryMinusExpression");
    /*package*/ static final SConcept FractionExpression$NO = MetaAdapterFactory.getConcept(0x6fadc44e69c24a4aL, 0x9d167ebf5f8d3ba0L, 0x449e19d04e9bcd46L, "org.iets3.core.expr.math.structure.FractionExpression");
    /*package*/ static final SConcept AbstractTaggedType$oL = MetaAdapterFactory.getConcept(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x4b61610d29e578f2L, "org.iets3.core.expr.typetags.structure.AbstractTaggedType");
    /*package*/ static final SConcept RealType$36 = MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x46ff3b3d86d0e74cL, "org.iets3.core.expr.simpleTypes.structure.RealType");
    /*package*/ static final SConcept TaggedType$O4 = MetaAdapterFactory.getConcept(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x186a8ed9947750b6L, "org.iets3.core.expr.typetags.structure.TaggedType");
    /*package*/ static final SConcept UnitSpecification$DK = MetaAdapterFactory.getConcept(0xcb91a38e738a4811L, 0xa96d448d08f526faL, 0x73b48a125b0d411dL, "org.iets3.core.expr.typetags.units.structure.UnitSpecification");
    /*package*/ static final SConcept NumberType$n = MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x7211e50064d40ea8L, "org.iets3.core.expr.simpleTypes.structure.NumberType");
    /*package*/ static final SConcept Type$WK = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x670d5e92f854a614L, "org.iets3.core.expr.base.structure.Type");
    /*package*/ static final SConcept BaseConcept$gP = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept");
    /*package*/ static final SConcept DivExpression$us = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cac63bL, "org.iets3.core.expr.base.structure.DivExpression");
    /*package*/ static final SConcept Expression$D_ = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x670d5e92f854a047L, "org.iets3.core.expr.base.structure.Expression");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink numerator$GF9U = MetaAdapterFactory.getContainmentLink(0x6fadc44e69c24a4aL, 0x9d167ebf5f8d3ba0L, 0x449e19d04e9bcd46L, 0x449e19d04e9bcd47L, "numerator");
    /*package*/ static final SContainmentLink denominator$GFQX = MetaAdapterFactory.getContainmentLink(0x6fadc44e69c24a4aL, 0x9d167ebf5f8d3ba0L, 0x449e19d04e9bcd46L, 0x449e19d04e9bcd4aL, "denominator");
    /*package*/ static final SContainmentLink tags$Lx_i = MetaAdapterFactory.getContainmentLink(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x71bf4701bdf46b3eL, 0x186a8ed9947750b7L, "tags");
    /*package*/ static final SContainmentLink baseType$z6Mz = MetaAdapterFactory.getContainmentLink(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x186a8ed9947750b6L, 0x186a8ed9947750b9L, "baseType");
    /*package*/ static final SContainmentLink left$zxUa = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86c99c15L, 0x46ff3b3d86c99c16L, "left");
    /*package*/ static final SContainmentLink right$zBjx = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86c99c15L, 0x46ff3b3d86c99c18L, "right");
  }
}
