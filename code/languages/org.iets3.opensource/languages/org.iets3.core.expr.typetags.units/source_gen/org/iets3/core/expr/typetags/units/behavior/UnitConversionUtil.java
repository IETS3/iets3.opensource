package org.iets3.core.expr.typetags.units.behavior;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import java.util.Map;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.iets3.core.expr.typetags.behavior.BaseTaggedTypeHelper;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.iets3.core.expr.base.runtime.runtime.Fraction;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import com.mbeddr.core.base.behavior.IDetectCycle__BehaviorDescriptor;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import java.util.LinkedList;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.iets3.core.expr.simpleTypes.behavior.NumberLiteral__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class UnitConversionUtil {

  public static SNode getUnitSpecification(SNode type) {
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.TaggedType$O4)) {
      Tuples._2<SNode, Map<SAbstractConcept, SNode>> components = BaseTaggedTypeHelper.getComponents(type);
      Map<SAbstractConcept, SNode> tagMap = components._1();
      SNode tag = tagMap.get(CONCEPTS.UnitSpecification$DK);
      return SNodeOperations.as(tag, CONCEPTS.UnitSpecification$DK);
    } else {
      return null;
    }
  }

  public static boolean hasUnitSpecification(SNode type) {
    return getUnitSpecification(type) != null;
  }

  public static boolean isAtomicUnit(SNode unit) {
    List<SNode> components = ISpecification__BehaviorDescriptor.components_id1KUmgSF_6Sp.invoke(IUnit__BehaviorDescriptor.specification_id1KUmgSF_6QP.invoke(unit));
    return components == null || ListSequence.fromList(components).isEmpty();
  }

  public static boolean isIntegerType(SNode type) {
    SNode innerType = getInnerType(type);
    if (SNodeOperations.isInstanceOf(innerType, CONCEPTS.MeetType$ZG)) {
      return ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(innerType, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).any((it) -> isIntegerType(it));
    } else {
      return SNodeOperations.isInstanceOf(innerType, CONCEPTS.IntegerType$7a);
    }
  }

  public static SNode getInnerType(SNode type) {
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.TaggedType$O4)) {
      return SNodeOperations.copyNode(SLinkOperations.getTarget(SNodeOperations.cast(type, CONCEPTS.TaggedType$O4), LINKS.baseType$z6Mz));
    } else {
      return SNodeOperations.copyNode(type);
    }
  }

  /**
   * Returns true if the given map represents a unitless mapping, 
   * meaning the map is empty or null. 
   * 
   * @param unitMap the unit mapping
   * @return true if the mapping represents a unitless mapping, false otherwise
   */
  public static boolean isUnitLessType(Map<SNode, Fraction> unitMap) {
    if (unitMap == null || MapSequence.fromMap(unitMap).isEmpty()) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * Returns true of the given type is a unitless type. 
   * 
   * @param type the type
   * @return true if the type has no unit annotation, false otherwise
   */
  public static boolean isUnitLessType(SNode type) {
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.TaggedType$O4)) {
      SNode specification = getUnitSpecification(type);
      Map<SNode, Fraction> spec = getUnitMap_UnitSpecification(specification);
      return MapSequence.fromMap(spec).isEmpty();
    } else {
      return true;
    }
  }

  /**
   * Returns the unit mapping for the given type. 
   * If the given type is not an annotated type then an empty map will be returned. 
   * 
   * @param type the type
   * @return the unit mapping
   */
  public static Map<SNode, Fraction> getUnitMap_Type(SNode type) {
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.TaggedType$O4)) {
      SNode specification = getUnitSpecification(type);
      return getUnitMap_UnitSpecification(specification);
    } else {
      return Collections.<SNode,Fraction>emptyMap();
    }
  }

  public static boolean isSelfReferencingUnit(SNode unit) {
    return SetSequence.fromSet(IDetectCycle__BehaviorDescriptor.getCyclicDependencyElements_id17fjvcLFUH5.invoke(unit)).contains(unit);
  }

  /**
   * Generates the unit mapping from the given unit specification, no meta unit resolving is applied. 
   * Composite units are always broken down to atomic units. 
   * 
   * This method returns a new unit mapping. 
   */
  public static Map<SNode, Fraction> getUnitMap_UnitSpecification(SNode specification) {
    Map<SNode, Fraction> result = MapSequence.fromMap(new HashMap<SNode, Fraction>());
    if ((boolean) IDetectCycle__BehaviorDescriptor.isInvolvedInCycle_id59HbAIOYtvQ.invoke(SNodeOperations.as(SNodeOperations.getParent(specification), CONCEPTS.Unit$fR))) {
      return result;
    }
    for (SNode reference : ListSequence.fromList(SLinkOperations.getChildren(specification, LINKS.components$SDyb))) {
      result = unify(result, getUnitMap_UnitReference(reference, getExponent(reference)));
    }
    return result;
  }

  /**
   * Generates the unit mapping from the given unit reference and multiplies all the exponents with the given one. 
   * Composite units are always broken down to atomic units. 
   * 
   * This method returns a new unit mapping. 
   */
  public static Map<SNode, Fraction> getUnitMap_UnitReference(SNode reference, Fraction exponent) {
    Map<SNode, Fraction> result = MapSequence.fromMap(new HashMap<SNode, Fraction>());
    Set<SNode> seenUnits = SetSequence.fromSet(new HashSet<SNode>());

    Queue<Tuples._2<SNode, Fraction>> queue = QueueSequence.fromQueue(new LinkedList<Tuples._2<SNode, Fraction>>());
    QueueSequence.fromQueue(queue).addLastElement(MultiTuple.<SNode,Fraction>from(reference, exponent));

    while (QueueSequence.fromQueue(queue).isNotEmpty()) {
      Tuples._2<SNode, Fraction> headPair = QueueSequence.fromQueue(queue).removeFirstElement();
      SNode headReference = headPair._0();
      Fraction headExponent = headPair._1();
      SetSequence.fromSet(seenUnits).addElement(SLinkOperations.getTarget(headReference, LINKS.unit$3rM9));

      List<SNode> components = ISpecification__BehaviorDescriptor.components_id1KUmgSF_6Sp.invoke(IUnit__BehaviorDescriptor.specification_id1KUmgSF_6QP.invoke(SLinkOperations.getTarget(headReference, LINKS.unit$3rM9)));
      if (components == null || ListSequence.fromList(components).isEmpty()) {
        result = unify_inplace(result, SLinkOperations.getTarget(headReference, LINKS.unit$3rM9), headExponent);
      } else if (!((boolean) IDetectCycle__BehaviorDescriptor.isInvolvedInCycle_id59HbAIOYtvQ.invoke(SLinkOperations.getTarget(headReference, LINKS.unit$3rM9)))) {
        for (SNode component : ListSequence.fromList(components)) {
          QueueSequence.fromQueue(queue).addLastElement(MultiTuple.<SNode,Fraction>from(component, getExponent(component).multiply(headExponent)));
        }
      }
    }

    return result;
  }

  /**
   * Generates the unit mapping from the given unit and multiplies all the exponents with the given one. 
   * Composite units are always broken down to atomic units. 
   * 
   * This method returns a new unit mapping. 
   */
  public static Map<SNode, Fraction> getUnitMap_IUnit(SNode unit, Fraction exponent) {
    Map<SNode, Fraction> result = MapSequence.fromMap(new HashMap<SNode, Fraction>());
    if ((boolean) IDetectCycle__BehaviorDescriptor.isInvolvedInCycle_id59HbAIOYtvQ.invoke(unit)) {
      return result;
    }

    List<SNode> components = ISpecification__BehaviorDescriptor.components_id1KUmgSF_6Sp.invoke(IUnit__BehaviorDescriptor.specification_id1KUmgSF_6QP.invoke(unit));
    if (components == null || ListSequence.fromList(components).isEmpty()) {
      MapSequence.fromMap(result).put(unit, exponent);
    } else {
      for (SNode component : ListSequence.fromList(components)) {
        result = unify(result, getUnitMap_UnitReference(component, getExponent(component).multiply(exponent)));
      }
    }
    return result;
  }

  public static Map<SNode, Fraction> getUnitMap_IUnit(SNode unit, int exponent) {
    return getUnitMap_IUnit(unit, new Fraction(exponent));
  }


  public static Fraction getExponent(SNode reference) {
    if (SLinkOperations.getTarget(reference, LINKS.exponent$3sgb) == null) {
      return new Fraction(1);
    } else {
      return new Fraction((int) Exponent__BehaviorDescriptor.getNumerator_id3j3yk3guAC3.invoke(SLinkOperations.getTarget(reference, LINKS.exponent$3sgb)), (int) Exponent__BehaviorDescriptor.getDenumerator_id3j3yk3guABz.invoke(SLinkOperations.getTarget(reference, LINKS.exponent$3sgb)));
    }
  }

  /**
   * Divides all of the exponents in the unit mapping with the given value if it is possible.
   * As fractions are used in their minimal form this can only be possible if two fractions 
   * have the exact same denumerator and the modulo check should be performed with their numerators. 
   * 
   * This method returns a new unit mapping. 
   */
  public static Map<SNode, Fraction> rootBy(Map<SNode, Fraction> unitMap, SNode root) {
    Map<SNode, Fraction> result = MapSequence.fromMap(new HashMap<SNode, Fraction>());
    Fraction rootFraction = new Fraction((int) Exponent__BehaviorDescriptor.getNumerator_id3j3yk3guAC3.invoke(root), (int) Exponent__BehaviorDescriptor.getDenumerator_id3j3yk3guABz.invoke(root));

    for (SNode key : SetSequence.fromSet(MapSequence.fromMap(unitMap).keySet())) {
      MapSequence.fromMap(result).put(key, MapSequence.fromMap(unitMap).get(key).divide(rootFraction));
    }

    return result;
  }

  /**
   * Reduces the given unit mapping with an other unit mapping. This means that all of the exponents will be 
   * substracted in the unit mapping with the corresponding exponent from the other mapping. If a unit is 
   * not present in the original mapping, then the inverse exponent of the other mapping's unit will be inserted. 
   * Units with zero exponents are eliminated from the resuling unit mapping. 
   * 
   * This method returns a new unit mapping. 
   */
  public static Map<SNode, Fraction> reduceBy(Map<SNode, Fraction> unitMap, Map<SNode, Fraction> withWhom) {
    Map<SNode, Fraction> result = MapSequence.fromMap(new HashMap<SNode, Fraction>());
    MapSequence.fromMap(result).putAll(unitMap);

    for (SNode key : SetSequence.fromSet(MapSequence.fromMap(withWhom).keySet())) {
      if (MapSequence.fromMap(result).containsKey(key)) {
        // rule out zero exponents
        if (MapSequence.fromMap(result).get(key).equals(MapSequence.fromMap(withWhom).get(key))) {
          MapSequence.fromMap(result).removeKey(key);
        } else {
          MapSequence.fromMap(result).put(key, MapSequence.fromMap(result).get(key).subtract(MapSequence.fromMap(withWhom).get(key)));
        }
      } else if (MapSequence.fromMap(withWhom).get(key).isNonZero()) {
        MapSequence.fromMap(result).put(key, MapSequence.fromMap(withWhom).get(key).multiply(-1));
      }
    }

    return result;
  }

  /**
   * Unifies the given unit mapping with an other unit mapping. This means that all of the exponents will be 
   * summed in the unit mapping with the corresponding exponent from the other mapping. If a unit is not 
   * present in the original mapping, then the exponent of the other mapping's unit will be inserted. 
   * Units with zero exponents are eliminated from the resuling unit mapping. 
   * 
   * This method returns a new unit mapping. 
   */
  public static Map<SNode, Fraction> unify(Map<SNode, Fraction> m1, Map<SNode, Fraction> m2) {
    Map<SNode, Fraction> res = MapSequence.fromMap(new HashMap<SNode, Fraction>());
    MapSequence.fromMap(res).putAll(m1);
    for (SNode key : SetSequence.fromSet(MapSequence.fromMap(m2).keySet())) {
      res = unify_inplace(res, key, MapSequence.fromMap(m2).get(key));
    }
    return res;
  }

  private static Map<SNode, Fraction> unify_inplace(Map<SNode, Fraction> mapping, SNode key, Fraction exponent) {
    if (MapSequence.fromMap(mapping).containsKey(key)) {
      // rule out zero exponents
      if (MapSequence.fromMap(mapping).get(key).equals(exponent.multiply(-1))) {
        MapSequence.fromMap(mapping).removeKey(key);
      } else {
        MapSequence.fromMap(mapping).put(key, MapSequence.fromMap(mapping).get(key).add(exponent));
      }
    } else if (exponent.isNonZero()) {
      MapSequence.fromMap(mapping).put(key, exponent);
    }
    return mapping;
  }

  /**
   * It is expected that the passed map is already broken down to atomic units. 
   */
  public static List<SNode> createUnitReferences(Map<SNode, Fraction> unitMap) {
    List<SNode> references = ListSequence.fromList(new ArrayList<SNode>());
    for (IMapping<SNode, Fraction> entry : MapSequence.fromMap(unitMap)) {
      ListSequence.fromList(references).addElement(createUnitReference(entry.key(), entry.value()));
    }
    return references;
  }

  public static SNode createUnitReference(SNode unit, Fraction exp) {
    SNode reference = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xcb91a38e738a4811L, 0xa96d448d08f526faL, 0x73b48a125b0d4dc5L, "org.iets3.core.expr.typetags.units.structure.UnitReference"));
    SLinkOperations.setTarget(reference, LINKS.unit$3rM9, unit);

    // only insert the exponent if it does not equal to 1
    if (!(exp.equals(Fraction.ONE))) {
      if (exp.denominator == 1) {
        SLinkOperations.setTarget(reference, LINKS.exponent$3sgb, createIntegerExponent_5ohk72_a0a0a0e0ob(exp.numerator));
      } else {
        SLinkOperations.setTarget(reference, LINKS.exponent$3sgb, createFractionalExponent_5ohk72_a0a0a0a4a04(NumberLiteral__BehaviorDescriptor.set_id2oUyrt$Tg3c.invoke(SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x46ff3b3d86d0e6daL, "org.iets3.core.expr.simpleTypes.structure.NumberLiteral")), "" + exp.numerator), NumberLiteral__BehaviorDescriptor.set_id2oUyrt$Tg3c.invoke(SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x46ff3b3d86d0e6daL, "org.iets3.core.expr.simpleTypes.structure.NumberLiteral")), "" + exp.denominator)));
      }
    }
    return reference;
  }

  public static Map<SNode, Fraction> negate(Map<SNode, Fraction> unitMap) {
    for (SNode key : SetSequence.fromSet(MapSequence.fromMap(unitMap).keySet())) {
      MapSequence.fromMap(unitMap).put(key, MapSequence.fromMap(unitMap).get(key).multiply(-1));
    }
    return unitMap;
  }

  /**
   * This method modifies the original unit mapping. 
   */
  public static Map<SNode, Fraction> multiply(Map<SNode, Fraction> unitMap, Fraction m) {
    for (SNode key : SetSequence.fromSet(MapSequence.fromMap(unitMap).keySet())) {
      MapSequence.fromMap(unitMap).put(key, MapSequence.fromMap(unitMap).get(key).multiply(m));
    }
    return unitMap;
  }

  /**
   * Checks wether two unit mappings can be possibly matched / exactly matched. 
   * 
   * In case of exact match check the unit mappings must be entirely the same.
   */
  public static Tuples._2<Boolean, Iterable<SNode>> matchingUnits(Map<SNode, Fraction> leftUnitMap, Map<SNode, Fraction> rightUnitMap) {
    if (leftUnitMap == null && rightUnitMap == null) {
      return MultiTuple.<Boolean,Iterable<SNode>>from(true, Sequence.fromIterable(Collections.<SNode>emptyList()));
    }

    // remove units with zero exponents
    Map<UnitWrapper, Fraction> leftNonMatched = MapSequence.fromMap(new HashMap<UnitWrapper, Fraction>());
    Set<UnitWrapper> keys = SetSequence.fromSet(new HashSet<UnitWrapper>());

    for (SNode key : SetSequence.fromSet(MapSequence.fromMap(leftUnitMap).keySet())) {
      if (MapSequence.fromMap(leftUnitMap).get(key).isNonZero()) {
        UnitWrapper wrapper = new UnitWrapper(key);
        MapSequence.fromMap(leftNonMatched).put(wrapper, MapSequence.fromMap(leftUnitMap).get(key));
        SetSequence.fromSet(keys).addElement(wrapper);
      }
    }

    Map<UnitWrapper, Fraction> rightNonMatched = MapSequence.fromMap(new HashMap<UnitWrapper, Fraction>());
    for (SNode key : SetSequence.fromSet(MapSequence.fromMap(rightUnitMap).keySet())) {
      if (MapSequence.fromMap(rightUnitMap).get(key).isNonZero()) {
        MapSequence.fromMap(rightNonMatched).put(new UnitWrapper(key), MapSequence.fromMap(rightUnitMap).get(key));
      }
    }

    for (UnitWrapper key : SetSequence.fromSet(keys)) {
      if (MapSequence.fromMap(leftNonMatched).containsKey(key) && MapSequence.fromMap(rightNonMatched).containsKey(key)) {
        Fraction le = MapSequence.fromMap(leftNonMatched).get(key);
        Fraction re = MapSequence.fromMap(rightNonMatched).get(key);
        int c = le.compareTo(re);

        if (c == 0) {
          MapSequence.fromMap(leftNonMatched).removeKey(key);
          MapSequence.fromMap(rightNonMatched).removeKey(key);
        } else if (c < 0) {
          MapSequence.fromMap(leftNonMatched).removeKey(key);
          MapSequence.fromMap(rightNonMatched).put(key, re.subtract(le));
        } else {
          MapSequence.fromMap(rightNonMatched).removeKey(key);
          MapSequence.fromMap(leftNonMatched).put(key, le.subtract(re));
        }
      }
    }
    return MultiTuple.<Boolean,Iterable<SNode>>from(MapSequence.fromMap(leftNonMatched).isEmpty() && MapSequence.fromMap(rightNonMatched).isEmpty(), SetSequence.fromSet(MapSequence.fromMap(leftNonMatched).keySet()).select((it) -> it.unit).concat(SetSequence.fromSet(MapSequence.fromMap(rightNonMatched).keySet()).select((it) -> it.unit)));
  }


  /**
   * Calculates the sqrt of the units within the provided UnitSpecification and returns a new UnitSpecification.
   */
  public static SNode sqrt(SNode unitSpecificaion) {
    Map<SNode, Fraction> originalUnitMap = getUnitMap_UnitSpecification(unitSpecificaion);
    final Map<SNode, Fraction> sqrtUnitMap = MapSequence.fromMap(new HashMap<SNode, Fraction>());

    MapSequence.fromMap(originalUnitMap).visitAll((it) -> MapSequence.fromMap(sqrtUnitMap).put(it.key(), it.value().sqrt()));

    return createUnitSpecification(sqrtUnitMap);
  }


  public static SNode pow(SNode unitSpecification, final int power) {
    Map<SNode, Fraction> originalUnitMap = getUnitMap_UnitSpecification(unitSpecification);
    final Map<SNode, Fraction> powUnitMap = MapSequence.fromMap(new HashMap<SNode, Fraction>());

    MapSequence.fromMap(originalUnitMap).visitAll((it) -> MapSequence.fromMap(powUnitMap).put(it.key(), it.value().pow(power)));

    return createUnitSpecification(powUnitMap);
  }

  private static SNode createUnitSpecification(Map<SNode, Fraction> unitMap) {
    List<SNode> unitRefs = createUnitReferences(unitMap);
    SNode newUnitSpecifciation = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xcb91a38e738a4811L, 0xa96d448d08f526faL, 0x73b48a125b0d411dL, "org.iets3.core.expr.typetags.units.structure.UnitSpecification"));
    ListSequence.fromList(SLinkOperations.getChildren(newUnitSpecifciation, LINKS.components$SDyb)).addSequence(ListSequence.fromList(unitRefs));
    return newUnitSpecifciation;
  }
  private static SNode createIntegerExponent_5ohk72_a0a0a0e0ob(int p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.IntegerExponent$Hv);
    n0.setProperty(PROPS.value$vsHL, "" + (p0));
    return n0.getResult();
  }
  private static SNode createFractionalExponent_5ohk72_a0a0a0a4a04(SNode p0, SNode p1) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.FractionalExponent$hx);
    {
      SNodeBuilder n1 = n0.forChild(LINKS.fraction$uM6j).init(CONCEPTS.FractionExpression$NO);
      n1.forChild(LINKS.numerator$GF9U).initNode(p0, CONCEPTS.Expression$D_, true);
      n1.forChild(LINKS.denominator$GFQX).initNode(p1, CONCEPTS.Expression$D_, true);
    }
    return n0.getResult();
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept TaggedType$O4 = MetaAdapterFactory.getConcept(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x186a8ed9947750b6L, "org.iets3.core.expr.typetags.structure.TaggedType");
    /*package*/ static final SConcept UnitSpecification$DK = MetaAdapterFactory.getConcept(0xcb91a38e738a4811L, 0xa96d448d08f526faL, 0x73b48a125b0d411dL, "org.iets3.core.expr.typetags.units.structure.UnitSpecification");
    /*package*/ static final SConcept MeetType$ZG = MetaAdapterFactory.getConcept(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x114b68ad132L, "jetbrains.mps.lang.typesystem.structure.MeetType");
    /*package*/ static final SConcept IntegerType$7a = MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940d22479L, "jetbrains.mps.baseLanguage.structure.IntegerType");
    /*package*/ static final SConcept Unit$fR = MetaAdapterFactory.getConcept(0xcb91a38e738a4811L, 0xa96d448d08f526faL, 0x73b48a125b0d373fL, "org.iets3.core.expr.typetags.units.structure.Unit");
    /*package*/ static final SConcept IntegerExponent$Hv = MetaAdapterFactory.getConcept(0xcb91a38e738a4811L, 0xa96d448d08f526faL, 0x73b48a125b0d4dc6L, "org.iets3.core.expr.typetags.units.structure.IntegerExponent");
    /*package*/ static final SConcept FractionalExponent$hx = MetaAdapterFactory.getConcept(0xcb91a38e738a4811L, 0xa96d448d08f526faL, 0x34c38940d09904b9L, "org.iets3.core.expr.typetags.units.structure.FractionalExponent");
    /*package*/ static final SConcept FractionExpression$NO = MetaAdapterFactory.getConcept(0x6fadc44e69c24a4aL, 0x9d167ebf5f8d3ba0L, 0x449e19d04e9bcd46L, "org.iets3.core.expr.math.structure.FractionExpression");
    /*package*/ static final SConcept Expression$D_ = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x670d5e92f854a047L, "org.iets3.core.expr.base.structure.Expression");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink argument$r2cT = MetaAdapterFactory.getContainmentLink(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x114b68ad132L, 0x114b68b040bL, "argument");
    /*package*/ static final SContainmentLink baseType$z6Mz = MetaAdapterFactory.getContainmentLink(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x186a8ed9947750b6L, 0x186a8ed9947750b9L, "baseType");
    /*package*/ static final SContainmentLink components$SDyb = MetaAdapterFactory.getContainmentLink(0xcb91a38e738a4811L, 0xa96d448d08f526faL, 0x73b48a125b0d411dL, 0x73b48a125b0dab03L, "components");
    /*package*/ static final SReferenceLink unit$3rM9 = MetaAdapterFactory.getReferenceLink(0xcb91a38e738a4811L, 0xa96d448d08f526faL, 0x73b48a125b0d4dc5L, 0x73b48a125b0daafcL, "unit");
    /*package*/ static final SContainmentLink exponent$3sgb = MetaAdapterFactory.getContainmentLink(0xcb91a38e738a4811L, 0xa96d448d08f526faL, 0x73b48a125b0d4dc5L, 0x73b48a125b0daafeL, "exponent");
    /*package*/ static final SContainmentLink fraction$uM6j = MetaAdapterFactory.getContainmentLink(0xcb91a38e738a4811L, 0xa96d448d08f526faL, 0x34c38940d09904b9L, 0x34c38940d09979deL, "fraction");
    /*package*/ static final SContainmentLink numerator$GF9U = MetaAdapterFactory.getContainmentLink(0x6fadc44e69c24a4aL, 0x9d167ebf5f8d3ba0L, 0x449e19d04e9bcd46L, 0x449e19d04e9bcd47L, "numerator");
    /*package*/ static final SContainmentLink denominator$GFQX = MetaAdapterFactory.getContainmentLink(0x6fadc44e69c24a4aL, 0x9d167ebf5f8d3ba0L, 0x449e19d04e9bcd46L, 0x449e19d04e9bcd4aL, "denominator");
  }

  private static final class PROPS {
    /*package*/ static final SProperty value$vsHL = MetaAdapterFactory.getProperty(0xcb91a38e738a4811L, 0xa96d448d08f526faL, 0x73b48a125b0d4dc6L, 0x73b48a125b0d4dc7L, "value");
  }
}
