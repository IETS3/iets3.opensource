package org.iets3.components.core.constraints;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.base.BaseConstraintsDescriptor;
import jetbrains.mps.smodel.runtime.ConstraintFunction;
import jetbrains.mps.smodel.runtime.ConstraintContext_CanBeChild;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.runtime.CheckingNodeContext;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.iets3.core.expr.base.behavior.IContextTypeProvider__BehaviorDescriptor;
import jetbrains.mps.typechecking.TypecheckingFacade;
import org.iets3.core.base.behavior.ITypeWithTarget__BehaviorDescriptor;
import org.iets3.components.core.behavior.IKindContext__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.iets3.components.core.behavior.IKindSpecificAttribute__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.SNodePointer;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class IKindSpecificAttribute_Constraints extends BaseConstraintsDescriptor {
  public IKindSpecificAttribute_Constraints() {
    super(CONCEPTS.IKindSpecificAttribute$ly);
  }

  @Override
  protected ConstraintFunction<ConstraintContext_CanBeChild, Boolean> calculateCanBeChildConstraint() {
    return new ConstraintFunction<ConstraintContext_CanBeChild, Boolean>() {
      @NotNull
      public Boolean invoke(@NotNull ConstraintContext_CanBeChild context, @Nullable CheckingNodeContext checkingNodeContext) {
        boolean result = staticCanBeAChild(context.getNode(), context.getParentNode(), context.getConcept(), context.getLink());

        if (!(result) && checkingNodeContext != null) {
          checkingNodeContext.setBreakingNode(canBeChildBreakingPoint);
        }

        return result;
      }
    };
  }
  private static boolean staticCanBeAChild(SNode node, SNode parentNode, SAbstractConcept childConcept, SContainmentLink link) {
    // constraint should work in typeProvider
    SNode ctxTypeProvider = SNodeOperations.getNodeAncestor(parentNode, CONCEPTS.IContextTypeProvider$Ib, true, false);
    if ((ctxTypeProvider != null)) {
      SNode contextTypeNode = IContextTypeProvider__BehaviorDescriptor.getTypedContextNode_id4fgA7QrKR89.invoke(ctxTypeProvider);
      SNode contextType = TypecheckingFacade.getFromContext().getTypeOf(contextTypeNode);

      {
        final SNode itypeWithTarget = contextType;
        if (SNodeOperations.isInstanceOf(itypeWithTarget, CONCEPTS.ITypeWithTarget$mU)) {
          SNode target = ITypeWithTarget__BehaviorDescriptor.getTarget_id3QX5db_zS9H.invoke(itypeWithTarget);
          //  target itself (like the component) can be IKindContext
          // if not it will take the next ancestor as IKindContext
          SNode kindContext = SNodeOperations.getNodeAncestor(target, CONCEPTS.IKindContext$DQ, true, false);
          if ((kindContext != null)) {
            SNode specifiedKind = IKindContext__BehaviorDescriptor.specifiedKind_id6LfBX8Yl7t8.invoke(kindContext);
            Iterable<SConcept> allowedKindConcepts = Sequence.fromIterable(IKindSpecificAttribute__BehaviorDescriptor.allowedKinds_id68KkV783QPs.invoke(SNodeOperations.asSConcept(SNodeOperations.castConcept(childConcept, CONCEPTS.IKindSpecificAttribute$ly)))).select((it) -> SNodeOperations.getConcept(it));
            final SConcept kindConcept = SNodeOperations.getConcept(specifiedKind);

            return Sequence.fromIterable(allowedKindConcepts).any((it) -> SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(kindConcept), SNodeOperations.asSConcept(it)) || SConceptOperations.isExactly(SNodeOperations.asSConcept(kindConcept), SNodeOperations.asSConcept(it)));
          }
        }
      }
    }

    // fallback: ask the IKindContext directly if this attribute is allowed
    SNode kindContext = SNodeOperations.getNodeAncestor(parentNode, CONCEPTS.IKindContext$DQ, true, false);
    if ((kindContext != null)) {
      SNode specifiedKind = IKindContext__BehaviorDescriptor.specifiedKind_id6LfBX8Yl7t8.invoke(kindContext);
      return Sequence.fromIterable(IKindSpecificAttribute__BehaviorDescriptor.allowedKinds_id68KkV783QPs.invoke(SNodeOperations.asSConcept(SNodeOperations.castConcept(childConcept, CONCEPTS.IKindSpecificAttribute$ly)))).contains(specifiedKind);
    }
    return false;
  }
  private static final SNodePointer canBeChildBreakingPoint = new SNodePointer("r:a9d6b037-1504-40b0-9d90-6aed1da43430(org.iets3.components.core.constraints)", "8133465492372624");

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept IKindSpecificAttribute$ly = MetaAdapterFactory.getInterfaceConcept(0xf0fd486f857743e9L, 0xb6713d118449c6e7L, 0x1ce55801773c6cL, "org.iets3.components.core.structure.IKindSpecificAttribute");
    /*package*/ static final SInterfaceConcept IContextTypeProvider$Ib = MetaAdapterFactory.getInterfaceConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x43d0987d9bc3829cL, "org.iets3.core.expr.base.structure.IContextTypeProvider");
    /*package*/ static final SInterfaceConcept ITypeWithTarget$mU = MetaAdapterFactory.getInterfaceConcept(0x7b68d745a7b848b9L, 0xbd9c05c0f8725a35L, 0x3dbd14d2e58f75ddL, "org.iets3.core.base.structure.ITypeWithTarget");
    /*package*/ static final SInterfaceConcept IKindContext$DQ = MetaAdapterFactory.getInterfaceConcept(0xf0fd486f857743e9L, 0xb6713d118449c6e7L, 0x6c4f9fd23e54772cL, "org.iets3.components.core.structure.IKindContext");
  }
}
