package org.iets3.components.core.editor;

/*Generated by MPS */

import com.mbeddr.mpsutil.grammarcells.runtime.AbstractGrammarActionDescriptor;
import com.mbeddr.mpsutil.grammarcells.runtime.IGrammarActionsDescriptor;
import java.util.List;
import jetbrains.mps.openapi.editor.menus.substitute.SubstituteMenuItem;
import jetbrains.mps.openapi.editor.menus.substitute.SubstituteMenuContext;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.editor.menus.EditorMenuDescriptorBase;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.model.SNode;
import com.mbeddr.mpsutil.grammarcells.runtime.GrammarCellsUtil;
import jetbrains.mps.openapi.editor.EditorContext;
import org.iets3.core.expr.base.plugin.EditorCustomizationConfigHelper;
import com.mbeddr.mpsutil.grammarcells.runtime.FlagSubstituteMenuItem;
import com.mbeddr.mpsutil.grammarcells.runtime.DefaultFlagModelAccess;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.SNodePointer;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.lang.editor.menus.substitute.DefaultSubstituteMenuLookup;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.lang.editor.menus.substitute.ReferenceScopeSubstituteMenuItem;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import jetbrains.mps.lang.editor.menus.substitute.SubstituteMenuItemWrapper;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.action.NodeFactoryManager;
import com.mbeddr.mpsutil.grammarcells.runtime.menu.GrammarCellsSubstituteMenuItem;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuItem;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuContext;
import jetbrains.mps.lang.editor.menus.transformation.MenuLocations;
import com.mbeddr.mpsutil.grammarcells.runtime.Parser;
import jetbrains.mps.smodel.constraints.ConstraintsCanBeFacade;
import jetbrains.mps.core.aspects.constraints.rules.kinds.ContainmentContext;
import com.mbeddr.mpsutil.grammarcells.runtime.MultiTextActionItem;
import jetbrains.mps.smodel.action.SNodeFactoryOperations;
import jetbrains.mps.editor.runtime.selection.SelectionUtil;
import com.mbeddr.mpsutil.grammarcells.runtime.SavedCaretPosition;
import jetbrains.mps.openapi.editor.cells.SubstituteAction;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.smodel.action.NodeSubstituteActionsFactoryContext;
import com.mbeddr.mpsutil.grammarcells.runtime.IToken;
import com.mbeddr.mpsutil.grammarcells.runtime.ISymbol;
import com.mbeddr.mpsutil.grammarcells.runtime.ChildSymbol;
import com.mbeddr.mpsutil.grammarcells.runtime.SyntaxMatcher;
import com.mbeddr.mpsutil.grammarcells.runtime.MultiTextSubsituteAction;
import com.mbeddr.mpsutil.grammarcells.runtime.IRule;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SProperty;

public class GrammarActionsDescriptor extends AbstractGrammarActionDescriptor implements IGrammarActionsDescriptor {

  public static final GrammarActionsDescriptor INSTANCE = new GrammarActionsDescriptor();

  @Override
  public List<SubstituteMenuItem> getActions(final SubstituteMenuContext _context, final SAbstractConcept expectedOutputConceptExactly) {
    final List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());

    _context.getEditorMenuTrace().pushTraceInfo();
    _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("org.iets3.components.core.editor.GrammarActionsDescriptor.getActions", null));
    try {
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());

          {
            final SConcept outputConcept = CONCEPTS.Component$gR;

            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConceptExactly))) {
              final SNode parentNode = _context.getParentNode();
              final SNode substitutedNode = _context.getCurrentTargetNode();
              for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(outputConcept, _context.getModel(), Component_Editor.class, _context.getEditorContext())) {
                EditorContext editorContext = _context.getEditorContext();
                boolean applicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                applicable &= new Object() {
                  public boolean query() {
                    return EditorCustomizationConfigHelper.getConfig().isFlagCellSubstitutionActivated(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Component$gR, PROPS.public$9JFf), subconcept, substitutedNode, parentNode, editorContext);
                  }
                }.query();
                if (applicable) {
                  ListSequence.fromList(result).addElement(new FlagSubstituteMenuItem(parentNode, _context.getCurrentTargetNode(), subconcept, "public", _context, new DefaultFlagModelAccess(PROPS.public$9JFf)) {
                    @Nullable
                    @Override
                    public String getDescriptionText(@NotNull String pattern) {
                      String originalText = super.getDescriptionText(pattern);
                      EditorContext editorContext = _context.getEditorContext();
                      String descriptiontext = EditorCustomizationConfigHelper.getConfig().getFlagCellDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Component$gR, PROPS.public$9JFf), originalText, editorContext);
                      return ((descriptiontext != null && descriptiontext.length() > 0) ? descriptiontext : "a public component");
                    }
                  });
                }
              }
            }
          }

          return result;
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "Component", new SNodePointer("r:04f1cb74-fc0c-4bf2-94b8-b7470b9d8339(org.iets3.components.core.editor)", "2293941288986433688")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.Component$gR)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.ComponentKind$Dm;
              for (final SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.Component$gR, _context.getModel(), Component_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  final SContainmentLink aggregation = LINKS.kind$8cnO;

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);


                  if (isApplicable) {
                    // get all available actions
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.kind$8cnO).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    // Filter based on grammar.rule conditions
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new _FunctionTypes._return_P1_E0<Boolean, SubstituteMenuItem>() {
                      public Boolean invoke(SubstituteMenuItem it) {
                        // Need to check constraints again for concrete type
                        boolean isApplicable = GrammarCellsUtil.canBeChildForSubstitute(subconcept, _context, it.getOutputConcept(), aggregation);
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        isApplicable &= new Object() {
                          public boolean query(SAbstractConcept expectedConcept) {
                            return EditorCustomizationConfigHelper.getConfig().isWrapperCellSubstitutionActivated(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Component$gR, LINKS.kind$8cnO), expectedConcept, wrappedConcept, editorContext);
                          }
                        }.query(expectedOutputConcept);
                        return isApplicable;
                      }
                    }).toList();

                    // Create wrapper objects for items
                    wrappedActions = ListSequence.fromList(wrappedActions).select((final SubstituteMenuItem it) -> {
                      final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                      SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                        private SNode wrappedNode;
                        @Override
                        public SNode createNode(@NotNull String pattern) {
                          SNode nodeToWrap = super.createNode(pattern);
                          wrappedNode = nodeToWrap;
                          // use setupNode after setting wrapped element to allow access to the wrapped element in node factories
                          SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                          SLinkOperations.setTarget(wrapper, LINKS.kind$8cnO, SNodeOperations.cast(nodeToWrap, CONCEPTS.ComponentKind$Dm));
                          NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                          new Object() {
                            public void postprocess(SNode node, EditorContext editorContext, SNode parentNode) {
                              EditorCustomizationConfigHelper.getConfig().wrapperCellSubstitutionPostProcess(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Component$gR, LINKS.kind$8cnO), node, editorContext);
                            }
                          }.postprocess(wrapper, _context.getEditorContext(), _context.getParentNode());
                          return wrapper;
                        }
                        @Override
                        public String getDescriptionText(@NotNull final String pattern) {
                          String originalText = ((_FunctionTypes._return_P0_E0<String>) () -> {
                            String description = it.getDescriptionText(pattern);
                            return ((description != null && description.length() > 0) ? description : it.getOutputConcept().getName());
                          }).invoke();
                          SNode wrappedNode = null;
                          SAbstractConcept wrappedConcept = super.getOutputConcept();
                          EditorContext editorContext = _context.getEditorContext();
                          String descriptiontext = EditorCustomizationConfigHelper.getConfig().getWrapperCellSubstitutionDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Component$gR, LINKS.kind$8cnO), wrappedNode, wrappedConcept, subconcept, originalText, editorContext);
                          return ((descriptiontext != null && descriptiontext.length() > 0) ? descriptiontext : "a component with kind");
                        }
                        @Override
                        public SAbstractConcept getOutputConcept() {
                          return outputConcept;
                        }

                        @Override
                        public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                          GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                        }
                      };
                      return wrapper;
                    }).toList();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where((it) -> it != null).toList();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());


          return result;
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "Port", new SNodePointer("r:04f1cb74-fc0c-4bf2-94b8-b7470b9d8339(org.iets3.components.core.editor)", "409503520730247768")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.Port$gs)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.PortCategory$Wm;
              for (final SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.Port$gs, _context.getModel(), Port_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  final SContainmentLink aggregation = LINKS.category$WD4l;

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);


                  if (isApplicable) {
                    // get all available actions
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.category$WD4l).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    // Filter based on grammar.rule conditions
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new _FunctionTypes._return_P1_E0<Boolean, SubstituteMenuItem>() {
                      public Boolean invoke(SubstituteMenuItem it) {
                        // Need to check constraints again for concrete type
                        boolean isApplicable = GrammarCellsUtil.canBeChildForSubstitute(subconcept, _context, it.getOutputConcept(), aggregation);
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        isApplicable &= new Object() {
                          public boolean query(SAbstractConcept expectedConcept) {
                            return EditorCustomizationConfigHelper.getConfig().isWrapperCellSubstitutionActivated(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Port$gs, LINKS.category$WD4l), expectedConcept, wrappedConcept, editorContext);
                          }
                        }.query(expectedOutputConcept);
                        return isApplicable;
                      }
                    }).toList();

                    // Create wrapper objects for items
                    wrappedActions = ListSequence.fromList(wrappedActions).select((final SubstituteMenuItem it) -> {
                      final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                      SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                        private SNode wrappedNode;
                        @Override
                        public SNode createNode(@NotNull String pattern) {
                          SNode nodeToWrap = super.createNode(pattern);
                          wrappedNode = nodeToWrap;
                          // use setupNode after setting wrapped element to allow access to the wrapped element in node factories
                          SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                          SLinkOperations.setTarget(wrapper, LINKS.category$WD4l, SNodeOperations.cast(nodeToWrap, CONCEPTS.PortCategory$Wm));
                          NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                          new Object() {
                            public void postprocess(SNode node, EditorContext editorContext, SNode parentNode) {
                              EditorCustomizationConfigHelper.getConfig().wrapperCellSubstitutionPostProcess(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Port$gs, LINKS.category$WD4l), node, editorContext);
                            }
                          }.postprocess(wrapper, _context.getEditorContext(), _context.getParentNode());
                          return wrapper;
                        }
                        @Override
                        public String getDescriptionText(@NotNull final String pattern) {
                          String originalText = ((_FunctionTypes._return_P0_E0<String>) () -> {
                            String description = it.getDescriptionText(pattern);
                            return ((description != null && description.length() > 0) ? description : it.getOutputConcept().getName());
                          }).invoke();
                          SNode wrappedNode = null;
                          SAbstractConcept wrappedConcept = super.getOutputConcept();
                          EditorContext editorContext = _context.getEditorContext();
                          String descriptiontext = EditorCustomizationConfigHelper.getConfig().getWrapperCellSubstitutionDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Port$gs, LINKS.category$WD4l), wrappedNode, wrappedConcept, subconcept, originalText, editorContext);
                          return ((descriptiontext != null && descriptiontext.length() > 0) ? descriptiontext : "a port with category");
                        }
                        @Override
                        public SAbstractConcept getOutputConcept() {
                          return outputConcept;
                        }

                        @Override
                        public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                          GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                        }
                      };
                      return wrapper;
                    }).toList();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where((it) -> it != null).toList();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "SimpleBehavior", new SNodePointer("r:04f1cb74-fc0c-4bf2-94b8-b7470b9d8339(org.iets3.components.core.editor)", "3280647862048458622")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.SimpleBehavior$jv)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.Trigger$jZ;
              for (final SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.SimpleBehavior$jv, _context.getModel(), SimpleBehavior_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  final SContainmentLink aggregation = LINKS.trigger$nkOV;

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);


                  if (isApplicable) {
                    // get all available actions
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.trigger$nkOV).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    // Filter based on grammar.rule conditions
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new _FunctionTypes._return_P1_E0<Boolean, SubstituteMenuItem>() {
                      public Boolean invoke(SubstituteMenuItem it) {
                        // Need to check constraints again for concrete type
                        boolean isApplicable = GrammarCellsUtil.canBeChildForSubstitute(subconcept, _context, it.getOutputConcept(), aggregation);
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        isApplicable &= new Object() {
                          public boolean query(SAbstractConcept expectedConcept) {
                            return EditorCustomizationConfigHelper.getConfig().isWrapperCellSubstitutionActivated(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.SimpleBehavior$jv, LINKS.trigger$nkOV), expectedConcept, wrappedConcept, editorContext);
                          }
                        }.query(expectedOutputConcept);
                        return isApplicable;
                      }
                    }).toList();

                    // Create wrapper objects for items
                    wrappedActions = ListSequence.fromList(wrappedActions).select((final SubstituteMenuItem it) -> {
                      final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                      SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                        private SNode wrappedNode;
                        @Override
                        public SNode createNode(@NotNull String pattern) {
                          SNode nodeToWrap = super.createNode(pattern);
                          wrappedNode = nodeToWrap;
                          // use setupNode after setting wrapped element to allow access to the wrapped element in node factories
                          SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                          SLinkOperations.setTarget(wrapper, LINKS.trigger$nkOV, SNodeOperations.cast(nodeToWrap, CONCEPTS.Trigger$jZ));
                          NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                          new Object() {
                            public void postprocess(SNode node, EditorContext editorContext, SNode parentNode) {
                              EditorCustomizationConfigHelper.getConfig().wrapperCellSubstitutionPostProcess(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.SimpleBehavior$jv, LINKS.trigger$nkOV), node, editorContext);
                            }
                          }.postprocess(wrapper, _context.getEditorContext(), _context.getParentNode());
                          return wrapper;
                        }
                        @Override
                        public String getDescriptionText(@NotNull final String pattern) {
                          String originalText = ((_FunctionTypes._return_P0_E0<String>) () -> {
                            String description = it.getDescriptionText(pattern);
                            return ((description != null && description.length() > 0) ? description : it.getOutputConcept().getName());
                          }).invoke();
                          SNode wrappedNode = null;
                          SAbstractConcept wrappedConcept = super.getOutputConcept();
                          EditorContext editorContext = _context.getEditorContext();
                          String descriptiontext = EditorCustomizationConfigHelper.getConfig().getWrapperCellSubstitutionDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.SimpleBehavior$jv, LINKS.trigger$nkOV), wrappedNode, wrappedConcept, subconcept, originalText, editorContext);
                          return ((descriptiontext != null && descriptiontext.length() > 0) ? descriptiontext : "a simple behavior with trigger");
                        }
                        @Override
                        public SAbstractConcept getOutputConcept() {
                          return outputConcept;
                        }

                        @Override
                        public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                          GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                        }
                      };
                      return wrapper;
                    }).toList();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where((it) -> it != null).toList();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());


          return result;
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "Component", new SNodePointer("r:04f1cb74-fc0c-4bf2-94b8-b7470b9d8339(org.iets3.components.core.editor)", "8209493818901373393")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.Component$gR)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.ComponentKind$Dm;
              for (final SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.Component$gR, _context.getModel(), Component_inlineComponent_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  final SContainmentLink aggregation = LINKS.kind$8cnO;

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);


                  if (isApplicable) {
                    // get all available actions
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.kind$8cnO).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    // Filter based on grammar.rule conditions
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new _FunctionTypes._return_P1_E0<Boolean, SubstituteMenuItem>() {
                      public Boolean invoke(SubstituteMenuItem it) {
                        // Need to check constraints again for concrete type
                        boolean isApplicable = GrammarCellsUtil.canBeChildForSubstitute(subconcept, _context, it.getOutputConcept(), aggregation);
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        isApplicable &= new Object() {
                          public boolean query(SAbstractConcept expectedConcept) {
                            return EditorCustomizationConfigHelper.getConfig().isWrapperCellSubstitutionActivated(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Component$gR, LINKS.kind$8cnO), expectedConcept, wrappedConcept, editorContext);
                          }
                        }.query(expectedOutputConcept);
                        return isApplicable;
                      }
                    }).toList();

                    // Create wrapper objects for items
                    wrappedActions = ListSequence.fromList(wrappedActions).select((final SubstituteMenuItem it) -> {
                      final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                      SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                        private SNode wrappedNode;
                        @Override
                        public SNode createNode(@NotNull String pattern) {
                          SNode nodeToWrap = super.createNode(pattern);
                          wrappedNode = nodeToWrap;
                          // use setupNode after setting wrapped element to allow access to the wrapped element in node factories
                          SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                          SLinkOperations.setTarget(wrapper, LINKS.kind$8cnO, SNodeOperations.cast(nodeToWrap, CONCEPTS.ComponentKind$Dm));
                          NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                          new Object() {
                            public void postprocess(SNode node, EditorContext editorContext, SNode parentNode) {
                              EditorCustomizationConfigHelper.getConfig().wrapperCellSubstitutionPostProcess(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Component$gR, LINKS.kind$8cnO), node, editorContext);
                            }
                          }.postprocess(wrapper, _context.getEditorContext(), _context.getParentNode());
                          return wrapper;
                        }
                        @Override
                        public String getDescriptionText(@NotNull final String pattern) {
                          String originalText = ((_FunctionTypes._return_P0_E0<String>) () -> {
                            String description = it.getDescriptionText(pattern);
                            return ((description != null && description.length() > 0) ? description : it.getOutputConcept().getName());
                          }).invoke();
                          SNode wrappedNode = null;
                          SAbstractConcept wrappedConcept = super.getOutputConcept();
                          EditorContext editorContext = _context.getEditorContext();
                          String descriptiontext = EditorCustomizationConfigHelper.getConfig().getWrapperCellSubstitutionDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Component$gR, LINKS.kind$8cnO), wrappedNode, wrappedConcept, subconcept, originalText, editorContext);
                          return ((descriptiontext != null && descriptiontext.length() > 0) ? descriptiontext : "a component with kind");
                        }
                        @Override
                        public SAbstractConcept getOutputConcept() {
                          return outputConcept;
                        }

                        @Override
                        public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                          GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                        }
                      };
                      return wrapper;
                    }).toList();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where((it) -> it != null).toList();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "PortWithConfiguration", new SNodePointer("r:04f1cb74-fc0c-4bf2-94b8-b7470b9d8339(org.iets3.components.core.editor)", "4983437972509912034")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.PortWithConfiguration$kT)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.IPortType$DL;
              for (final SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.PortWithConfiguration$kT, _context.getModel(), PortWithConfiguration_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  final SContainmentLink aggregation = LINKS.wrapped$gKEw;

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);


                  if (isApplicable) {
                    // get all available actions
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.wrapped$gKEw).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    // Filter based on grammar.rule conditions
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new _FunctionTypes._return_P1_E0<Boolean, SubstituteMenuItem>() {
                      public Boolean invoke(SubstituteMenuItem it) {
                        // Need to check constraints again for concrete type
                        boolean isApplicable = GrammarCellsUtil.canBeChildForSubstitute(subconcept, _context, it.getOutputConcept(), aggregation);
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        isApplicable &= new Object() {
                          public boolean query(SAbstractConcept expectedConcept) {
                            return EditorCustomizationConfigHelper.getConfig().isWrapperCellSubstitutionActivated(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.PortWithConfiguration$kT, LINKS.wrapped$gKEw), expectedConcept, wrappedConcept, editorContext);
                          }
                        }.query(expectedOutputConcept);
                        return isApplicable;
                      }
                    }).toList();

                    // Create wrapper objects for items
                    wrappedActions = ListSequence.fromList(wrappedActions).select((final SubstituteMenuItem it) -> {
                      final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                      SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                        private SNode wrappedNode;
                        @Override
                        public SNode createNode(@NotNull String pattern) {
                          SNode nodeToWrap = super.createNode(pattern);
                          wrappedNode = nodeToWrap;
                          // use setupNode after setting wrapped element to allow access to the wrapped element in node factories
                          SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                          SLinkOperations.setTarget(wrapper, LINKS.wrapped$gKEw, SNodeOperations.cast(nodeToWrap, CONCEPTS.IPortType$DL));
                          NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                          new Object() {
                            public void postprocess(SNode node, EditorContext editorContext, SNode parentNode) {
                              EditorCustomizationConfigHelper.getConfig().wrapperCellSubstitutionPostProcess(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.PortWithConfiguration$kT, LINKS.wrapped$gKEw), node, editorContext);
                            }
                          }.postprocess(wrapper, _context.getEditorContext(), _context.getParentNode());
                          return wrapper;
                        }
                        @Override
                        public String getDescriptionText(@NotNull final String pattern) {
                          String originalText = ((_FunctionTypes._return_P0_E0<String>) () -> {
                            String description = it.getDescriptionText(pattern);
                            return ((description != null && description.length() > 0) ? description : it.getOutputConcept().getName());
                          }).invoke();
                          SNode wrappedNode = null;
                          SAbstractConcept wrappedConcept = super.getOutputConcept();
                          EditorContext editorContext = _context.getEditorContext();
                          String descriptiontext = EditorCustomizationConfigHelper.getConfig().getWrapperCellSubstitutionDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.PortWithConfiguration$kT, LINKS.wrapped$gKEw), wrappedNode, wrappedConcept, subconcept, originalText, editorContext);
                          return ((descriptiontext != null && descriptiontext.length() > 0) ? descriptiontext : originalText);
                        }
                        @Override
                        public SAbstractConcept getOutputConcept() {
                          return outputConcept;
                        }

                        @Override
                        public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                          GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                        }
                      };
                      return wrapper;
                    }).toList();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where((it) -> it != null).toList();
        }
      }.query()));
    } finally {
      _context.getEditorMenuTrace().popTraceInfo();
    }

    return ListSequence.fromList(result).where((it) -> it != null).toList();
  }

  @Override
  protected List<TransformationMenuItem> doGetSideTransformActions(final TransformationMenuContext _context) {
    final List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());

    _context.getEditorMenuTrace().pushTraceInfo();
    _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("org.iets3.components.core.editor.GrammarActionsDescriptor.doGetSideTransformActions", null));
    try {
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "Component", new SNodePointer("r:04f1cb74-fc0c-4bf2-94b8-b7470b9d8339(org.iets3.components.core.editor)", "2293941288986433688")));
              try {
                if (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.ComponentKind$Dm, null);
                  final EditorContext editorContext = _context.getEditorContext();

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    final SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.Component$gR, _context.getModel(), Component_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = Sequence.<String>singleton("component");
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ConstraintsCanBeFacade.checkCanBeParent(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          sideTransformationEnabled &= GrammarCellsUtil.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink());
                          sideTransformationEnabled &= ConstraintsCanBeFacade.checkCanBeChild(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          sideTransformationEnabled &= new Object() {
                            public boolean enabled(SNode wrappedNode) {
                              return EditorCustomizationConfigHelper.getConfig().isWrapperCellSideTransformationActivated(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Component$gR, LINKS.kind$8cnO), wrappedNode, subconcept, editorContext);
                            }
                          }.enabled(SNodeOperations.cast(sourceNode, CONCEPTS.ComponentKind$Dm));
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              @Override
                              public String getShortDescriptionText(@NotNull String pattern) {
                                String originalText = super.getShortDescriptionText(pattern);
                                SNode wrappedNode = _context.getNode();
                                SAbstractConcept wrappedConcept = this.getOutputConcept();
                                EditorContext editorContext = _context.getEditorContext();
                                String descriptiontext = EditorCustomizationConfigHelper.getConfig().getWrapperCellSubstitutionDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Component$gR, LINKS.kind$8cnO), wrappedNode, wrappedConcept, subconcept, originalText, editorContext);
                                return ((descriptiontext != null && descriptiontext.length() > 0) ? descriptiontext : "a component with kind");
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.Component$gR);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.kind$8cnO, SNodeOperations.cast(sourceNode, CONCEPTS.ComponentKind$Dm));

                                new Object() {
                                  public void postprocess(SNode node) {
                                    EditorCustomizationConfigHelper.getConfig().wrapperCellSideTransformationPostProcess(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Component$gR, LINKS.kind$8cnO), node, editorContext);
                                  }
                                }.postprocess(wrapper);

                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst((it) -> it != sourceNode);
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where((it) -> it != null).toList();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "Port", new SNodePointer("r:04f1cb74-fc0c-4bf2-94b8-b7470b9d8339(org.iets3.components.core.editor)", "409503520730247768")));
              try {
                if (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.PortCategory$Wm, null);
                  final EditorContext editorContext = _context.getEditorContext();

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    final SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.Port$gs, _context.getModel(), Port_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = Sequence.<String>singleton("[");
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ConstraintsCanBeFacade.checkCanBeParent(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          sideTransformationEnabled &= GrammarCellsUtil.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink());
                          sideTransformationEnabled &= ConstraintsCanBeFacade.checkCanBeChild(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          sideTransformationEnabled &= new Object() {
                            public boolean enabled(SNode wrappedNode) {
                              return EditorCustomizationConfigHelper.getConfig().isWrapperCellSideTransformationActivated(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Port$gs, LINKS.category$WD4l), wrappedNode, subconcept, editorContext);
                            }
                          }.enabled(SNodeOperations.cast(sourceNode, CONCEPTS.PortCategory$Wm));
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              @Override
                              public String getShortDescriptionText(@NotNull String pattern) {
                                String originalText = super.getShortDescriptionText(pattern);
                                SNode wrappedNode = _context.getNode();
                                SAbstractConcept wrappedConcept = this.getOutputConcept();
                                EditorContext editorContext = _context.getEditorContext();
                                String descriptiontext = EditorCustomizationConfigHelper.getConfig().getWrapperCellSubstitutionDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Port$gs, LINKS.category$WD4l), wrappedNode, wrappedConcept, subconcept, originalText, editorContext);
                                return ((descriptiontext != null && descriptiontext.length() > 0) ? descriptiontext : "a port with category");
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.Port$gs);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.category$WD4l, SNodeOperations.cast(sourceNode, CONCEPTS.PortCategory$Wm));

                                new Object() {
                                  public void postprocess(SNode node) {
                                    EditorCustomizationConfigHelper.getConfig().wrapperCellSideTransformationPostProcess(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Port$gs, LINKS.category$WD4l), node, editorContext);
                                  }
                                }.postprocess(wrapper);

                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst((it) -> it != sourceNode);
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where((it) -> it != null).toList();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "SimpleBehavior", new SNodePointer("r:04f1cb74-fc0c-4bf2-94b8-b7470b9d8339(org.iets3.components.core.editor)", "3280647862048458622")));
              try {
                if (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Trigger$jZ, null);
                  final EditorContext editorContext = _context.getEditorContext();

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    final SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.SimpleBehavior$jv, _context.getModel(), SimpleBehavior_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = Sequence.<String>singleton("{");
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ConstraintsCanBeFacade.checkCanBeParent(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          sideTransformationEnabled &= GrammarCellsUtil.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink());
                          sideTransformationEnabled &= ConstraintsCanBeFacade.checkCanBeChild(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          sideTransformationEnabled &= new Object() {
                            public boolean enabled(SNode wrappedNode) {
                              return EditorCustomizationConfigHelper.getConfig().isWrapperCellSideTransformationActivated(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.SimpleBehavior$jv, LINKS.trigger$nkOV), wrappedNode, subconcept, editorContext);
                            }
                          }.enabled(SNodeOperations.cast(sourceNode, CONCEPTS.Trigger$jZ));
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              @Override
                              public String getShortDescriptionText(@NotNull String pattern) {
                                String originalText = super.getShortDescriptionText(pattern);
                                SNode wrappedNode = _context.getNode();
                                SAbstractConcept wrappedConcept = this.getOutputConcept();
                                EditorContext editorContext = _context.getEditorContext();
                                String descriptiontext = EditorCustomizationConfigHelper.getConfig().getWrapperCellSubstitutionDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.SimpleBehavior$jv, LINKS.trigger$nkOV), wrappedNode, wrappedConcept, subconcept, originalText, editorContext);
                                return ((descriptiontext != null && descriptiontext.length() > 0) ? descriptiontext : "a simple behavior with trigger");
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.SimpleBehavior$jv);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.trigger$nkOV, SNodeOperations.cast(sourceNode, CONCEPTS.Trigger$jZ));

                                new Object() {
                                  public void postprocess(SNode node) {
                                    EditorCustomizationConfigHelper.getConfig().wrapperCellSideTransformationPostProcess(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.SimpleBehavior$jv, LINKS.trigger$nkOV), node, editorContext);
                                  }
                                }.postprocess(wrapper);

                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst((it) -> it != sourceNode);
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where((it) -> it != null).toList();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "Component", new SNodePointer("r:04f1cb74-fc0c-4bf2-94b8-b7470b9d8339(org.iets3.components.core.editor)", "8209493818901373393")));
              try {
                if (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.ComponentKind$Dm, null);
                  final EditorContext editorContext = _context.getEditorContext();

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    final SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.Component$gR, _context.getModel(), Component_inlineComponent_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = Sequence.<String>singleton("[");
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ConstraintsCanBeFacade.checkCanBeParent(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          sideTransformationEnabled &= GrammarCellsUtil.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink());
                          sideTransformationEnabled &= ConstraintsCanBeFacade.checkCanBeChild(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          sideTransformationEnabled &= new Object() {
                            public boolean enabled(SNode wrappedNode) {
                              return EditorCustomizationConfigHelper.getConfig().isWrapperCellSideTransformationActivated(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Component$gR, LINKS.kind$8cnO), wrappedNode, subconcept, editorContext);
                            }
                          }.enabled(SNodeOperations.cast(sourceNode, CONCEPTS.ComponentKind$Dm));
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              @Override
                              public String getShortDescriptionText(@NotNull String pattern) {
                                String originalText = super.getShortDescriptionText(pattern);
                                SNode wrappedNode = _context.getNode();
                                SAbstractConcept wrappedConcept = this.getOutputConcept();
                                EditorContext editorContext = _context.getEditorContext();
                                String descriptiontext = EditorCustomizationConfigHelper.getConfig().getWrapperCellSubstitutionDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Component$gR, LINKS.kind$8cnO), wrappedNode, wrappedConcept, subconcept, originalText, editorContext);
                                return ((descriptiontext != null && descriptiontext.length() > 0) ? descriptiontext : "a component with kind");
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.Component$gR);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.kind$8cnO, SNodeOperations.cast(sourceNode, CONCEPTS.ComponentKind$Dm));

                                new Object() {
                                  public void postprocess(SNode node) {
                                    EditorCustomizationConfigHelper.getConfig().wrapperCellSideTransformationPostProcess(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.Component$gR, LINKS.kind$8cnO), node, editorContext);
                                  }
                                }.postprocess(wrapper);

                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst((it) -> it != sourceNode);
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where((it) -> it != null).toList();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "PortWithConfiguration", new SNodePointer("r:04f1cb74-fc0c-4bf2-94b8-b7470b9d8339(org.iets3.components.core.editor)", "4983437972509912034")));
              try {
                if (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.IPortType$DL, null);
                  final EditorContext editorContext = _context.getEditorContext();

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    final SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.PortWithConfiguration$kT, _context.getModel(), PortWithConfiguration_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = Sequence.<String>singleton("with");
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ConstraintsCanBeFacade.checkCanBeParent(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          sideTransformationEnabled &= GrammarCellsUtil.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink());
                          sideTransformationEnabled &= ConstraintsCanBeFacade.checkCanBeChild(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          sideTransformationEnabled &= new Object() {
                            public boolean enabled(SNode wrappedNode) {
                              return EditorCustomizationConfigHelper.getConfig().isWrapperCellSideTransformationActivated(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.PortWithConfiguration$kT, LINKS.wrapped$gKEw), wrappedNode, subconcept, editorContext);
                            }
                          }.enabled(SNodeOperations.cast(sourceNode, CONCEPTS.IPortType$DL));
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              @Override
                              public String getShortDescriptionText(@NotNull String pattern) {
                                String originalText = super.getShortDescriptionText(pattern);
                                SNode wrappedNode = _context.getNode();
                                SAbstractConcept wrappedConcept = this.getOutputConcept();
                                EditorContext editorContext = _context.getEditorContext();
                                String descriptiontext = EditorCustomizationConfigHelper.getConfig().getWrapperCellSubstitutionDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.PortWithConfiguration$kT, LINKS.wrapped$gKEw), wrappedNode, wrappedConcept, subconcept, originalText, editorContext);
                                return ((descriptiontext != null && descriptiontext.length() > 0) ? descriptiontext : originalText);
                              }
                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.PortWithConfiguration$kT);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.wrapped$gKEw, SNodeOperations.cast(sourceNode, CONCEPTS.IPortType$DL));

                                new Object() {
                                  public void postprocess(SNode node) {
                                    EditorCustomizationConfigHelper.getConfig().wrapperCellSideTransformationPostProcess(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.PortWithConfiguration$kT, LINKS.wrapped$gKEw), node, editorContext);
                                  }
                                }.postprocess(wrapper);

                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst((it) -> it != sourceNode);
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where((it) -> it != null).toList();
            }
          }.query(_context)));
        }
      }
    } finally {
      _context.getEditorMenuTrace().popTraceInfo();
    }

    return ListSequence.fromList(result).where((it) -> it != null).toList();
  }

  @Override
  public List<SubstituteAction> getConstantReplaceActions(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context, final List<IToken> elementsBefore, final List<IToken> elementsAfter) {
    final List<SubstituteAction> result = ListSequence.fromList(new ArrayList<SubstituteAction>());
    // PortWithConfiguration_Editor
    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.PortWithConfiguration$kT, _context.getModel(), PortWithConfiguration_Editor.class)) {
      final Iterable<String> matchingText = Sequence.<String>singleton("with");
      boolean conceptAllowed = SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(_context.getChildConcept()));
      SNode sourceNode = _context.getCurrentTargetNode();
      boolean transformationEnabled = ConstraintsCanBeFacade.checkCanBeParent(new ContainmentContext.Builder().parentNode(_context.getParentNode()).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
      transformationEnabled &= GrammarCellsUtil.canBeAncestor(_context.getParentNode(), subconcept, sourceNode.getContainmentLink());
      if (Sequence.fromIterable(matchingText).isNotEmpty() && conceptAllowed && transformationEnabled) {

        final List<ISymbol> beforeMatchers = ListSequence.fromList(new ArrayList<ISymbol>());
        final List<ISymbol> afterMatchers = ListSequence.fromList(new ArrayList<ISymbol>());
        ListSequence.fromList(beforeMatchers).addElement(new ChildSymbol(LINKS.wrapped$gKEw));
        ListSequence.fromList(afterMatchers).addElement(new ChildSymbol(LINKS.value$GOOo));
        final SyntaxMatcher matcher = new SyntaxMatcher();
        if (matcher.matches(elementsBefore, beforeMatchers, false, null) && matcher.matches(elementsAfter, afterMatchers, false, null)) {

          ListSequence.fromList(result).addElement(new MultiTextSubsituteAction(_context.getParentNode(), matchingText) {
            @Override
            protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
              SNode newNode = SNodeFactoryOperations.createNewNode(subconcept, null);

              matcher.matches(elementsBefore, beforeMatchers, true, newNode);
              matcher.matches(elementsAfter, afterMatchers, true, newNode);

              _context.getChildSetter().execute(_context.getParentNode(), _context.getCurrentTargetNode(), newNode, editorContext);

              GrammarCellsUtil.selectCellWithText(editorContext, newNode, getMatchingText(pattern));

              SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
              caretPosition.save();
              Parser parser = new Parser(editorContext.getModel());
              SNode expressionRoot = parser.findRootExpression(newNode);
              parser.rebalanceIfRequired(expressionRoot);
              caretPosition.restore();

              return null;
            }
            @Override
            public SNode getOutputConcept() {
              return SNodeOperations.asNode(subconcept);
            }
            @Override
            public String getDescriptionText(@NotNull String pattern) {
              String originalText = super.getDescriptionText(pattern);
              SNode node = _context.getCurrentTargetNode();
              return EditorCustomizationConfigHelper.getConfig().getSubstituteCellDescriptionText(EditorCustomizationConfigHelper.getIdentifier(CONCEPTS.PortWithConfiguration$kT), node, originalText);
            }

          });
        }
      }
    }




    return ListSequence.fromList(result).where((it) -> it != null).toList();
  }

  @Override
  public List<IRule> getRules(final SModel contextModel) {
    final List<IRule> rules = ListSequence.fromList(new ArrayList<IRule>());

    final Set<SLanguage> visibleLanguages = GrammarCellsUtil.getVisibleLanguages(contextModel);


    return rules;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Component$gR = MetaAdapterFactory.getConcept(0xf0fd486f857743e9L, 0xb6713d118449c6e7L, 0x6c4f9fd23e484601L, "org.iets3.components.core.structure.Component");
    /*package*/ static final SConcept ComponentKind$Dm = MetaAdapterFactory.getConcept(0xf0fd486f857743e9L, 0xb6713d118449c6e7L, 0x6c4f9fd23e4c95e0L, "org.iets3.components.core.structure.ComponentKind");
    /*package*/ static final SConcept PortCategory$Wm = MetaAdapterFactory.getConcept(0xf0fd486f857743e9L, 0xb6713d118449c6e7L, 0x71280102d0186c2L, "org.iets3.components.core.structure.PortCategory");
    /*package*/ static final SConcept Port$gs = MetaAdapterFactory.getConcept(0xf0fd486f857743e9L, 0xb6713d118449c6e7L, 0x6c4f9fd23e51937cL, "org.iets3.components.core.structure.Port");
    /*package*/ static final SConcept Trigger$jZ = MetaAdapterFactory.getConcept(0xf0fd486f857743e9L, 0xb6713d118449c6e7L, 0x2d8733d9528b0759L, "org.iets3.components.core.structure.Trigger");
    /*package*/ static final SConcept SimpleBehavior$jv = MetaAdapterFactory.getConcept(0xf0fd486f857743e9L, 0xb6713d118449c6e7L, 0x2d8733d9528b05f9L, "org.iets3.components.core.structure.SimpleBehavior");
    /*package*/ static final SInterfaceConcept IPortType$DL = MetaAdapterFactory.getInterfaceConcept(0xf0fd486f857743e9L, 0xb6713d118449c6e7L, 0x6c4f9fd23e566371L, "org.iets3.components.core.structure.IPortType");
    /*package*/ static final SConcept PortWithConfiguration$kT = MetaAdapterFactory.getConcept(0xf0fd486f857743e9L, 0xb6713d118449c6e7L, 0x4528ba6ebfa56b3cL, "org.iets3.components.core.structure.PortWithConfiguration");
  }

  private static final class PROPS {
    /*package*/ static final SProperty public$9JFf = MetaAdapterFactory.getProperty(0xf0fd486f857743e9L, 0xb6713d118449c6e7L, 0x6c4f9fd23e49f653L, 0x553d981116f0c96cL, "public");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink kind$8cnO = MetaAdapterFactory.getContainmentLink(0xf0fd486f857743e9L, 0xb6713d118449c6e7L, 0x6c4f9fd23e484601L, 0x6c4f9fd23e4c96f7L, "kind");
    /*package*/ static final SContainmentLink category$WD4l = MetaAdapterFactory.getContainmentLink(0xf0fd486f857743e9L, 0xb6713d118449c6e7L, 0x6c4f9fd23e51937cL, 0x5aed9484f65f1e5L, "category");
    /*package*/ static final SContainmentLink trigger$nkOV = MetaAdapterFactory.getContainmentLink(0xf0fd486f857743e9L, 0xb6713d118449c6e7L, 0x2d8733d9528b05f9L, 0x2d8733d9528b075aL, "trigger");
    /*package*/ static final SContainmentLink wrapped$gKEw = MetaAdapterFactory.getContainmentLink(0xf0fd486f857743e9L, 0xb6713d118449c6e7L, 0x4528ba6ebfa56b3cL, 0x4528ba6ebfa56b79L, "wrapped");
    /*package*/ static final SContainmentLink value$GOOo = MetaAdapterFactory.getContainmentLink(0xf0fd486f857743e9L, 0xb6713d118449c6e7L, 0x4528ba6ebfa56b3cL, 0x4528ba6ebfa59535L, "value");
  }
}
