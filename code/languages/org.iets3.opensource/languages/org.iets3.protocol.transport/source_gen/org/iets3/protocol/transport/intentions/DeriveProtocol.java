package org.iets3.protocol.transport.intentions;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.iets3.protocol.transport.behavior.IProtocoled__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.iets3.protocol.transport.behavior.Protocol__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class DeriveProtocol {

  private SNode protocolAttr;

  public DeriveProtocol(SNode mappingSection) {
    this.protocolAttr = mappingSection;
  }

  public Iterable<SConcept> candidateProtocols(final SNode protocolAttr) {
    final Wrappers._T<Iterable<SConcept>> candidateProtocols = new Wrappers._T<Iterable<SConcept>>(null);
    Sequence.fromIterable(IProtocoled__BehaviorDescriptor.protocoledElements_id2HsTbibmy9E.invoke(protocolAttr)).visitAll((it) -> {
      Iterable<SNode> protocolMapForElement = IProtocoled__BehaviorDescriptor.protocolMapsForElement_id4FLRp99wBxW.invoke(protocolAttr, it);
      if (candidateProtocols.value == null) {
        candidateProtocols.value = initializeCandidateProtocols(protocolMapForElement);
      } else {
        candidateProtocols.value = Sequence.fromIterable(candidateProtocols.value).intersect(Sequence.fromIterable(transportProtocolConcepts(protocolMapForElement)));
      }
    });
    return candidateProtocols.value;
  }

  public SNode firstMatchingHardware(Iterable<SConcept> candidateProtocols) {
    SConcept concept = Sequence.fromIterable(candidateProtocols).findFirst((it) -> Sequence.fromIterable(SNodeOperations.ofConcept(IProtocoled__BehaviorDescriptor.availableHardwareConnectorTypes_id6JtAeCuVOz7.invoke(protocolAttr), SNodeOperations.asSConcept(SNodeOperations.getConcept(Protocol__BehaviorDescriptor.connectorType_id6JtAeCuVpNb.invoke(SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(it))))))).isNotEmpty());
    return SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(concept));
  }

  private Iterable<SConcept> initializeCandidateProtocols(Iterable<SNode> protocolMaps) {
    return ListSequence.fromListWithValues(new ArrayList<SConcept>(), transportProtocolConcepts(protocolMaps));
  }

  private Iterable<SConcept> transportProtocolConcepts(Iterable<SNode> protocolMaps) {
    return Sequence.fromIterable(protocolMaps).select((it) -> SNodeOperations.getConcept(SLinkOperations.getTarget(it, LINKS.protocol$Prfs)));
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink protocol$Prfs = MetaAdapterFactory.getContainmentLink(0xa50d629093d242afL, 0x9ae0b2fefc6ee754L, 0x7ef7796277ace0dL, 0x6bdd98ea1ecc9564L, "protocol");
  }
}
