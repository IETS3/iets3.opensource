package org.iets3.protocol.transport.intentions;

/*Generated by MPS */

import jetbrains.mps.intentions.AbstractIntentionDescriptor;
import jetbrains.mps.openapi.intentions.IntentionFactory;
import java.util.Collection;
import jetbrains.mps.openapi.intentions.IntentionExecutable;
import jetbrains.mps.openapi.intentions.Kind;
import jetbrains.mps.smodel.SNodePointer;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.EditorContext;
import java.util.Collections;
import jetbrains.mps.intentions.AbstractIntentionExecutable;
import org.iets3.core.mapping.behavior.IMappingContainer__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.iets3.protocol.transport.behavior.IProtocoled__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.openapi.intentions.IntentionDescriptor;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public final class DeriveProtocol_Intention extends AbstractIntentionDescriptor implements IntentionFactory {
  private Collection<IntentionExecutable> myCachedExecutable;

  public DeriveProtocol_Intention() {
    super(Kind.NORMAL, false, new SNodePointer("r:c9d3b67e-62f4-430e-a5b8-04459662b42c(org.iets3.protocol.transport.intentions)", "7150030894251205322"));
  }

  @Override
  public String getPresentation() {
    return "DeriveProtocol";
  }

  @Override
  public boolean isSurroundWith() {
    return false;
  }

  public Collection<IntentionExecutable> instances(final SNode node, final EditorContext context) {
    if (myCachedExecutable == null) {
      myCachedExecutable = Collections.<IntentionExecutable>singletonList(new IntentionImplementation());
    }
    return myCachedExecutable;
  }
  /*package*/ final class IntentionImplementation extends AbstractIntentionExecutable {
    public IntentionImplementation() {
    }

    @Override
    public String getDescription(final SNode node, final EditorContext editorContext) {
      return "Derive Protocol Mappings";
    }

    @Override
    public void execute(final SNode node, final EditorContext editorContext) {
      final DeriveProtocolErrorHandler errorHandler = new DeriveProtocolErrorHandler();

      SNode mappingSection = IMappingContainer__BehaviorDescriptor.mappingSection_id3GbuJrdLq2n.invoke(SNodeOperations.getNodeAncestor(node, CONCEPTS.MappingContainer$hD, false, false));
      ListSequence.fromList(SLinkOperations.getChildren(mappingSection, LINKS.mappings$f1X7)).visitAll((mapping) -> {
        SNode protocolAttr = Sequence.fromIterable(SNodeOperations.ofConcept(SLinkOperations.getChildren(mapping, LINKS.attributes$zPmM), CONCEPTS.ProtocoledComponentMappingAttr$I6)).first();
        if ((protocolAttr == null)) {
          protocolAttr = SLinkOperations.addNewChild(mapping, LINKS.attributes$zPmM, CONCEPTS.ProtocoledComponentMappingAttr$I6);
        }

        DeriveProtocol deriveProtocol = new DeriveProtocol(protocolAttr);
        if ((SLinkOperations.getTarget(protocolAttr, LINKS.protocol$J5FJ) == null)) {
          Iterable<SNode> notMappedProtocoledElements = IProtocoled__BehaviorDescriptor.notMappedProtocoledElements_id3wMQ0tmvpy$.invoke(protocolAttr);
          if (Sequence.fromIterable(notMappedProtocoledElements).isEmpty()) {
            Iterable<SConcept> candidateProtocols = deriveProtocol.candidateProtocols(protocolAttr);
            if (Sequence.fromIterable(candidateProtocols).isNotEmpty()) {
              SNode derivedProtocol = deriveProtocol.firstMatchingHardware(candidateProtocols);
              if (derivedProtocol == null) {
                errorHandler.appendNotSuitableHardwareError(mapping, candidateProtocols, IProtocoled__BehaviorDescriptor.availableHardwareConnectorTypes_id6JtAeCuVOz7.invoke(protocolAttr));
              } else {
                SLinkOperations.setTarget(protocolAttr, LINKS.protocol$J5FJ, derivedProtocol);
              }
            } else {
              errorHandler.appendNonCommonMapsError(mapping, IProtocoled__BehaviorDescriptor.protocoledElements_id2HsTbibmy9E.invoke(protocolAttr));
            }
          } else {
            errorHandler.appendMissingMapError(mapping, notMappedProtocoledElements);
          }
        }
      });

      if (errorHandler.hasErrorsToShow()) {
        errorHandler.showErrorMessage();
      }
    }

    @Override
    public boolean isApplicable(final SNode node, final EditorContext editorContext) {
      return true;
    }



    @Override
    public IntentionDescriptor getDescriptor() {
      return DeriveProtocol_Intention.this;
    }

  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept MappingContainer$hD = MetaAdapterFactory.getConcept(0x8c1ef69abcac4cb5L, 0x96196b27d0aefc0cL, 0x2b39747c07e31163L, "org.iets3.core.mapping.structure.MappingContainer");
    /*package*/ static final SConcept ProtocoledComponentMappingAttr$I6 = MetaAdapterFactory.getConcept(0xa50d629093d242afL, 0x9ae0b2fefc6ee754L, 0x2b5ce4b48ba6f6f1L, "org.iets3.protocol.transport.structure.ProtocoledComponentMappingAttr");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink mappings$f1X7 = MetaAdapterFactory.getContainmentLink(0x8c1ef69abcac4cb5L, 0x96196b27d0aefc0cL, 0xd6b6a95f7fb8f18L, 0xd6b6a95f7fb8f1eL, "mappings");
    /*package*/ static final SContainmentLink attributes$zPmM = MetaAdapterFactory.getContainmentLink(0x583939beded04735L, 0xa055a74f8477fc34L, 0x3ce7d48974432ecdL, 0x3ce7d48974432eceL, "attributes");
    /*package*/ static final SContainmentLink protocol$J5FJ = MetaAdapterFactory.getContainmentLink(0xa50d629093d242afL, 0x9ae0b2fefc6ee754L, 0x7ef7796277a6785L, 0x7ef7796277a6786L, "protocol");
  }
}
