package org.iets3.protocol.transport.intentions;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import org.iets3.core.expr.base.behavior.Expression__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.ui.Messages;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class DeriveProtocolErrorHandler {

  private StringBuilder errorText = null;

  public void appendMissingMapError(SNode mapping, Iterable<SNode> notMappedElements) {
    if (errorText == null) {
      initStringBuilder();
    }
    errorText.append(Expression__BehaviorDescriptor.renderReadable_id4Y0vh0cfqjE.invoke(SLinkOperations.getTarget(mapping, LINKS.mappingSource$IdG3)) + " <b>to</b> " + Expression__BehaviorDescriptor.renderReadable_id4Y0vh0cfqjE.invoke(SLinkOperations.getTarget(mapping, LINKS.mappingTarget$zDSl)) + " -> ");
    errorText.append("<b>" + notMappedElements + "</b>");
    errorText.append(" not mapped to any protocol<br/><br/>");
  }

  public void appendNonCommonMapsError(SNode mapping, Iterable<SNode> mappedElements) {
    if (errorText == null) {
      initStringBuilder();
    }
    errorText.append(Expression__BehaviorDescriptor.renderReadable_id4Y0vh0cfqjE.invoke(SLinkOperations.getTarget(mapping, LINKS.mappingSource$IdG3)) + " <b>to</b> " + Expression__BehaviorDescriptor.renderReadable_id4Y0vh0cfqjE.invoke(SLinkOperations.getTarget(mapping, LINKS.mappingTarget$zDSl)) + " -> ");
    errorText.append(" Could not find any common protocol for ");
    errorText.append("<b>" + mappedElements + "</b><br/><br/>");

  }
  public void appendNotSuitableHardwareError(SNode mapping, Iterable<SConcept> candidateProtocols, Iterable<SNode> connectorType) {
    if (errorText == null) {
      initStringBuilder();
    }
    errorText.append(Expression__BehaviorDescriptor.renderReadable_id4Y0vh0cfqjE.invoke(SLinkOperations.getTarget(mapping, LINKS.mappingSource$IdG3)) + " <b>to</b> " + Expression__BehaviorDescriptor.renderReadable_id4Y0vh0cfqjE.invoke(SLinkOperations.getTarget(mapping, LINKS.mappingTarget$zDSl)) + " -> ");
    errorText.append("None of the mapped protocols <b>" + Sequence.fromIterable(candidateProtocols).select((it) -> SConceptOperations.conceptAlias(it)) + "</b>");
    errorText.append(" matches available connector types <b>" + connectorType + "</b><br/><br/>");
  }

  private void initStringBuilder() {
    errorText = new StringBuilder("<html>Could not derive protocols for :<br/><br/>");
  }

  public boolean hasErrorsToShow() {
    return errorText != null;
  }

  public void showErrorMessage() {
    ApplicationManager.getApplication().invokeLater(() -> Messages.showErrorDialog(errorText.toString(), "Could not derive protocols"));
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink mappingSource$IdG3 = MetaAdapterFactory.getContainmentLink(0x8c1ef69abcac4cb5L, 0x96196b27d0aefc0cL, 0x2b39747c07e31164L, 0x2b39747c07ec721bL, "mappingSource");
    /*package*/ static final SContainmentLink mappingTarget$zDSl = MetaAdapterFactory.getContainmentLink(0x8c1ef69abcac4cb5L, 0x96196b27d0aefc0cL, 0x2b39747c07e31164L, 0x2b39747c07f144eeL, "mappingTarget");
  }
}
