package org.iets3.core.expr.typetags.physunits.plugin;

/*Generated by MPS */

import com.google.common.collect.Multimap;
import org.jetbrains.mps.openapi.model.SNode;
import com.google.common.collect.HashMultimap;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.iets3.core.expr.typetags.physunits.behavior.UnitConversionUtil;
import org.iets3.core.expr.typetags.physunits.behavior.UnitSubsumption;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SProperty;

public class UnitTypesPrimitiveTypeMapperHelper {
  private UnitTypesPrimitiveTypeMapperHelper() {
  }
  public static Multimap<SNode, SNode> createUnitSpec2TypesMap(Iterable<SNode> typesWithUnit) {
    final Multimap<SNode, SNode> unitSpec2TypesMap = HashMultimap.create();
    Sequence.fromIterable(typesWithUnit).visitAll((typeWithUnit) -> {
      SNode unitSpecOfType = SNodeOperations.as(UnitConversionUtil.getSpecification(typeWithUnit), CONCEPTS.UnitSpecification$6j);
      SNode unitSpecInMap = UnitTypesPrimitiveTypeMapperHelper.findUnitSpecificationInKey(unitSpec2TypesMap, unitSpecOfType);
      unitSpec2TypesMap.put(unitSpecInMap, typeWithUnit);
    });
    return unitSpec2TypesMap;
  }

  public static SNode findUnitSpecificationInKey(Multimap<SNode, SNode> unitSpec2TaggedType, SNode unitSpecification) {
    for (SNode unitSpecInMap : unitSpec2TaggedType.keySet()) {
      if (UnitSubsumption.subsumes(unitSpecInMap, unitSpecification)) {
        return unitSpecInMap;
      }
    }
    return unitSpecification;
  }

  public static SNode createRuntimeErrorType(Iterable<SNode> nodesWithError) {
    SNode runtimeErrorType = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x113f84956f9L, "jetbrains.mps.lang.typesystem.structure.RuntimeErrorType"));
    String typesErrorMsg = IterableUtils.join(Sequence.fromIterable(nodesWithError).select((it) -> (String) BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(it)), ", ");
    SPropertyOperations.assign(runtimeErrorType, PROPS.errorText$leWQ, String.format("The different types \"%s\" are incompatible. Only types with same unit are compatible.", typesErrorMsg));
    return runtimeErrorType;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept UnitSpecification$6j = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d411dL, "org.iets3.core.expr.typetags.physunits.structure.UnitSpecification");
  }

  private static final class PROPS {
    /*package*/ static final SProperty errorText$leWQ = MetaAdapterFactory.getProperty(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x113f84956f9L, 0x113f84956faL, "errorText");
  }
}
