package org.iets3.core.expr.typetags.physunits.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.AbstractInequationReplacementRule_Runtime;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.typesystem.runtime.IsApplicable2Status;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import java.util.Map;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.iets3.core.expr.typetags.behavior.BaseTaggedTypeHelper;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import org.iets3.core.expr.typetags.behavior.ITag__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.MPSModuleRepository;
import org.iets3.core.expr.typetags.physunits.behavior.StandardUnitHelper;
import jetbrains.mps.typechecking.TypecheckingFacade;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.iets3.core.expr.typetags.physunits.behavior.UnitSubsumption;
import jetbrains.mps.typesystem.inference.EquationInfo;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.List;
import java.util.Objects;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.iets3.core.expr.typetags.physunits.behavior.IUnit__BehaviorDescriptor;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.errors.IErrorReporter;
import jetbrains.mps.lang.typesystem.runtime.HUtil;
import jetbrains.mps.lang.typesystem.runtime.IsApplicableStatus;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class unitsAreCompatibleWithQuantity_InequationReplacementRule extends AbstractInequationReplacementRule_Runtime {
  public unitsAreCompatibleWithQuantity_InequationReplacementRule() {
  }
  public boolean isApplicableCustom(SNode subtype, SNode supertype, IsApplicable2Status status) {
    if (!(SNodeOperations.isInstanceOf(subtype, CONCEPTS.TaggedType$O4) | SNodeOperations.isInstanceOf(supertype, CONCEPTS.TaggedType$O4))) {
      return false;
    }

    Tuples._2<SNode, Map<SAbstractConcept, SNode>> subComponents = BaseTaggedTypeHelper.getComponents(subtype);
    Tuples._2<SNode, Map<SAbstractConcept, SNode>> supComponents = BaseTaggedTypeHelper.getComponents(supertype);
    SNode subBaseType = subComponents._0();
    SNode supBaseType = supComponents._0();
    Map<SAbstractConcept, SNode> subTagMap = subComponents._1();
    Map<SAbstractConcept, SNode> supTagMap = supComponents._1();

    SNode supQuantity = MapSequence.fromMap(supTagMap).get(CONCEPTS.QuantitySpecification$4N);
    SNode supUnit = MapSequence.fromMap(supTagMap).get(CONCEPTS.UnitSpecification$6j);
    SNode subUnit = MapSequence.fromMap(subTagMap).get(CONCEPTS.UnitSpecification$6j);

    if ((supQuantity != null) && (subUnit != null)) {
      return (boolean) ITag__BehaviorDescriptor.subsumes_id1RcasK0V7Pl.invoke(SNodeOperations.asSConcept(CONCEPTS.QuantitySpecification$4N), subUnit, supQuantity);
    }

    if ((supQuantity == null) && (subUnit == null)) {
      SNode unitRef = SNodeOperations.as(SLinkOperations.getTarget(SNodeOperations.as(supUnit, CONCEPTS.UnitSpecification$6j), LINKS.specification$d6YI), CONCEPTS.UnitReference$Zo);
      MPSModuleRepository repository = MPSModuleRepository.getInstance();
      if (StandardUnitHelper.isUnitLessUnit(SNodeOperations.as(SLinkOperations.getTarget(unitRef, LINKS.unit$nTeG), CONCEPTS.Unit$Gq), repository)) {
        return true;
      }
    }

    if (!(TypecheckingFacade.getFromContext().isSubtype(subBaseType, supBaseType))) {
      return false;
    }

    for (SAbstractConcept key : SetSequence.fromSet(MapSequence.fromMap(subTagMap).keySet())) {
      SNode subTag = MapSequence.fromMap(subTagMap).get(key);
      SNode supTag = MapSequence.fromMap(supTagMap).get(key);
      if (!(UnitSubsumption.subsumes(subTag, supTag))) {
        return false;
      }
    }

    return supUnit != null && subUnit != null;
  }
  public void processInequation(final SNode subtype, final SNode supertype, final EquationInfo equationInfo, final TypeCheckingContext typeCheckingContext, IsApplicable2Status status, final boolean inequalityIsWeak, final boolean inequalityIsLessThan) {
    if (equationInfo == null) {
      return;
    }
    SNode nodeWithError = equationInfo.getNodeWithError();

    for (SNode taggedExpression : ListSequence.fromList(SNodeOperations.getNodeDescendants(nodeWithError, CONCEPTS.TaggedExpression$jU, true, new SAbstractConcept[]{}))) {
      Tuples._2<SNode, Map<SAbstractConcept, SNode>> subComponents = BaseTaggedTypeHelper.getComponents(subtype);
      Map<SAbstractConcept, SNode> subTagMap = subComponents._1();

      Tuples._2<SNode, Map<SAbstractConcept, SNode>> supComponents = BaseTaggedTypeHelper.getComponents(supertype);
      Map<SAbstractConcept, SNode> supTagMap = supComponents._1();

      SNode subUnit = MapSequence.fromMap(subTagMap).get(CONCEPTS.UnitSpecification$6j);
      SNode supUnit = MapSequence.fromMap(supTagMap).get(CONCEPTS.UnitSpecification$6j);

      if (subUnit == null || supUnit == null) {
        continue;
      }

      SNode subSpecification = SLinkOperations.getTarget(SNodeOperations.as(subUnit, CONCEPTS.UnitSpecification$6j), LINKS.specification$d6YI);
      SNode supSpecification = SLinkOperations.getTarget(SNodeOperations.as(supUnit, CONCEPTS.UnitSpecification$6j), LINKS.specification$d6YI);

      List<SNode> subReferences = SNodeOperations.getNodeDescendants(subSpecification, CONCEPTS.UnitReference$Zo, true, new SAbstractConcept[]{});
      List<SNode> supReferences = SNodeOperations.getNodeDescendants(supSpecification, CONCEPTS.UnitReference$Zo, true, new SAbstractConcept[]{});

unitReferencesLabel:
      for (int i = 0; i < ListSequence.fromList(subReferences).count(); i++) {
        if (i >= ListSequence.fromList(supReferences).count()) {
          break unitReferencesLabel;
        }
        SNode unitRefSub = ListSequence.fromList(subReferences).getElement(i);
        SNode unitRefSup = ListSequence.fromList(supReferences).getElement(i);
        if (unitRefSup == null || unitRefSub == null || (Objects.equals(SLinkOperations.getTarget(unitRefSub, LINKS.unit$nTeG), SLinkOperations.getTarget(unitRefSup, LINKS.unit$nTeG)) && Objects.equals(SPropertyOperations.getString(unitRefSub, PROPS.prefix$AtV), SPropertyOperations.getString(unitRefSup, PROPS.prefix$AtV)) || !(Objects.equals(IUnit__BehaviorDescriptor.quantity_id7JDqwWRWT0R.invoke(SLinkOperations.getTarget(unitRefSub, LINKS.unit$nTeG)), IUnit__BehaviorDescriptor.quantity_id7JDqwWRWT0R.invoke(SLinkOperations.getTarget(unitRefSup, LINKS.unit$nTeG)))))) {
          continue unitReferencesLabel;
        }

        String errorMessage = QuantityCompatibilityChecker.check(taggedExpression, unitRefSub, unitRefSup);
        if (errorMessage != null) {
          {
            final MessageTarget errorTarget = new NodeMessageTarget();
            IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(nodeWithError, errorMessage, "r:d4f1532d-fc5c-419f-84ee-daef42867c8e(org.iets3.core.expr.typetags.physunits.typesystem)", "7397572119145678609", null, errorTarget);
            HUtil.addAdditionalRuleIdsFromInfo(_reporter_2309309498, equationInfo);
          }
        }
      }
    }
  }
  public boolean checkInequation(final SNode subtype, final SNode supertype, final EquationInfo equationInfo, IsApplicable2Status status, final boolean inequalityIsWeak, final boolean inequalityIsLessThan) {
    boolean result_14532009 = true;
    {
      if (equationInfo == null) {
        return result_14532009;
      }
      SNode nodeWithError = equationInfo.getNodeWithError();

      for (SNode taggedExpression : ListSequence.fromList(SNodeOperations.getNodeDescendants(nodeWithError, CONCEPTS.TaggedExpression$jU, true, new SAbstractConcept[]{}))) {
        Tuples._2<SNode, Map<SAbstractConcept, SNode>> subComponents = BaseTaggedTypeHelper.getComponents(subtype);
        Map<SAbstractConcept, SNode> subTagMap = subComponents._1();

        Tuples._2<SNode, Map<SAbstractConcept, SNode>> supComponents = BaseTaggedTypeHelper.getComponents(supertype);
        Map<SAbstractConcept, SNode> supTagMap = supComponents._1();

        SNode subUnit = MapSequence.fromMap(subTagMap).get(CONCEPTS.UnitSpecification$6j);
        SNode supUnit = MapSequence.fromMap(supTagMap).get(CONCEPTS.UnitSpecification$6j);

        if (subUnit == null || supUnit == null) {
          continue;
        }

        SNode subSpecification = SLinkOperations.getTarget(SNodeOperations.as(subUnit, CONCEPTS.UnitSpecification$6j), LINKS.specification$d6YI);
        SNode supSpecification = SLinkOperations.getTarget(SNodeOperations.as(supUnit, CONCEPTS.UnitSpecification$6j), LINKS.specification$d6YI);

        List<SNode> subReferences = SNodeOperations.getNodeDescendants(subSpecification, CONCEPTS.UnitReference$Zo, true, new SAbstractConcept[]{});
        List<SNode> supReferences = SNodeOperations.getNodeDescendants(supSpecification, CONCEPTS.UnitReference$Zo, true, new SAbstractConcept[]{});

unitReferencesLabel:
        for (int i = 0; i < ListSequence.fromList(subReferences).count(); i++) {
          if (i >= ListSequence.fromList(supReferences).count()) {
            break unitReferencesLabel;
          }
          SNode unitRefSub = ListSequence.fromList(subReferences).getElement(i);
          SNode unitRefSup = ListSequence.fromList(supReferences).getElement(i);
          if (unitRefSup == null || unitRefSub == null || (Objects.equals(SLinkOperations.getTarget(unitRefSub, LINKS.unit$nTeG), SLinkOperations.getTarget(unitRefSup, LINKS.unit$nTeG)) && Objects.equals(SPropertyOperations.getString(unitRefSub, PROPS.prefix$AtV), SPropertyOperations.getString(unitRefSup, PROPS.prefix$AtV)) || !(Objects.equals(IUnit__BehaviorDescriptor.quantity_id7JDqwWRWT0R.invoke(SLinkOperations.getTarget(unitRefSub, LINKS.unit$nTeG)), IUnit__BehaviorDescriptor.quantity_id7JDqwWRWT0R.invoke(SLinkOperations.getTarget(unitRefSup, LINKS.unit$nTeG)))))) {
            continue unitReferencesLabel;
          }

          String errorMessage = QuantityCompatibilityChecker.check(taggedExpression, unitRefSub, unitRefSup);
          if (errorMessage != null) {
            result_14532009 = false;
          }
        }
      }
    }
    return result_14532009;
  }
  public boolean isWeak() {
    return true;
  }
  public IsApplicableStatus isApplicableSubtypeAndPattern(SNode node) {
    return new IsApplicableStatus(node.getConcept().isSubConceptOf(getApplicableSubtypeConcept()), null);
  }
  public IsApplicableStatus isApplicableSupertypeAndPattern(SNode node) {
    return new IsApplicableStatus(node.getConcept().isSubConceptOf(getApplicableSupertypeConcept()), null);
  }

  public SAbstractConcept getApplicableSubtypeConcept() {
    return CONCEPTS.Type$WK;
  }
  public SAbstractConcept getApplicableSupertypeConcept() {
    return CONCEPTS.Type$WK;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept TaggedType$O4 = MetaAdapterFactory.getConcept(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x186a8ed9947750b6L, "org.iets3.core.expr.typetags.structure.TaggedType");
    /*package*/ static final SConcept QuantitySpecification$4N = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x729d46b7ce8b64dcL, "org.iets3.core.expr.typetags.physunits.structure.QuantitySpecification");
    /*package*/ static final SConcept UnitSpecification$6j = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d411dL, "org.iets3.core.expr.typetags.physunits.structure.UnitSpecification");
    /*package*/ static final SConcept UnitReference$Zo = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d4dc5L, "org.iets3.core.expr.typetags.physunits.structure.UnitReference");
    /*package*/ static final SConcept Unit$Gq = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d373fL, "org.iets3.core.expr.typetags.physunits.structure.Unit");
    /*package*/ static final SConcept TaggedExpression$jU = MetaAdapterFactory.getConcept(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x2ea11acb50fe9dabL, "org.iets3.core.expr.typetags.structure.TaggedExpression");
    /*package*/ static final SConcept Type$WK = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x670d5e92f854a614L, "org.iets3.core.expr.base.structure.Type");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink specification$d6YI = MetaAdapterFactory.getContainmentLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d411dL, 0x73b48a125b0dab03L, "specification");
    /*package*/ static final SReferenceLink unit$nTeG = MetaAdapterFactory.getReferenceLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d4dc5L, 0x73b48a125b0daafcL, "unit");
  }

  private static final class PROPS {
    /*package*/ static final SProperty prefix$AtV = MetaAdapterFactory.getProperty(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d4dc5L, 0x79d6409d1866689aL, "prefix");
  }
}
