package org.iets3.core.expr.typetags.physunits.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import java.util.Comparator;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.jetbrains.mps.openapi.language.SEnumerationLiteral;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;

public interface IUnitLangConfig {


  enum ConversionSpecifierSelection {
    FIRST_APPLICABLE(),
    DEFINED_IN_CONVERT_EXPESSION()
  }

  enum MinimizationStrategy {
    DIVISION(),
    MULTIPLICATION()
  }

  /**
   * Returns the priority of the current configuration. The configuration with the highest priority will be chosen.
   */
  int getPriorityLevel();

  /**
   * Returns the conversion specifier that should be used in convert expressions. It can be the first applicable specifier
   * or the one selected in the convert expression.
   */
  ConversionSpecifierSelection getConversionSpecifierSelection();

  /**
   * Returns the minimization strategy for reducing group-like expressions e.g. quantity and unit specification expression.
   * It is used to make expressions that use different mathematical operations but are semantically equivalent comparable by
   * reducing them by using the selected strategy.
   */
  MinimizationStrategy getMinimizationStrategy();

  /**
   * Returns the name used for quantities in the UI.
   */
  String getQuantitySpecifier();

  /**
   * Returns the name used for dimensions in the  UI.
   */
  String getDimensionSpecifier();

  /**
   * Returns the name used for the unspecified dimension in the UI.
   */
  String getUnspecifiedQuantifierSpecifier();

  /**
   * Returns the name used for the unspecified dimension in the UI.
   */
  default String getUnitLessUnitName() {
    return "unitless";
  }

  /**
   * Returns true if "/" should be used in unit names instead of "รท"
   */
  default boolean useSlashInsteadOfDivisionSymbol() {
    return false;
  }

  /**
   * Returns true if implicit conversions between prefixes (for example: metric, binary) are enabled and conversion rules
   * that are marked as "implicit" are taken into account.
   */
  boolean implicitConversionIsEnabled();


  /**
   * Returns true if implicit conversions are enabled for a specific tagged expression. A use case could be, for example,
   * to activate them if they are part of a binary expression.
   */
  default boolean implicitConversionIsEnabledAt(SNode taggedExpression) {
    return true;
  }

  /**
   * Allows compatible unit specifications (e.g. different prefix than expected) without implicit conversions being enabled.
   * 
   * Introduced to support the new, stricter unit compatibility check without forcing activation of the implicit conversions.
   */
  default boolean allowMixingCompatibleQuantitiesWithoutConversions() {
    return false;
  }


  /**
   * Returns the comparator used to order exponents in group-like expressions e.g. quantity and unit specification expression.
   */
  Comparator<SNode> getExponentComparator();

  default Map<SNodeReference, SEnumerationLiteral> getOverwrittenScaling() {
    return MapSequence.fromMap(new HashMap<SNodeReference, SEnumerationLiteral>());
  }
}
