package org.iets3.core.expr.typetags.physunits.behavior;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import java.util.Map;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.iets3.core.expr.typetags.behavior.BaseTaggedTypeHelper;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.iets3.core.expr.base.runtime.runtime.Fraction;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.Collections;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import com.mbeddr.core.base.behavior.IDetectCycle__BehaviorDescriptor;
import java.util.HashMap;
import java.util.Queue;
import jetbrains.mps.internal.collections.runtime.QueueSequence;
import java.util.LinkedList;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.iets3.core.expr.simpleTypes.behavior.NumberLiteral__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Set;
import java.util.HashSet;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.newTypesystem.context.IncrementalTypecheckingContext;
import jetbrains.mps.typesystem.inference.TypeChecker;
import java.util.Objects;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.language.SEnumerationLiteral;
import org.jetbrains.mps.openapi.model.SNodeReference;
import org.iets3.core.expr.typetags.physunits.plugin.PhysUnitLangConfigHelper;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class UnitConversionUtil {

  public static SNode getSpecification(SNode type) {
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.TaggedType$O4)) {
      Tuples._2<SNode, Map<SAbstractConcept, SNode>> components = BaseTaggedTypeHelper.getComponents(type);
      Map<SAbstractConcept, SNode> tagMap = components._1();
      SNode unitTag = tagMap.get(CONCEPTS.UnitSpecification$6j);
      if ((unitTag != null)) {
        return SNodeOperations.as(unitTag, CONCEPTS.UnitSpecification$6j);
      }

      SNode quantityTag = tagMap.get(CONCEPTS.QuantitySpecification$4N);
      return SNodeOperations.as(quantityTag, CONCEPTS.QuantitySpecification$4N);

    } else {
      return null;
    }
  }

  public static boolean hasSpecification(SNode type) {
    return getSpecification(type) != null;
  }

  public static boolean isAtomicUnit(SNode unit) {
    List<SNode> components = ISpecification__BehaviorDescriptor.components_id1KUmgSF_6Sp.invoke(IUnit__BehaviorDescriptor.specification_id1KUmgSF_6QP.invoke(unit));
    return components == null || ListSequence.fromList(components).isEmpty();
  }

  public static boolean isIntegerType(SNode type) {
    SNode innerType = getInnerType(type);
    if (SNodeOperations.isInstanceOf(innerType, CONCEPTS.MeetType$ZG)) {
      return ListSequence.fromList(SLinkOperations.getChildren(SNodeOperations.cast(innerType, CONCEPTS.MeetType$ZG), LINKS.argument$r2cT)).any((it) -> isIntegerType(it));
    } else {
      return SNodeOperations.isInstanceOf(innerType, CONCEPTS.IntegerType$7a);
    }
  }

  public static SNode getInnerType(SNode type) {
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.TaggedType$O4)) {
      return SNodeOperations.copyNode(SLinkOperations.getTarget(SNodeOperations.cast(type, CONCEPTS.TaggedType$O4), LINKS.baseType$z6Mz));
    } else {
      return SNodeOperations.copyNode(type);
    }
  }

  /**
   * Returns true if the given map represents a unitless mapping, 
   * meaning the map is empty or null. 
   * 
   * @param unitMap the unit mapping
   * @return true if the mapping represents a unitless mapping, false otherwise
   */
  public static boolean isUnitLessType(Map<SNode, Fraction> unitMap) {
    if (unitMap == null || MapSequence.fromMap(unitMap).isEmpty()) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * Returns true of the given type is a unitless type. 
   * 
   * @param type the type
   * @return true if the type has no unit annotation, false otherwise
   */
  public static boolean isUnitLessType(SNode type) {
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.TaggedType$O4)) {
      SNode specification = getSpecification(type);
      Map<NamedKeyWrapper, Fraction> spec = getMap_Group(IUnitSpecification__BehaviorDescriptor.getExpression_id6q45UTytEvW.invoke(specification));
      return MapSequence.fromMap(spec).isEmpty();
    } else {
      return true;
    }
  }

  /**
   * Returns the mapping for the given type. 
   * If the given type is not an annotated type then an empty map will be returned. 
   * 
   * @param type the type
   * @return the unit mapping
   */
  public static Map<NamedKeyWrapper, Fraction> getMap_Type(SNode type) {
    if (SNodeOperations.isInstanceOf(type, CONCEPTS.TaggedType$O4)) {
      SNode specification = getSpecification(type);
      return getMap_Group(IUnitSpecification__BehaviorDescriptor.getExpression_id6q45UTytEvW.invoke(specification));
    } else {
      return Collections.<NamedKeyWrapper,Fraction>emptyMap();
    }
  }

  public static boolean isSelfReferencingUnit(SNode unit) {
    return SetSequence.fromSet(IDetectCycle__BehaviorDescriptor.getCyclicDependencyElements_id17fjvcLFUH5.invoke(unit)).contains(unit);
  }

  /**
   * Generates the mapping from the given group expression. 
   * Composite groups are always broken down to atomic groups 
   * 
   * This method returns a new mapping. 
   */
  public static Map<NamedKeyWrapper, Fraction> getMap_Group(SNode group) {
    Map<NamedKeyWrapper, Fraction> result = MapSequence.fromMap(new HashMap<NamedKeyWrapper, Fraction>());
    if ((boolean) IDetectCycle__BehaviorDescriptor.isInvolvedInCycle_id59HbAIOYtvQ.invoke(SNodeOperations.getNodeAncestor(group, CONCEPTS.IDetectCycle$wy, false, false))) {
      return result;
    }

    result = getMap_Group(group, getExponent(group));
    return result;
  }

  /**
   * Generates the mapping from the given group expression and multiplies all the exponents with the given one. 
   * Composite groups are always broken down to atomic groups 
   * 
   * This method returns a new mapping. 
   */
  public static Map<NamedKeyWrapper, Fraction> getMap_Group(SNode expr, Fraction exponent) {
    Map<NamedKeyWrapper, Fraction> result = MapSequence.fromMap(new HashMap<NamedKeyWrapper, Fraction>());

    Queue<Tuples._2<SNode, Fraction>> queue = QueueSequence.fromQueue(new LinkedList<Tuples._2<SNode, Fraction>>());
    QueueSequence.fromQueue(queue).addLastElement(MultiTuple.<SNode,Fraction>from(expr, exponent));

    while (QueueSequence.fromQueue(queue).isNotEmpty()) {
      Tuples._2<SNode, Fraction> headPair = QueueSequence.fromQueue(queue).removeFirstElement();

      SNode headExpr = headPair._0();
      Fraction headExponent = headPair._1();

      {
        final SNode unitRef = headExpr;
        if (SNodeOperations.isInstanceOf(unitRef, CONCEPTS.IReference$$s)) {
          if ((boolean) IDetectCycle__BehaviorDescriptor.isInvolvedInCycle_id59HbAIOYtvQ.invoke(SNodeOperations.as(IReference__BehaviorDescriptor.getReferencedNode_id6q45UTyu4YY.invoke(unitRef), CONCEPTS.IDetectCycle$wy))) {
            return result;
          }
          SNode specification = SLinkOperations.getTarget(((SNode) IReference__BehaviorDescriptor.getReferencedNode_id6q45UTyu4YY.invoke(unitRef)), LINKS.specification$Tp$k);
          if ((specification == null)) {
            result = unify_inplace(result, new NamedKeyWrapper(unitRef), headExponent);
          } else {
            result = unify(result, getMap_Group(IUnitSpecification__BehaviorDescriptor.getExpression_id6q45UTytEvW.invoke(specification), getExponent(IUnitSpecification__BehaviorDescriptor.getExpression_id6q45UTytEvW.invoke(specification))));
          }
        } else if (SNodeOperations.isInstanceOf(unitRef, CONCEPTS.IGroupPower$Z2)) {
          final SNode _unitExp = headExpr;

          QueueSequence.fromQueue(queue).addLastElement(MultiTuple.<SNode,Fraction>from(IGroupPower__BehaviorDescriptor.getBase_id1JynhuWs9Jp.invoke(_unitExp), headExponent));
        } else if (SNodeOperations.isInstanceOf(unitRef, CONCEPTS.IGroupMultiplication$Y1)) {
          final SNode _unitMul = headExpr;

          SNode unitMul = _unitMul;
          QueueSequence.fromQueue(queue).addLastElement(MultiTuple.<SNode,Fraction>from(IGroupMultiplication__BehaviorDescriptor.getLeft_id1JynhuWs0Bg.invoke(unitMul), getExponent(IGroupMultiplication__BehaviorDescriptor.getLeft_id1JynhuWs0Bg.invoke(unitMul)).multiply(headExponent)));
          QueueSequence.fromQueue(queue).addLastElement(MultiTuple.<SNode,Fraction>from(IGroupMultiplication__BehaviorDescriptor.getRight_id1JynhuWs0LF.invoke(unitMul), getExponent(IGroupMultiplication__BehaviorDescriptor.getRight_id1JynhuWs0LF.invoke(unitMul)).multiply(headExponent)));
        } else if (SNodeOperations.isInstanceOf(unitRef, CONCEPTS.IGroupDivision$DT)) {
          final SNode _unitDiv = headExpr;

          SNode unitDiv = _unitDiv;
          QueueSequence.fromQueue(queue).addLastElement(MultiTuple.<SNode,Fraction>from(IGroupDivision__BehaviorDescriptor.getNumerator_id1JynhuWrSSG.invoke(unitDiv), getExponent(IGroupDivision__BehaviorDescriptor.getNumerator_id1JynhuWrSSG.invoke(unitDiv)).divide(headExponent)));
          QueueSequence.fromQueue(queue).addLastElement(MultiTuple.<SNode,Fraction>from(IGroupDivision__BehaviorDescriptor.getDenominator_id1JynhuWrTer.invoke(unitDiv), getExponent(IGroupDivision__BehaviorDescriptor.getDenominator_id1JynhuWrTer.invoke(unitDiv)).divide(headExponent).negate()));
        }
      }
    }

    return result;
  }

  /**
   * Generates the mapping from the given unit and multiplies all the exponents with the given one. 
   * Composite units are always broken down to atomic units. 
   * 
   * This method returns a new mapping. 
   */
  public static Map<NamedKeyWrapper, Fraction> getMap_IUnit(SNode iunit, Fraction exponent) {
    Map<NamedKeyWrapper, Fraction> result = MapSequence.fromMap(new HashMap<NamedKeyWrapper, Fraction>());
    if ((boolean) IDetectCycle__BehaviorDescriptor.isInvolvedInCycle_id59HbAIOYtvQ.invoke(iunit) || StandardUnitHelper.isUnitLessUnit(SNodeOperations.as(iunit, CONCEPTS.Unit$Gq), SNodeOperations.getModel(iunit).getRepository())) {
      return result;
    }

    SNode expr = SLinkOperations.getTarget(SNodeOperations.as(IUnit__BehaviorDescriptor.specification_id1KUmgSF_6QP.invoke(iunit), CONCEPTS.UnitSpecification$6j), LINKS.specification$d6YI);
    {
      final SNode unit = iunit;
      if (SNodeOperations.isInstanceOf(unit, CONCEPTS.Unit$Gq)) {
        if ((expr == null)) {
          MapSequence.fromMap(result).put(new NamedKeyWrapper(createUnitReference_5ohk72_a0a0a0a0a4a32(unit)), exponent);
        } else {
          return getMap_Group(expr, getExponent(expr));
        }
      }
    }
    return result;
  }

  public static Map<NamedKeyWrapper, Fraction> getMap_IUnit(SNode unit, int exponent) {
    return getMap_IUnit(unit, new Fraction(exponent));
  }

  public static Fraction getExponent(SNode expr) {
    {
      final SNode powerGroup = expr;
      if (SNodeOperations.isInstanceOf(powerGroup, CONCEPTS.IGroupPower$Z2)) {
        return IGroupPower__BehaviorDescriptor.getExp_id1JynhuWslGU.invoke(powerGroup);
      }
    }
    return new Fraction(1);
  }

  /**
   * Divides all of the exponents in the mapping with the given value if it is possible.
   * As fractions are used in their minimal form this can only be possible if two fractions 
   * have the exact same denominator and the modulo check should be performed with their numerators. 
   * 
   * This method returns a new mapping. 
   */
  public static Map<SNode, Fraction> rootBy(Map<SNode, Fraction> unitMap, SNode root) {
    Map<SNode, Fraction> result = MapSequence.fromMap(new HashMap<SNode, Fraction>());
    Fraction rootFraction = new Fraction((int) Exponent__BehaviorDescriptor.getNumerator_id3j3yk3guAC3.invoke(root), (int) Exponent__BehaviorDescriptor.getDenominator_id3j3yk3guABz.invoke(root));

    for (SNode key : SetSequence.fromSet(MapSequence.fromMap(unitMap).keySet())) {
      MapSequence.fromMap(result).put(key, MapSequence.fromMap(unitMap).get(key).divide(rootFraction));
    }

    return result;
  }

  /**
   * Reduces the given mapping with an other mapping. This means that all of the exponents will be 
   * subtracted in the mapping with the corresponding exponent from the other mapping. If a unit is 
   * not present in the original mapping, then the inverse exponent of the other mapping's node will be inserted. 
   * Nodes with zero exponents are eliminated from the resulting mapping. 
   * 
   * This method returns a new mapping. 
   */
  public static Map<NamedKeyWrapper, Fraction> reduceBy(Map<NamedKeyWrapper, Fraction> unitMap, Map<NamedKeyWrapper, Fraction> withWhom) {
    Map<NamedKeyWrapper, Fraction> result = MapSequence.fromMap(new HashMap<NamedKeyWrapper, Fraction>());
    MapSequence.fromMap(result).putAll(unitMap);

    for (NamedKeyWrapper key : SetSequence.fromSet(MapSequence.fromMap(withWhom).keySet())) {
      if (MapSequence.fromMap(result).containsKey(key)) {
        // rule out zero exponents
        if (MapSequence.fromMap(result).get(key).equals(MapSequence.fromMap(withWhom).get(key))) {
          MapSequence.fromMap(result).removeKey(key);
        } else {
          MapSequence.fromMap(result).put(key, MapSequence.fromMap(result).get(key).subtract(MapSequence.fromMap(withWhom).get(key)));
        }
      } else if (MapSequence.fromMap(withWhom).get(key).isNonZero()) {
        MapSequence.fromMap(result).put(key, MapSequence.fromMap(withWhom).get(key).multiply(-1));
      }
    }

    return result;
  }

  /**
   * Unifies the given mapping with an other mapping. This means that all of the exponents will be 
   * summed in the mapping with the corresponding exponent from the other mapping. If a node is not 
   * present in the original mapping, then the exponent of the other mapping's node will be inserted. 
   * Nodes with zero exponents are eliminated from the resulting unit mapping. 
   * 
   * This method returns a new mapping. 
   */
  public static Map<NamedKeyWrapper, Fraction> unify(Map<NamedKeyWrapper, Fraction> m1, Map<NamedKeyWrapper, Fraction> m2) {
    Map<NamedKeyWrapper, Fraction> res = MapSequence.fromMap(new HashMap<NamedKeyWrapper, Fraction>());
    MapSequence.fromMap(res).putAll(m1);
    for (NamedKeyWrapper key : SetSequence.fromSet(MapSequence.fromMap(m2).keySet())) {
      res = unify_inplace(res, key, MapSequence.fromMap(m2).get(key));
    }
    return res;
  }

  private static Map<NamedKeyWrapper, Fraction> unify_inplace(Map<NamedKeyWrapper, Fraction> mapping, NamedKeyWrapper key, Fraction exponent) {
    if (MapSequence.fromMap(mapping).containsKey(key)) {
      // rule out zero exponents
      if (MapSequence.fromMap(mapping).get(key).equals(exponent.multiply(-1))) {
        MapSequence.fromMap(mapping).removeKey(key);
      } else {
        MapSequence.fromMap(mapping).put(key, MapSequence.fromMap(mapping).get(key).add(exponent));
      }
    } else if (exponent.isNonZero()) {
      MapSequence.fromMap(mapping).put(key, exponent);
    }
    return mapping;
  }

  /**
   * It is expected that the passed map is already broken down to atomic units. 
   */
  public static List<SNode> createUnitReferences(Map<NamedKeyWrapper, Fraction> unitMap) {
    List<SNode> references = ListSequence.fromList(new ArrayList<SNode>());
    for (IMapping<NamedKeyWrapper, Fraction> entry : MapSequence.fromMap(unitMap)) {
      SNode key = entry.key().getKey();
      SNode referencedUnit = null;
      {
        final SNode unitReference = key;
        if (SNodeOperations.isInstanceOf(unitReference, CONCEPTS.UnitReference$Zo)) {
          referencedUnit = SLinkOperations.getTarget(unitReference, LINKS.unit$nTeG);
        }
      }
      {
        final SNode unit = key;
        if (SNodeOperations.isInstanceOf(unit, CONCEPTS.IUnit$tw)) {
          referencedUnit = unit;
        }
      }
      ListSequence.fromList(references).addElement(createUnitReference(referencedUnit, entry.value()));

    }
    return references;
  }

  public static SNode createUnitReference(SNode unit, Fraction exp) {
    SNode reference = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d4dc5L, "org.iets3.core.expr.typetags.physunits.structure.UnitReference"));
    SLinkOperations.setTarget(reference, LINKS.unit$nTeG, unit);

    // only insert the exponent if it does not equal to 1
    if (!(exp.equals(Fraction.ONE))) {
      SNode exponent;
      if (exp.denominator == 1) {
        exponent = createIntegerExponent_5ohk72_a0a0b0e0nb(exp.numerator);
      } else {
        exponent = createFractionalExponent_5ohk72_a0a0a1a4a93(NumberLiteral__BehaviorDescriptor.set_id2oUyrt$Tg3c.invoke(SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x46ff3b3d86d0e6daL, "org.iets3.core.expr.simpleTypes.structure.NumberLiteral")), "" + exp.numerator), NumberLiteral__BehaviorDescriptor.set_id2oUyrt$Tg3c.invoke(SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x46ff3b3d86d0e6daL, "org.iets3.core.expr.simpleTypes.structure.NumberLiteral")), "" + exp.denominator));
      }
      return createUnitExponent_5ohk72_a2a4a93(reference, exponent);
    }
    return reference;
  }

  public static Map<NamedKeyWrapper, Fraction> negate(Map<NamedKeyWrapper, Fraction> unitMap) {
    for (NamedKeyWrapper key : SetSequence.fromSet(MapSequence.fromMap(unitMap).keySet())) {
      MapSequence.fromMap(unitMap).put(key, MapSequence.fromMap(unitMap).get(key).multiply(-1));
    }
    return unitMap;
  }

  /**
   * This method modifies the original mapping. 
   */
  public static Map<NamedKeyWrapper, Fraction> multiply(Map<NamedKeyWrapper, Fraction> unitMap, Fraction m) {
    for (NamedKeyWrapper key : SetSequence.fromSet(MapSequence.fromMap(unitMap).keySet())) {
      MapSequence.fromMap(unitMap).put(key, MapSequence.fromMap(unitMap).get(key).multiply(m));
    }
    return unitMap;
  }

  /**
   * Checks whether two mappings can be possibly matched / exactly matched. 
   * 
   * In case of exact match check the unit mappings must be entirely the same.
   */
  public static Tuples._3<Boolean, List<SNode>, List<SNode>> matchingMappings(Map<NamedKeyWrapper, Fraction> leftUnitMap, Map<NamedKeyWrapper, Fraction> rightUnitMap) {
    if (leftUnitMap == null && rightUnitMap == null) {
      return MultiTuple.<Boolean,List<SNode>,List<SNode>>from(true, Sequence.fromIterable(Sequence.fromIterable(Collections.<SNode>emptyList())).toList(), Sequence.fromIterable(Sequence.fromIterable(Collections.<SNode>emptyList())).toList());
    }

    // remove units with zero exponents
    Map<NamedKeyWrapper, Fraction> leftNonMatched = MapSequence.fromMap(new HashMap<NamedKeyWrapper, Fraction>());
    Set<NamedKeyWrapper> keys = SetSequence.fromSet(new HashSet<NamedKeyWrapper>());
    for (NamedKeyWrapper key : SetSequence.fromSet(MapSequence.fromMap(leftUnitMap).keySet())) {
      if (MapSequence.fromMap(leftUnitMap).get(key).isNonZero()) {
        MapSequence.fromMap(leftNonMatched).put(key, MapSequence.fromMap(leftUnitMap).get(key));
        SetSequence.fromSet(keys).addElement(key);
      }
    }

    Map<NamedKeyWrapper, Fraction> rightNonMatched = MapSequence.fromMap(new HashMap<NamedKeyWrapper, Fraction>());
    for (NamedKeyWrapper key : SetSequence.fromSet(MapSequence.fromMap(rightUnitMap).keySet())) {
      if (MapSequence.fromMap(rightUnitMap).get(key).isNonZero()) {
        MapSequence.fromMap(rightNonMatched).put(key, MapSequence.fromMap(rightUnitMap).get(key));
      }
    }

    for (NamedKeyWrapper key : SetSequence.fromSet(keys)) {
      if (MapSequence.fromMap(leftNonMatched).containsKey(key) && MapSequence.fromMap(rightNonMatched).containsKey(key)) {
        Fraction le = MapSequence.fromMap(leftNonMatched).get(key);
        Fraction re = MapSequence.fromMap(rightNonMatched).get(key);
        int c = le.compareTo(re);

        if (c == 0) {
          MapSequence.fromMap(leftNonMatched).removeKey(key);
          MapSequence.fromMap(rightNonMatched).removeKey(key);
        } else if (c < 0) {
          MapSequence.fromMap(leftNonMatched).removeKey(key);
          MapSequence.fromMap(rightNonMatched).put(key, re.subtract(le));
        } else {
          MapSequence.fromMap(rightNonMatched).removeKey(key);
          MapSequence.fromMap(leftNonMatched).put(key, le.subtract(re));
        }
      }
    }
    return MultiTuple.<Boolean,List<SNode>,List<SNode>>from(MapSequence.fromMap(leftNonMatched).isEmpty() && MapSequence.fromMap(rightNonMatched).isEmpty(), SetSequence.fromSet(MapSequence.fromMap(leftNonMatched).keySet()).select((it) -> it.getKey()).toList(), SetSequence.fromSet(MapSequence.fromMap(rightNonMatched).keySet()).select((it) -> it.getKey()).toList());
  }


  /**
   * Calculates the sqrt of the nodes within the provided group and returns a new unit specification
   */
  public static SNode sqrt(SNode group) {
    Map<NamedKeyWrapper, Fraction> originalUnitMap = getMap_Group(group);
    final Map<NamedKeyWrapper, Fraction> sqrtUnitMap = MapSequence.fromMap(new HashMap<NamedKeyWrapper, Fraction>());

    MapSequence.fromMap(originalUnitMap).visitAll((it) -> MapSequence.fromMap(sqrtUnitMap).put(it.key(), it.value().sqrt()));

    return createUnitSpecification(sqrtUnitMap);
  }

  public static SNode pow(SNode group, final int power) {
    Map<NamedKeyWrapper, Fraction> originalUnitMap = getMap_Group(group);
    final Map<NamedKeyWrapper, Fraction> powUnitMap = MapSequence.fromMap(new HashMap<NamedKeyWrapper, Fraction>());

    MapSequence.fromMap(originalUnitMap).visitAll((it) -> {
      SNode key = it.key().getKey();
      SNode unit = null;
      {
        final SNode unitReference = key;
        if (SNodeOperations.isInstanceOf(unitReference, CONCEPTS.UnitReference$Zo)) {
          unit = SLinkOperations.getTarget(unitReference, LINKS.unit$nTeG);
        }
      }
      {
        final SNode iunit = key;
        if (SNodeOperations.isInstanceOf(iunit, CONCEPTS.IUnit$tw)) {
          unit = iunit;
        }
      }
      MapSequence.fromMap(powUnitMap).put(new NamedKeyWrapper(unit), it.value().pow(power));
    });

    return createUnitSpecification(powUnitMap);
  }

  public static SNode createUnitSpecification(Map<NamedKeyWrapper, Fraction> unitMap) {
    List<SNode> unitRefs = createUnitReferences(unitMap);
    SNode newUnitSpecifciation = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d411dL, "org.iets3.core.expr.typetags.physunits.structure.UnitSpecification"));
    SLinkOperations.setTarget(newUnitSpecifciation, LINKS.specification$d6YI, SNodeOperations.cast(createUnitMultiplication(unitRefs), CONCEPTS.UnitExpression$Xv));
    return newUnitSpecifciation;
  }

  public static SNode createUnitMultiplication(List<SNode> unitExprs) {
    if (ListSequence.fromList(unitExprs).isEmpty()) {
      return null;
    }

    if (ListSequence.fromList(unitExprs).count() == 1) {
      return ListSequence.fromList(unitExprs).first();
    }

    return (SNode) IGroupLike__BehaviorDescriptor.mkMultiply_id45a4DYZTqDU.invoke(ListSequence.fromList(unitExprs).first(), ListSequence.fromList(unitExprs).first(), createUnitMultiplication(ListSequence.fromList(unitExprs).skip(1).toList()));
  }

  public static List<SNode> extractUnitsFromMultiplication(SNode expr) {
    if ((expr == null)) {
      return new ArrayList<SNode>();
    }

    {
      final SNode mulExpr = expr;
      if (SNodeOperations.isInstanceOf(mulExpr, CONCEPTS.UnitMultiplication$sx)) {
        List<SNode> extractedExprs = ListSequence.fromList(new LinkedList<SNode>());
        ListSequence.fromList(extractedExprs).addSequence(ListSequence.fromList(extractUnitsFromMultiplication(SLinkOperations.getTarget(mulExpr, LINKS.left$sr9k))));
        ListSequence.fromList(extractedExprs).addSequence(ListSequence.fromList(extractUnitsFromMultiplication(SLinkOperations.getTarget(mulExpr, LINKS.right$2nEP))));
        return extractedExprs;
      }
    }

    return Sequence.fromIterable(Sequence.<SNode>singleton(expr)).toList();
  }

  public static SNode createQuantitySpecificationForUnit(SNode unit) {
    return createQuantitySpecification_5ohk72_a0a85(convertUnit2QuantityExpr(SLinkOperations.getTarget(SLinkOperations.getTarget(unit, LINKS.specification$Tp$k), LINKS.specification$d6YI)));
  }


  public static SNode convertUnit2QuantityExpr(SNode unitExpr) {
    {
      final SNode unitReference = unitExpr;
      if (SNodeOperations.isInstanceOf(unitReference, CONCEPTS.UnitReference$Zo)) {
        return createQuantityReference_5ohk72_a0a0a16(SLinkOperations.getTarget(SNodeOperations.as(SLinkOperations.getTarget(unitReference, LINKS.unit$nTeG), CONCEPTS.Unit$Gq), LINKS.quantity$tnl1));
      }
    }

    {
      final SNode unitDiv = unitExpr;
      if (SNodeOperations.isInstanceOf(unitDiv, CONCEPTS.UnitDivision$$9)) {
        return createQuantityDivision_5ohk72_a0a2a16(convertUnit2QuantityExpr(SLinkOperations.getTarget(unitDiv, LINKS.numerator$qo9G)), convertUnit2QuantityExpr(SLinkOperations.getTarget(unitDiv, LINKS.denominator$4xz7)));
      }
    }

    {
      final SNode unitMul = unitExpr;
      if (SNodeOperations.isInstanceOf(unitMul, CONCEPTS.UnitMultiplication$sx)) {
        return createQuantityMultiplication_5ohk72_a0a4a16(convertUnit2QuantityExpr(SLinkOperations.getTarget(unitMul, LINKS.left$sr9k)), convertUnit2QuantityExpr(SLinkOperations.getTarget(unitMul, LINKS.right$2nEP)));
      }
    }

    {
      final SNode unitExponent = unitExpr;
      if (SNodeOperations.isInstanceOf(unitExponent, CONCEPTS.UnitExponent$BW)) {
        return createQuantityExponent_5ohk72_a0a6a16(convertUnit2QuantityExpr(SLinkOperations.getTarget(unitExponent, LINKS.base$z8ie)), SNodeOperations.copyNode(SLinkOperations.getTarget(unitExponent, LINKS.exponent$z83d)));
      }
    }

    return null;
  }

  public static SNode createConversionSpecifierForPrefixedUnitReferences(SNode convertUnit, Map<NamedKeyWrapper, Fraction> sourceUnitMap, Map<NamedKeyWrapper, Fraction> targetUnitMap) {
    SNode expression = IConvertUnit__BehaviorDescriptor.getExpression_id7SygLIkQnGn.invoke(convertUnit);
    // deprecated getInstance is necessary to ensure compatibility with the command-line generator execution (MpsEnvironment)
    TypeCheckingContext typeChecking = new IncrementalTypecheckingContext(expression, TypeChecker.getInstance().getTypeCheckerHelper(), null);
    typeChecking.checkIfNotChecked(expression, false);
    SNode sourceType = typeChecking.typeOf(expression);
    typeChecking.dispose();
    SNode sourceSpecification = UnitConversionUtil.getSpecification(sourceType);
    {
      final SNode sourceExpression = IUnitSpecification__BehaviorDescriptor.getExpression_id6q45UTytEvW.invoke(sourceSpecification);
      if (SNodeOperations.isInstanceOf(sourceExpression, CONCEPTS.UnitReference$Zo)) {
        Map<NamedKeyWrapper, Fraction> sourceUnitMapCopy = MapSequence.fromMap(new HashMap<NamedKeyWrapper, Fraction>());
        for (IMapping<NamedKeyWrapper, Fraction> entry : MapSequence.fromMap(sourceUnitMap)) {
          MapSequence.fromMap(sourceUnitMapCopy).put(entry.key(), entry.value());
        }
        Map<NamedKeyWrapper, Fraction> targetUnitMapCopy = MapSequence.fromMap(new HashMap<NamedKeyWrapper, Fraction>());
        for (IMapping<NamedKeyWrapper, Fraction> entry : MapSequence.fromMap(targetUnitMap)) {
          MapSequence.fromMap(targetUnitMapCopy).put(entry.key(), entry.value());
        }
        for (IMapping<NamedKeyWrapper, Fraction> sourceUnitMapping : MapSequence.fromMap(sourceUnitMap)) {
          {
            final SNode sourceUnitMappingUnitReference = sourceUnitMapping.key().getKey();
            if (SNodeOperations.isInstanceOf(sourceUnitMappingUnitReference, CONCEPTS.UnitReference$Zo)) {
              MapSequence.fromMap(sourceUnitMapCopy).removeKey(sourceUnitMapping.key());
              MapSequence.fromMap(sourceUnitMapCopy).put(new NamedKeyWrapper(SLinkOperations.getTarget(sourceUnitMappingUnitReference, LINKS.unit$nTeG)), sourceUnitMapping.value());
            }
          }
        }
        for (IMapping<NamedKeyWrapper, Fraction> targetUnitMapping : MapSequence.fromMap(targetUnitMap)) {
          {
            final SNode targetUnitMappingUnitReference = targetUnitMapping.key().getKey();
            if (SNodeOperations.isInstanceOf(targetUnitMappingUnitReference, CONCEPTS.UnitReference$Zo)) {
              MapSequence.fromMap(targetUnitMapCopy).removeKey(targetUnitMapping.key());
              MapSequence.fromMap(targetUnitMapCopy).put(new NamedKeyWrapper(SLinkOperations.getTarget(targetUnitMappingUnitReference, LINKS.unit$nTeG)), targetUnitMapping.value());
            }
          }
        }
        if ((boolean) UnitConversionUtil.matchingMappings(sourceUnitMapCopy, targetUnitMapCopy)._0()) {
          SNode targetUnitReference = IConvertUnit__BehaviorDescriptor.getTargetUnitReference_id1BdB9zGarhv.invoke(convertUnit);
          // missing different scaling is not allowed
          if (!(Objects.equals(UnitConversionUtil.getScaling(SNodeOperations.as(SLinkOperations.getTarget(sourceExpression, LINKS.unit$nTeG), CONCEPTS.Unit$Gq)), UnitConversionUtil.getScaling(SNodeOperations.as(SLinkOperations.getTarget(targetUnitReference, LINKS.unit$nTeG), CONCEPTS.Unit$Gq))))) {
            return null;
          }

          AbstractUnitPrefix sourcePrefix = GlobalUnitPrefixManager.getManager(SLinkOperations.getTarget(sourceExpression, LINKS.unit$nTeG)).findPrefix(SPropertyOperations.getString(sourceExpression, PROPS.prefix$AtV));
          int sourceFactor = (sourcePrefix != null ? (int) sourcePrefix.factor() : 0);
          AbstractUnitPrefix targetPrefix = GlobalUnitPrefixManager.getManager(SLinkOperations.getTarget(targetUnitReference, LINKS.unit$nTeG)).findPrefix(SPropertyOperations.getString(targetUnitReference, PROPS.prefix$AtV));
          int targetFactor = (targetPrefix != null ? (int) targetPrefix.factor() : 0);

          SNode powerExpr = _quotation_createNode_5ohk72_a0j0g0h0lc(createNumberLiteral_5ohk72_a0a0a0a9a6a7a36(String.valueOf(sourceFactor) + ".0"), createNumberLiteral_5ohk72_a0a0a0a9a6a7a36_0(String.valueOf(targetFactor) + ".0"), createNumberLiteral_5ohk72_a0a0a0j0g0h0lc(String.valueOf(GlobalUnitPrefixManager.getManager(SLinkOperations.getTarget(sourceExpression, LINKS.unit$nTeG), SLinkOperations.getTarget(targetUnitReference, LINKS.unit$nTeG)).getBase())));
          return createConversionSpecifier_5ohk72_a01a6a7a36(powerExpr);
        }
      }
    }
    return null;
  }

  public static SNode replaceUnitsWithSIBaseEquivalents(SNode unitExpr, SRepository repository) {
    SNode expr = SNodeOperations.copyNode(unitExpr);
    final List<SNode> allSiUnits = Sequence.fromIterable(SNodeOperations.ofConcept(StandardUnitHelper.getAllSiUnits(false, repository), CONCEPTS.Unit$Gq)).toList();
    ListSequence.fromList(SNodeOperations.getNodeDescendants(expr, CONCEPTS.UnitReference$Zo, false, new SAbstractConcept[]{})).visitAll((final SNode it) -> {
      SNode foundSiUnit = ListSequence.fromList(allSiUnits).findFirst((siUnit) -> Objects.equals(SLinkOperations.getTarget(siUnit, LINKS.quantity$tnl1), SLinkOperations.getTarget(SNodeOperations.as(SLinkOperations.getTarget(it, LINKS.unit$nTeG), CONCEPTS.Unit$Gq), LINKS.quantity$tnl1)));
      if ((foundSiUnit != null)) {
        SLinkOperations.setTarget(it, LINKS.unit$nTeG, foundSiUnit);
      }
    });
    return expr;
  }

  public static SEnumerationLiteral getScaling(SNode unit) {
    Map<SNodeReference, SEnumerationLiteral> overwrittenScalingMap = PhysUnitLangConfigHelper.getConfig().getOverwrittenScaling();
    if (MapSequence.fromMap(overwrittenScalingMap).containsKey(SNodeOperations.getPointer(unit))) {
      return MapSequence.fromMap(overwrittenScalingMap).get(SNodeOperations.getPointer(unit));
    } else {
      return SPropertyOperations.getEnum(unit, PROPS.scaling$a4tq);
    }
  }
  private static SNode createUnitReference_5ohk72_a0a0a0a0a4a32(SNode p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.UnitReference$Zo);
    n0.setReferenceTarget(LINKS.unit$nTeG, p0);
    return n0.getResult();
  }
  private static SNode createIntegerExponent_5ohk72_a0a0b0e0nb(int p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.IntegerExponent$a2);
    n0.setProperty(PROPS.value$NUak, "" + (p0));
    return n0.getResult();
  }
  private static SNode createFractionalExponent_5ohk72_a0a0a1a4a93(SNode p0, SNode p1) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.FractionalExponent$I4);
    {
      SNodeBuilder n1 = n0.forChild(LINKS.fraction$NfyQ).init(CONCEPTS.FractionExpression$NO);
      n1.forChild(LINKS.numerator$GF9U).initNode(p0, CONCEPTS.Expression$D_, true);
      n1.forChild(LINKS.denominator$GFQX).initNode(p1, CONCEPTS.Expression$D_, true);
    }
    return n0.getResult();
  }
  private static SNode createUnitExponent_5ohk72_a2a4a93(SNode p0, SNode p1) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.UnitExponent$BW);
    n0.forChild(LINKS.base$z8ie).initNode(p0, CONCEPTS.UnitExpression$Xv, true);
    n0.forChild(LINKS.exponent$z83d).initNode(p1, CONCEPTS.Exponent$bg, true);
    return n0.getResult();
  }
  private static SNode createQuantitySpecification_5ohk72_a0a85(SNode p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.QuantitySpecification$4N);
    n0.forChild(LINKS.specification$WwUP).initNode(p0, CONCEPTS.QuantityExpression$D7, true);
    return n0.getResult();
  }
  private static SNode createQuantityReference_5ohk72_a0a0a16(SNode p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.QuantityReference$ba);
    n0.setReferenceTarget(LINKS.quantity$A_Kl, p0);
    return n0.getResult();
  }
  private static SNode createQuantityDivision_5ohk72_a0a2a16(SNode p0, SNode p1) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.QuantityDivision$7h);
    n0.forChild(LINKS.numerator$clxk).initNode(p0, CONCEPTS.QuantityExpression$D7, true);
    n0.forChild(LINKS.denominator$F8jm).initNode(p1, CONCEPTS.QuantityExpression$D7, true);
    return n0.getResult();
  }
  private static SNode createQuantityMultiplication_5ohk72_a0a4a16(SNode p0, SNode p1) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.QuantityMultiplication$Ff);
    n0.forChild(LINKS.left$z0Di).initNode(p0, CONCEPTS.QuantityExpression$D7, true);
    n0.forChild(LINKS.right$YInn).initNode(p1, CONCEPTS.QuantityExpression$D7, true);
    return n0.getResult();
  }
  private static SNode createQuantityExponent_5ohk72_a0a6a16(SNode p0, SNode p1) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.QuantityExponent$yd);
    n0.forChild(LINKS.base$4f1J).initNode(p0, CONCEPTS.QuantityExpression$D7, true);
    n0.forChild(LINKS.exponent$xhDu).initNode(p1, CONCEPTS.Exponent$bg, true);
    return n0.getResult();
  }
  private static SNode _quotation_createNode_5ohk72_a0j0g0h0lc(Object parameter_1, Object parameter_2, Object parameter_3) {
    SNode quotedNode_4 = null;
    SNode quotedNode_5 = null;
    SNode quotedNode_6 = null;
    SNode quotedNode_7 = null;
    SNode quotedNode_8 = null;
    SNodeBuilder nb = new SNodeBuilder(null, null).init(MetaAdapterFactory.getConcept(MetaAdapterFactory.getLanguage(0x6fadc44e69c24a4aL, 0x9d167ebf5f8d3ba0L, "org.iets3.core.expr.math"), 0x449e19d04e9c6144L, "PowerExpression"));
    quotedNode_4 = nb.getResult();
    SNodeBuilder nb1 = new SNodeBuilder(null, null).init(MetaAdapterFactory.getConcept(MetaAdapterFactory.getLanguage(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, "org.iets3.core.expr.base"), 0x46ff3b3d86cac5a5L, "MinusExpression"));
    quotedNode_5 = nb1.getResult();
    quotedNode_7 = (SNode) parameter_1;
    if (quotedNode_7 != null) {
      quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86c99c15L, 0x46ff3b3d86c99c16L, "left"), SNodeOperations.copyIfNecessary(quotedNode_7));
    }
    quotedNode_8 = (SNode) parameter_2;
    if (quotedNode_8 != null) {
      quotedNode_5.addChild(MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86c99c15L, 0x46ff3b3d86c99c18L, "right"), SNodeOperations.copyIfNecessary(quotedNode_8));
    }
    quotedNode_4.addChild(MetaAdapterFactory.getContainmentLink(0x6fadc44e69c24a4aL, 0x9d167ebf5f8d3ba0L, 0x449e19d04e9c6144L, 0x46c15b39e5605f2fL, "exponent"), quotedNode_5);
    quotedNode_6 = (SNode) parameter_3;
    if (quotedNode_6 != null) {
      quotedNode_4.addChild(MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x3b256bb6ae8048d8L, 0x3b256bb6ae8048d9L, "expr"), SNodeOperations.copyIfNecessary(quotedNode_6));
    }
    return quotedNode_4;
  }
  private static SNode createNumberLiteral_5ohk72_a0a0a0a9a6a7a36(String p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.NumberLiteral$wE);
    n0.setProperty(PROPS.value$iWTK, p0);
    return n0.getResult();
  }
  private static SNode createNumberLiteral_5ohk72_a0a0a0a9a6a7a36_0(String p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.NumberLiteral$wE);
    n0.setProperty(PROPS.value$iWTK, p0);
    return n0.getResult();
  }
  private static SNode createNumberLiteral_5ohk72_a0a0a0j0g0h0lc(String p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.NumberLiteral$wE);
    n0.setProperty(PROPS.value$iWTK, p0);
    return n0.getResult();
  }
  private static SNode createConversionSpecifier_5ohk72_a01a6a7a36(SNode p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.ConversionSpecifier$X$);
    n0.forChild(LINKS.type$poAd).init(CONCEPTS.IntegerType$m0);
    {
      SNodeBuilder n1 = n0.forChild(LINKS.expression$BZ0p).init(CONCEPTS.CastExpression$Df);
      n1.forChild(LINKS.expectedType$SdFI).init(CONCEPTS.NumberType$n);
      {
        SNodeBuilder n2 = n1.forChild(LINKS.expr$CW3E).init(CONCEPTS.MulExpression$iC);
        n2.forChild(LINKS.left$zxUa).init(CONCEPTS.ValExpression$hl);
        n2.forChild(LINKS.right$zBjx).initNode(p0, CONCEPTS.Expression$D_, true);
      }
    }
    return n0.getResult();
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept TaggedType$O4 = MetaAdapterFactory.getConcept(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x186a8ed9947750b6L, "org.iets3.core.expr.typetags.structure.TaggedType");
    /*package*/ static final SConcept UnitSpecification$6j = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d411dL, "org.iets3.core.expr.typetags.physunits.structure.UnitSpecification");
    /*package*/ static final SConcept QuantitySpecification$4N = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x729d46b7ce8b64dcL, "org.iets3.core.expr.typetags.physunits.structure.QuantitySpecification");
    /*package*/ static final SConcept MeetType$ZG = MetaAdapterFactory.getConcept(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x114b68ad132L, "jetbrains.mps.lang.typesystem.structure.MeetType");
    /*package*/ static final SConcept IntegerType$7a = MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf940d22479L, "jetbrains.mps.baseLanguage.structure.IntegerType");
    /*package*/ static final SInterfaceConcept IDetectCycle$wy = MetaAdapterFactory.getInterfaceConcept(0xd4280a54f6df4383L, 0xaa41d1b2bffa7eb1L, 0x526d2e6bb4f94a97L, "com.mbeddr.core.base.structure.IDetectCycle");
    /*package*/ static final SInterfaceConcept IReference$$s = MetaAdapterFactory.getInterfaceConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x668417ae62784d3aL, "org.iets3.core.expr.typetags.physunits.structure.IReference");
    /*package*/ static final SInterfaceConcept IGroupPower$Z2 = MetaAdapterFactory.getInterfaceConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x414a129fbfe5a6d2L, "org.iets3.core.expr.typetags.physunits.structure.IGroupPower");
    /*package*/ static final SInterfaceConcept IGroupMultiplication$Y1 = MetaAdapterFactory.getInterfaceConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x414a129fbfe5a32cL, "org.iets3.core.expr.typetags.physunits.structure.IGroupMultiplication");
    /*package*/ static final SInterfaceConcept IGroupDivision$DT = MetaAdapterFactory.getInterfaceConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x414a129fbfe5a55aL, "org.iets3.core.expr.typetags.physunits.structure.IGroupDivision");
    /*package*/ static final SConcept Unit$Gq = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d373fL, "org.iets3.core.expr.typetags.physunits.structure.Unit");
    /*package*/ static final SConcept UnitReference$Zo = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d4dc5L, "org.iets3.core.expr.typetags.physunits.structure.UnitReference");
    /*package*/ static final SInterfaceConcept IUnit$tw = MetaAdapterFactory.getInterfaceConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d40ceL, "org.iets3.core.expr.typetags.physunits.structure.IUnit");
    /*package*/ static final SConcept UnitExpression$Xv = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x729d46b7ceabeb6cL, "org.iets3.core.expr.typetags.physunits.structure.UnitExpression");
    /*package*/ static final SConcept UnitMultiplication$sx = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x74818abc5471020dL, "org.iets3.core.expr.typetags.physunits.structure.UnitMultiplication");
    /*package*/ static final SConcept UnitDivision$$9 = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x729d46b7ceac12f5L, "org.iets3.core.expr.typetags.physunits.structure.UnitDivision");
    /*package*/ static final SConcept UnitExponent$BW = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x74818abc54714f3eL, "org.iets3.core.expr.typetags.physunits.structure.UnitExponent");
    /*package*/ static final SConcept IntegerExponent$a2 = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d4dc6L, "org.iets3.core.expr.typetags.physunits.structure.IntegerExponent");
    /*package*/ static final SConcept FractionalExponent$I4 = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x34c38940d09904b9L, "org.iets3.core.expr.typetags.physunits.structure.FractionalExponent");
    /*package*/ static final SConcept FractionExpression$NO = MetaAdapterFactory.getConcept(0x6fadc44e69c24a4aL, 0x9d167ebf5f8d3ba0L, 0x449e19d04e9bcd46L, "org.iets3.core.expr.math.structure.FractionExpression");
    /*package*/ static final SConcept Expression$D_ = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x670d5e92f854a047L, "org.iets3.core.expr.base.structure.Expression");
    /*package*/ static final SConcept Exponent$bg = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x34c38940d07a6995L, "org.iets3.core.expr.typetags.physunits.structure.Exponent");
    /*package*/ static final SConcept QuantityExpression$D7 = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x729d46b7ce978ef0L, "org.iets3.core.expr.typetags.physunits.structure.QuantityExpression");
    /*package*/ static final SConcept QuantityReference$ba = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x729d46b7ce8b6fa3L, "org.iets3.core.expr.typetags.physunits.structure.QuantityReference");
    /*package*/ static final SConcept QuantityDivision$7h = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x729d46b7ce97ab00L, "org.iets3.core.expr.typetags.physunits.structure.QuantityDivision");
    /*package*/ static final SConcept QuantityMultiplication$Ff = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x729d46b7cea3ee22L, "org.iets3.core.expr.typetags.physunits.structure.QuantityMultiplication");
    /*package*/ static final SConcept QuantityExponent$yd = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x729d46b7ce979cf7L, "org.iets3.core.expr.typetags.physunits.structure.QuantityExponent");
    /*package*/ static final SConcept NumberLiteral$wE = MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x46ff3b3d86d0e6daL, "org.iets3.core.expr.simpleTypes.structure.NumberLiteral");
    /*package*/ static final SConcept ConversionSpecifier$X$ = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x182c7aae9fea4574L, "org.iets3.core.expr.typetags.physunits.structure.ConversionSpecifier");
    /*package*/ static final SConcept IntegerType$m0 = MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x46ff3b3d86d0e6d9L, "org.iets3.core.expr.simpleTypes.structure.IntegerType");
    /*package*/ static final SConcept CastExpression$Df = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x2d8b76405dcec884L, "org.iets3.core.expr.base.structure.CastExpression");
    /*package*/ static final SConcept NumberType$n = MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x7211e50064d40ea8L, "org.iets3.core.expr.simpleTypes.structure.NumberType");
    /*package*/ static final SConcept MulExpression$iC = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86c9a56fL, "org.iets3.core.expr.base.structure.MulExpression");
    /*package*/ static final SConcept ValExpression$hl = MetaAdapterFactory.getConcept(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x47f53137d1e3b2aeL, "org.iets3.core.expr.typetags.physunits.structure.ValExpression");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink argument$r2cT = MetaAdapterFactory.getContainmentLink(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x114b68ad132L, 0x114b68b040bL, "argument");
    /*package*/ static final SContainmentLink baseType$z6Mz = MetaAdapterFactory.getContainmentLink(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x186a8ed9947750b6L, 0x186a8ed9947750b9L, "baseType");
    /*package*/ static final SContainmentLink specification$Tp$k = MetaAdapterFactory.getContainmentLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x668417ae62c5c36cL, 0x668417ae62c5ca21L, "specification");
    /*package*/ static final SContainmentLink specification$d6YI = MetaAdapterFactory.getContainmentLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d411dL, 0x73b48a125b0dab03L, "specification");
    /*package*/ static final SReferenceLink unit$nTeG = MetaAdapterFactory.getReferenceLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d4dc5L, 0x73b48a125b0daafcL, "unit");
    /*package*/ static final SContainmentLink left$sr9k = MetaAdapterFactory.getContainmentLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x74818abc5471020dL, 0x74818abc54710afeL, "left");
    /*package*/ static final SContainmentLink right$2nEP = MetaAdapterFactory.getContainmentLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x74818abc5471020dL, 0x74818abc54710e0cL, "right");
    /*package*/ static final SReferenceLink quantity$tnl1 = MetaAdapterFactory.getReferenceLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d373fL, 0x1c3a590e2b660f1aL, "quantity");
    /*package*/ static final SContainmentLink numerator$qo9G = MetaAdapterFactory.getContainmentLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x729d46b7ceac12f5L, 0x729d46b7ceac161cL, "numerator");
    /*package*/ static final SContainmentLink denominator$4xz7 = MetaAdapterFactory.getContainmentLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x729d46b7ceac12f5L, 0x729d46b7ceac19c9L, "denominator");
    /*package*/ static final SContainmentLink base$z8ie = MetaAdapterFactory.getContainmentLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x74818abc54714f3eL, 0x74818abc54715a86L, "base");
    /*package*/ static final SContainmentLink exponent$z83d = MetaAdapterFactory.getContainmentLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x74818abc54714f3eL, 0x74818abc54715a85L, "exponent");
    /*package*/ static final SContainmentLink fraction$NfyQ = MetaAdapterFactory.getContainmentLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x34c38940d09904b9L, 0x34c38940d09979deL, "fraction");
    /*package*/ static final SContainmentLink numerator$GF9U = MetaAdapterFactory.getContainmentLink(0x6fadc44e69c24a4aL, 0x9d167ebf5f8d3ba0L, 0x449e19d04e9bcd46L, 0x449e19d04e9bcd47L, "numerator");
    /*package*/ static final SContainmentLink denominator$GFQX = MetaAdapterFactory.getContainmentLink(0x6fadc44e69c24a4aL, 0x9d167ebf5f8d3ba0L, 0x449e19d04e9bcd46L, 0x449e19d04e9bcd4aL, "denominator");
    /*package*/ static final SContainmentLink specification$WwUP = MetaAdapterFactory.getContainmentLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x729d46b7ce8b64dcL, 0x729d46b7ce8b6885L, "specification");
    /*package*/ static final SReferenceLink quantity$A_Kl = MetaAdapterFactory.getReferenceLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x729d46b7ce8b6fa3L, 0x729d46b7ce8b760cL, "quantity");
    /*package*/ static final SContainmentLink numerator$clxk = MetaAdapterFactory.getContainmentLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x729d46b7ce97ab00L, 0x1be25d17bc5c9220L, "numerator");
    /*package*/ static final SContainmentLink denominator$F8jm = MetaAdapterFactory.getContainmentLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x729d46b7ce97ab00L, 0x1be25d17bc5c945eL, "denominator");
    /*package*/ static final SContainmentLink left$z0Di = MetaAdapterFactory.getContainmentLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x729d46b7cea3ee22L, 0x1be25d17bc5c9d57L, "left");
    /*package*/ static final SContainmentLink right$YInn = MetaAdapterFactory.getContainmentLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x729d46b7cea3ee22L, 0x1be25d17bc5ca07fL, "right");
    /*package*/ static final SContainmentLink base$4f1J = MetaAdapterFactory.getContainmentLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x729d46b7ce979cf7L, 0x1be25d17bc5c98a7L, "base");
    /*package*/ static final SContainmentLink exponent$xhDu = MetaAdapterFactory.getContainmentLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x729d46b7ce979cf7L, 0x70ccd48a59f31f35L, "exponent");
    /*package*/ static final SContainmentLink type$poAd = MetaAdapterFactory.getContainmentLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x182c7aae9fea4574L, 0x182c7aaea0320b8dL, "type");
    /*package*/ static final SContainmentLink expression$BZ0p = MetaAdapterFactory.getContainmentLink(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x182c7aae9fea4574L, 0x182c7aae9fee3f05L, "expression");
    /*package*/ static final SContainmentLink expectedType$SdFI = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x2d8b76405dcec884L, 0x2d8b76405dcec889L, "expectedType");
    /*package*/ static final SContainmentLink expr$CW3E = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x3b256bb6ae8048d8L, 0x3b256bb6ae8048d9L, "expr");
    /*package*/ static final SContainmentLink left$zxUa = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86c99c15L, 0x46ff3b3d86c99c16L, "left");
    /*package*/ static final SContainmentLink right$zBjx = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86c99c15L, 0x46ff3b3d86c99c18L, "right");
  }

  private static final class PROPS {
    /*package*/ static final SProperty prefix$AtV = MetaAdapterFactory.getProperty(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d4dc5L, 0x79d6409d1866689aL, "prefix");
    /*package*/ static final SProperty scaling$a4tq = MetaAdapterFactory.getProperty(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d373fL, 0x244b2b88a69f311cL, "scaling");
    /*package*/ static final SProperty value$NUak = MetaAdapterFactory.getProperty(0x7ee265bd59864709L, 0x86ed2c6daa33cd8cL, 0x73b48a125b0d4dc6L, 0x73b48a125b0d4dc7L, "value");
    /*package*/ static final SProperty value$iWTK = MetaAdapterFactory.getProperty(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x46ff3b3d86d0e6daL, 0x46ff3b3d86d0e6ddL, "value");
  }
}
