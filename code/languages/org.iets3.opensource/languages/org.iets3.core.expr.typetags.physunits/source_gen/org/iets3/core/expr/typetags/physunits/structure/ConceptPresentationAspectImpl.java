package org.iets3.core.expr.typetags.physunits.structure;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.ConceptPresentationAspectBase;
import jetbrains.mps.smodel.runtime.ConceptPresentation;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.runtime.ConceptPresentationBuilder;

public class ConceptPresentationAspectImpl extends ConceptPresentationAspectBase {
  private ConceptPresentation props_AllowNameShadowingAnnotation;
  private ConceptPresentation props_ConversionRule;
  private ConceptPresentation props_ConversionSpecifier;
  private ConceptPresentation props_ConvertExpression;
  private ConceptPresentation props_ConvertToTarget;
  private ConceptPresentation props_Dimension;
  private ConceptPresentation props_DimensionDivision;
  private ConceptPresentation props_DimensionExponent;
  private ConceptPresentation props_DimensionExpression;
  private ConceptPresentation props_DimensionMultiplication;
  private ConceptPresentation props_DimensionNeutral;
  private ConceptPresentation props_DimensionReference;
  private ConceptPresentation props_Exponent;
  private ConceptPresentation props_FractionalExponent;
  private ConceptPresentation props_ICanUseUnitlessUnit;
  private ConceptPresentation props_IConvertUnit;
  private ConceptPresentation props_IGroupBase;
  private ConceptPresentation props_IGroupDivision;
  private ConceptPresentation props_IGroupLike;
  private ConceptPresentation props_IGroupMultiplication;
  private ConceptPresentation props_IGroupNeutral;
  private ConceptPresentation props_IGroupPower;
  private ConceptPresentation props_IHaveIUnitSpecification;
  private ConceptPresentation props_IReference;
  private ConceptPresentation props_ISpecification;
  private ConceptPresentation props_ITransformationProperty;
  private ConceptPresentation props_IUnit;
  private ConceptPresentation props_IUnitDeclarationsProvider;
  private ConceptPresentation props_IUnitSpecification;
  private ConceptPresentation props_IntegerExponent;
  private ConceptPresentation props_NoConvertExpression;
  private ConceptPresentation props_PseudoScalar;
  private ConceptPresentation props_PseudoVector;
  private ConceptPresentation props_Quantity;
  private ConceptPresentation props_QuantityBaseType;
  private ConceptPresentation props_QuantityDivision;
  private ConceptPresentation props_QuantityDivisionType;
  private ConceptPresentation props_QuantityEmptyType;
  private ConceptPresentation props_QuantityExponent;
  private ConceptPresentation props_QuantityExponentType;
  private ConceptPresentation props_QuantityExpression;
  private ConceptPresentation props_QuantityMultiplication;
  private ConceptPresentation props_QuantityMultiplicationType;
  private ConceptPresentation props_QuantityNeutral;
  private ConceptPresentation props_QuantityReference;
  private ConceptPresentation props_QuantitySpecification;
  private ConceptPresentation props_QuantityType;
  private ConceptPresentation props_Scalar;
  private ConceptPresentation props_StripUnitExpression;
  private ConceptPresentation props_Tensor;
  private ConceptPresentation props_Unit;
  private ConceptPresentation props_UnitDivision;
  private ConceptPresentation props_UnitExponent;
  private ConceptPresentation props_UnitExpression;
  private ConceptPresentation props_UnitMultiplication;
  private ConceptPresentation props_UnitNeutral;
  private ConceptPresentation props_UnitReference;
  private ConceptPresentation props_UnitSpecification;
  private ConceptPresentation props_ValExpression;
  private ConceptPresentation props_Vector;
  private ConceptPresentation props_VectorField;

  @Override
  @Nullable
  public ConceptPresentation getDescriptor(SAbstractConcept c) {
    StructureAspectDescriptor structureDescriptor = (StructureAspectDescriptor) myLanguageRuntime.getAspect(jetbrains.mps.smodel.runtime.StructureAspectDescriptor.class);
    switch (structureDescriptor.internalIndex(c)) {
      case LanguageConceptSwitch.AllowNameShadowingAnnotation:
        if (props_AllowNameShadowingAnnotation == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.rawPresentation("@allow name shadowing");
          props_AllowNameShadowingAnnotation = cpb.create();
        }
        return props_AllowNameShadowingAnnotation;
      case LanguageConceptSwitch.ConversionRule:
        if (props_ConversionRule == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a conversion rule between two units");
          cpb.presentationByName();
          props_ConversionRule = cpb.create();
        }
        return props_ConversionRule;
      case LanguageConceptSwitch.ConversionSpecifier:
        if (props_ConversionSpecifier == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a conversion specifier");
          cpb.presentationByName();
          props_ConversionSpecifier = cpb.create();
        }
        return props_ConversionSpecifier;
      case LanguageConceptSwitch.ConvertExpression:
        if (props_ConvertExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("convert to a target unit");
          cpb.rawPresentation("convert");
          props_ConvertExpression = cpb.create();
        }
        return props_ConvertExpression;
      case LanguageConceptSwitch.ConvertToTarget:
        if (props_ConvertToTarget == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("convert to a target unit");
          cpb.rawPresentation("convertTo");
          props_ConvertToTarget = cpb.create();
        }
        return props_ConvertToTarget;
      case LanguageConceptSwitch.Dimension:
        if (props_Dimension == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.presentationByName();
          props_Dimension = cpb.create();
        }
        return props_Dimension;
      case LanguageConceptSwitch.DimensionDivision:
        if (props_DimensionDivision == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.rawPresentation("DimensionDivision");
          props_DimensionDivision = cpb.create();
        }
        return props_DimensionDivision;
      case LanguageConceptSwitch.DimensionExponent:
        if (props_DimensionExponent == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.rawPresentation("DimensionExponent");
          props_DimensionExponent = cpb.create();
        }
        return props_DimensionExponent;
      case LanguageConceptSwitch.DimensionExpression:
        if (props_DimensionExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_DimensionExpression = cpb.create();
        }
        return props_DimensionExpression;
      case LanguageConceptSwitch.DimensionMultiplication:
        if (props_DimensionMultiplication == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.rawPresentation("DimensionMultiplication");
          props_DimensionMultiplication = cpb.create();
        }
        return props_DimensionMultiplication;
      case LanguageConceptSwitch.DimensionNeutral:
        if (props_DimensionNeutral == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.rawPresentation("DimensionNeutral");
          props_DimensionNeutral = cpb.create();
        }
        return props_DimensionNeutral;
      case LanguageConceptSwitch.DimensionReference:
        if (props_DimensionReference == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a base quantity type");
          cpb.presentationByName();
          props_DimensionReference = cpb.create();
        }
        return props_DimensionReference;
      case LanguageConceptSwitch.Exponent:
        if (props_Exponent == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a base concept for exponents");
          props_Exponent = cpb.create();
        }
        return props_Exponent;
      case LanguageConceptSwitch.FractionalExponent:
        if (props_FractionalExponent == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a fractional exponent");
          cpb.rawPresentation("FractionalExponent");
          props_FractionalExponent = cpb.create();
        }
        return props_FractionalExponent;
      case LanguageConceptSwitch.ICanUseUnitlessUnit:
        if (props_ICanUseUnitlessUnit == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_ICanUseUnitlessUnit = cpb.create();
        }
        return props_ICanUseUnitlessUnit;
      case LanguageConceptSwitch.IConvertUnit:
        if (props_IConvertUnit == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_IConvertUnit = cpb.create();
        }
        return props_IConvertUnit;
      case LanguageConceptSwitch.IGroupBase:
        if (props_IGroupBase == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_IGroupBase = cpb.create();
        }
        return props_IGroupBase;
      case LanguageConceptSwitch.IGroupDivision:
        if (props_IGroupDivision == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_IGroupDivision = cpb.create();
        }
        return props_IGroupDivision;
      case LanguageConceptSwitch.IGroupLike:
        if (props_IGroupLike == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_IGroupLike = cpb.create();
        }
        return props_IGroupLike;
      case LanguageConceptSwitch.IGroupMultiplication:
        if (props_IGroupMultiplication == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_IGroupMultiplication = cpb.create();
        }
        return props_IGroupMultiplication;
      case LanguageConceptSwitch.IGroupNeutral:
        if (props_IGroupNeutral == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_IGroupNeutral = cpb.create();
        }
        return props_IGroupNeutral;
      case LanguageConceptSwitch.IGroupPower:
        if (props_IGroupPower == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_IGroupPower = cpb.create();
        }
        return props_IGroupPower;
      case LanguageConceptSwitch.IHaveIUnitSpecification:
        if (props_IHaveIUnitSpecification == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_IHaveIUnitSpecification = cpb.create();
        }
        return props_IHaveIUnitSpecification;
      case LanguageConceptSwitch.IReference:
        if (props_IReference == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_IReference = cpb.create();
        }
        return props_IReference;
      case LanguageConceptSwitch.ISpecification:
        if (props_ISpecification == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_ISpecification = cpb.create();
        }
        return props_ISpecification;
      case LanguageConceptSwitch.ITransformationProperty:
        if (props_ITransformationProperty == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_ITransformationProperty = cpb.create();
        }
        return props_ITransformationProperty;
      case LanguageConceptSwitch.IUnit:
        if (props_IUnit == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_IUnit = cpb.create();
        }
        return props_IUnit;
      case LanguageConceptSwitch.IUnitDeclarationsProvider:
        if (props_IUnitDeclarationsProvider == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_IUnitDeclarationsProvider = cpb.create();
        }
        return props_IUnitDeclarationsProvider;
      case LanguageConceptSwitch.IUnitSpecification:
        if (props_IUnitSpecification == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_IUnitSpecification = cpb.create();
        }
        return props_IUnitSpecification;
      case LanguageConceptSwitch.IntegerExponent:
        if (props_IntegerExponent == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("an integer exponent");
          cpb.rawPresentation("IntegerExponent");
          props_IntegerExponent = cpb.create();
        }
        return props_IntegerExponent;
      case LanguageConceptSwitch.NoConvertExpression:
        if (props_NoConvertExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.rawPresentation("noConvert");
          props_NoConvertExpression = cpb.create();
        }
        return props_NoConvertExpression;
      case LanguageConceptSwitch.PseudoScalar:
        if (props_PseudoScalar == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.rawPresentation("pseudoscalar");
          props_PseudoScalar = cpb.create();
        }
        return props_PseudoScalar;
      case LanguageConceptSwitch.PseudoVector:
        if (props_PseudoVector == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.rawPresentation("pseudovector");
          props_PseudoVector = cpb.create();
        }
        return props_PseudoVector;
      case LanguageConceptSwitch.Quantity:
        if (props_Quantity == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a quantity");
          cpb.presentationByName();
          props_Quantity = cpb.create();
        }
        return props_Quantity;
      case LanguageConceptSwitch.QuantityBaseType:
        if (props_QuantityBaseType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a base quantity type");
          cpb.presentationByName();
          props_QuantityBaseType = cpb.create();
        }
        return props_QuantityBaseType;
      case LanguageConceptSwitch.QuantityDivision:
        if (props_QuantityDivision == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a quantity division expression");
          cpb.rawPresentation("/");
          props_QuantityDivision = cpb.create();
        }
        return props_QuantityDivision;
      case LanguageConceptSwitch.QuantityDivisionType:
        if (props_QuantityDivisionType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a type of a quantity");
          cpb.rawPresentation("/");
          props_QuantityDivisionType = cpb.create();
        }
        return props_QuantityDivisionType;
      case LanguageConceptSwitch.QuantityEmptyType:
        if (props_QuantityEmptyType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("an empty type of a quantity");
          cpb.rawPresentation("QuantityEmptyType");
          props_QuantityEmptyType = cpb.create();
        }
        return props_QuantityEmptyType;
      case LanguageConceptSwitch.QuantityExponent:
        if (props_QuantityExponent == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a quantity exponent expression");
          cpb.rawPresentation("^");
          props_QuantityExponent = cpb.create();
        }
        return props_QuantityExponent;
      case LanguageConceptSwitch.QuantityExponentType:
        if (props_QuantityExponentType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("an exponential type of a quantity");
          cpb.rawPresentation("^");
          props_QuantityExponentType = cpb.create();
        }
        return props_QuantityExponentType;
      case LanguageConceptSwitch.QuantityExpression:
        if (props_QuantityExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a quantity expression");
          props_QuantityExpression = cpb.create();
        }
        return props_QuantityExpression;
      case LanguageConceptSwitch.QuantityMultiplication:
        if (props_QuantityMultiplication == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a quantity multiplication expression");
          cpb.rawPresentation("*");
          props_QuantityMultiplication = cpb.create();
        }
        return props_QuantityMultiplication;
      case LanguageConceptSwitch.QuantityMultiplicationType:
        if (props_QuantityMultiplicationType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a multiplication type of a quantity");
          cpb.rawPresentation("*");
          props_QuantityMultiplicationType = cpb.create();
        }
        return props_QuantityMultiplicationType;
      case LanguageConceptSwitch.QuantityNeutral:
        if (props_QuantityNeutral == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a neutral quantity expression");
          cpb.rawPresentation("QuantityNeutral");
          props_QuantityNeutral = cpb.create();
        }
        return props_QuantityNeutral;
      case LanguageConceptSwitch.QuantityReference:
        if (props_QuantityReference == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a reference to a quantity expression");
          cpb.presentationByName();
          props_QuantityReference = cpb.create();
        }
        return props_QuantityReference;
      case LanguageConceptSwitch.QuantitySpecification:
        if (props_QuantitySpecification == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a specification of a measure");
          cpb.rawPresentation("QuantitySpecification");
          props_QuantitySpecification = cpb.create();
        }
        return props_QuantitySpecification;
      case LanguageConceptSwitch.QuantityType:
        if (props_QuantityType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("an abstract quantity type");
          props_QuantityType = cpb.create();
        }
        return props_QuantityType;
      case LanguageConceptSwitch.Scalar:
        if (props_Scalar == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.rawPresentation("scalar");
          props_Scalar = cpb.create();
        }
        return props_Scalar;
      case LanguageConceptSwitch.StripUnitExpression:
        if (props_StripUnitExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("remove the unit");
          cpb.rawPresentation("stripunit");
          props_StripUnitExpression = cpb.create();
        }
        return props_StripUnitExpression;
      case LanguageConceptSwitch.Tensor:
        if (props_Tensor == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.rawPresentation("tensor");
          props_Tensor = cpb.create();
        }
        return props_Tensor;
      case LanguageConceptSwitch.Unit:
        if (props_Unit == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a unit definition");
          cpb.presentationByName();
          props_Unit = cpb.create();
        }
        return props_Unit;
      case LanguageConceptSwitch.UnitDivision:
        if (props_UnitDivision == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a unit fraction expression");
          cpb.rawPresentation("/");
          props_UnitDivision = cpb.create();
        }
        return props_UnitDivision;
      case LanguageConceptSwitch.UnitExponent:
        if (props_UnitExponent == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a unit exponent expression");
          cpb.rawPresentation("^");
          props_UnitExponent = cpb.create();
        }
        return props_UnitExponent;
      case LanguageConceptSwitch.UnitExpression:
        if (props_UnitExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("an abstract unit expression");
          props_UnitExpression = cpb.create();
        }
        return props_UnitExpression;
      case LanguageConceptSwitch.UnitMultiplication:
        if (props_UnitMultiplication == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a unit multiplication expression");
          cpb.rawPresentation("*");
          props_UnitMultiplication = cpb.create();
        }
        return props_UnitMultiplication;
      case LanguageConceptSwitch.UnitNeutral:
        if (props_UnitNeutral == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a neutral unit expression");
          cpb.rawPresentation("UnitNeutral");
          props_UnitNeutral = cpb.create();
        }
        return props_UnitNeutral;
      case LanguageConceptSwitch.UnitReference:
        if (props_UnitReference == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a reference to an unit");
          cpb.presentationByName();
          props_UnitReference = cpb.create();
        }
        return props_UnitReference;
      case LanguageConceptSwitch.UnitSpecification:
        if (props_UnitSpecification == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a unit specification");
          cpb.rawPresentation("UnitSpecification");
          props_UnitSpecification = cpb.create();
        }
        return props_UnitSpecification;
      case LanguageConceptSwitch.ValExpression:
        if (props_ValExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("an unmodifiable variable");
          cpb.rawPresentation("val");
          props_ValExpression = cpb.create();
        }
        return props_ValExpression;
      case LanguageConceptSwitch.Vector:
        if (props_Vector == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.rawPresentation("vector");
          props_Vector = cpb.create();
        }
        return props_Vector;
      case LanguageConceptSwitch.VectorField:
        if (props_VectorField == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.rawPresentation("vector field");
          props_VectorField = cpb.create();
        }
        return props_VectorField;
    }
    return null;
  }
}
