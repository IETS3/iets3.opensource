package org.iets3.core.expr.mutable.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import com.mbeddr.mpsutil.interpreter.rt.IContext;
import com.mbeddr.mpsutil.interpreter.rt.ComputationTrace;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import com.mbeddr.mpsutil.interpreter.rt.NullCoverageAnalyzer;
import java.util.List;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;

public class ContextCollector {

  public static Iterable<ContextValue> collect(SNode target, final IContext ctx, final ComputationTrace trace) {
    Map<SNode, ContextValue> res = MapSequence.fromMap(new HashMap<SNode, ContextValue>());
    for (SNode anc : ListSequence.fromList(SNodeOperations.getNodeAncestors(target, CONCEPTS.WithContextExpression$ey, false))) {
      for (SNode cv : ListSequence.fromList(SLinkOperations.getChildren(anc, LINKS.contextValues$6ztQ))) {
        ContextValue evaled = new ContextValue(SLinkOperations.getTarget(cv, LINKS.argument$lHqQ), ctx.getRootInterpreter().evaluate(SLinkOperations.getTarget(cv, LINKS.expr$CW3E), ctx, new NullCoverageAnalyzer(), trace, false));
        MapSequence.fromMap(res).put(SNodeOperations.asNode(SNodeOperations.getConcept(evaled.arg)), evaled);
      }
    }
    List<ContextValue> locals = ListSequence.fromList(SLinkOperations.getChildren(target, LINKS.contextArgs$rYw)).select((it) -> new ContextValue(SLinkOperations.getTarget(it, LINKS.argument$lHqQ), ctx.getRootInterpreter().evaluate(SLinkOperations.getTarget(it, LINKS.expr$CW3E), ctx, new NullCoverageAnalyzer(), trace, false))).toList();
    for (ContextValue cv : ListSequence.fromList(locals)) {
      MapSequence.fromMap(res).put(SNodeOperations.asNode(SNodeOperations.getConcept(cv.arg)), cv);
    }
    return MapSequence.fromMap(res).values();
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink argument$lHqQ = MetaAdapterFactory.getContainmentLink(0xfbba51185fc649ffL, 0x9c3b0b4469830440L, 0x4bbb011107468f62L, 0x4bbb011107468f63L, "argument");
    /*package*/ static final SContainmentLink expr$CW3E = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x3b256bb6ae8048d8L, 0x3b256bb6ae8048d9L, "expr");
    /*package*/ static final SContainmentLink contextValues$6ztQ = MetaAdapterFactory.getContainmentLink(0xfbba51185fc649ffL, 0x9c3b0b4469830440L, 0x4bbb011107bcb0f0L, 0x4bbb011107bcb0f1L, "contextValues");
    /*package*/ static final SContainmentLink contextArgs$rYw = MetaAdapterFactory.getContainmentLink(0xfbba51185fc649ffL, 0x9c3b0b4469830440L, 0x7f2b47dbd5e20656L, 0x4bbb011107468f41L, "contextArgs");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept WithContextExpression$ey = MetaAdapterFactory.getConcept(0xfbba51185fc649ffL, 0x9c3b0b4469830440L, 0x4bbb011107bcb0f0L, "org.iets3.core.expr.mutable.structure.WithContextExpression");
  }
}
