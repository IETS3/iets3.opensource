package org.iets3.core.expr.mutable.plugin;

/*Generated by MPS */

import com.mbeddr.mpsutil.interpreter.rt.IContext;
import java.util.List;
import org.iets3.core.expr.base.behavior.IETS3ExprContext;
import com.mbeddr.mpsutil.interpreter.rt.ICoverageAnalyzer;
import com.mbeddr.mpsutil.interpreter.rt.ComputationTrace;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collection;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;
import java.util.HashMap;

public class LiveValue extends InteractorValue {

  private InteractorValue baseValue = null;
  private LiveValueSnapshot latestSnapshot;

  public LiveValue(InteractorValue bv, IContext ctx) {
    super(bv.interactor(), ctx);
    this.baseValue = bv;
  }

  @Override
  public Object handleElement(IDElement element, List<Object> payload, List<ContextValue> contextArgs, IETS3ExprContext ctx, ICoverageAnalyzer coverage, ComputationTrace trace) {
    Object res = baseValue.handleElement(element, payload, contextArgs, ctx, coverage, trace);
    prepareSnapshot(ctx, coverage, trace);
    if (element instanceof IDValue) {
      return res;
    }
    return this;
  }

  @Override
  public Object getSubstate(SNode n, IContext ctx, ComputationTrace trace) {
    return this.baseValue.getSubstate(n, ctx, trace);
  }

  public void prepareSnapshot(IETS3ExprContext ctx, ICoverageAnalyzer coverage, ComputationTrace trace) {
    latestSnapshot = takeSnapshot(this.baseValue, ctx, coverage, trace);
  }

  public static LiveValueSnapshot takeSnapshot(InteractorValue iv, IETS3ExprContext ctx, ICoverageAnalyzer coverage, ComputationTrace trace) {
    LiveValueSnapshot s = new LiveValueSnapshot(iv.getClass().getSimpleName(), iv.getClass().getSimpleName());
    ComputationTrace dummyTrace = new ComputationTrace();
    for (IDValue value : Sequence.fromIterable(iv.d().values())) {
      Object v = iv.handleElement(value, null, null, ctx, coverage, dummyTrace);
      if (v instanceof BoxValue) {
        v = ((BoxValue) v).getValue();
      }
      if (v instanceof InteractorValue) {
        s.add(value.name, takeSnapshot(((InteractorValue) v), ctx, coverage, trace));
      } else if (v instanceof Collection) {
        List l = new ArrayList();
        Iterator<Object> iter = ((Collection) v).iterator();
        while (iter.hasNext()) {
          Object o = iter.next();
          if (o instanceof InteractorValue) {
            l.add(takeSnapshot(((InteractorValue) v), ctx, coverage, trace));
          } else {
            l.add(o);
          }
        }
        s.add(value.name, l);
      } else if (v instanceof Map) {
        Map l = new HashMap();
        Map sourceMap = ((Map) v);
        Iterator<Object> iter = sourceMap.keySet().iterator();
        while (iter.hasNext()) {
          Object key = iter.next();
          Object val = sourceMap.get(key);
          if (val instanceof InteractorValue) {
            l.put(key, takeSnapshot(((InteractorValue) val), ctx, coverage, trace));
          } else {
            l.put(key, val);
          }
        }
        s.add(value.name, l);
      } else {
        s.add(value.name, v);
      }
    }
    return s;
  }

  @Override
  public Object getValue() {
    return this;
  }

  @Override
  public String toString() {
    return "live<" + baseValue.toString() + ">";
  }

  @Override
  public void setValue(Object newValue) {
    this.baseValue = ((InteractorValue) newValue);
  }

  @Override
  public Object createSnapshot() {
    return latestSnapshot;
  }

  @Override
  public boolean currentlyAllowsThisElement(IDElement element) {
    return this.baseValue.currentlyAllowsThisElement(element);
  }

}
