package org.iets3.core.expr.statemachines.editor;

/*Generated by MPS */

import com.mbeddr.mpsutil.grammarcells.runtime.AbstractGrammarActionDescriptor;
import com.mbeddr.mpsutil.grammarcells.runtime.IGrammarActionsDescriptor;
import java.util.List;
import jetbrains.mps.openapi.editor.menus.substitute.SubstituteMenuItem;
import jetbrains.mps.openapi.editor.menus.substitute.SubstituteMenuContext;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.editor.menus.EditorMenuDescriptorBase;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.model.SNode;
import com.mbeddr.mpsutil.grammarcells.runtime.GrammarCellsUtil;
import jetbrains.mps.openapi.editor.EditorContext;
import com.mbeddr.mpsutil.grammarcells.runtime.FlagSubstituteMenuItem;
import com.mbeddr.mpsutil.grammarcells.runtime.DefaultFlagModelAccess;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.smodel.SNodePointer;
import com.mbeddr.mpsutil.grammarcells.runtime.menu.GrammarCellsSubstituteMenuItem;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.action.SNodeFactoryOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.editor.runtime.selection.SelectionUtil;
import jetbrains.mps.editor.runtime.cells.CellIdManager;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuItem;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuContext;
import jetbrains.mps.lang.editor.menus.transformation.MenuLocations;
import jetbrains.mps.openapi.editor.cells.SubstituteAction;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.smodel.action.NodeSubstituteActionsFactoryContext;
import com.mbeddr.mpsutil.grammarcells.runtime.IToken;
import com.mbeddr.mpsutil.grammarcells.runtime.IRule;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SLanguage;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class GrammarActionsDescriptor extends AbstractGrammarActionDescriptor implements IGrammarActionsDescriptor {

  public static final GrammarActionsDescriptor INSTANCE = new GrammarActionsDescriptor();

  @Override
  public List<SubstituteMenuItem> getActions(final SubstituteMenuContext _context, final SAbstractConcept expectedOutputConceptExactly) {
    final List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());

    _context.getEditorMenuTrace().pushTraceInfo();
    _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("org.iets3.core.expr.statemachines.editor.GrammarActionsDescriptor.getActions", null));
    try {
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());

          {
            final SConcept outputConcept = CONCEPTS.StateMachine$He;

            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConceptExactly))) {
              final SNode parentNode = _context.getParentNode();
              final SNode substitutedNode = _context.getCurrentTargetNode();
              for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(outputConcept, _context.getModel(), StateMachine_Editor.class, _context.getEditorContext())) {
                EditorContext editorContext = _context.getEditorContext();
                boolean applicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                if (applicable) {
                  ListSequence.fromList(result).addElement(new FlagSubstituteMenuItem(parentNode, _context.getCurrentTargetNode(), subconcept, "strict", _context, new DefaultFlagModelAccess(PROPS.isStrict$_qyl)) {
                    @Nullable
                    @Override
                    public String getDescriptionText(@NotNull String pattern) {
                      String originalText = super.getDescriptionText(pattern);
                      EditorContext editorContext = _context.getEditorContext();
                      return "fail when no transition applies";
                    }
                  });
                }
              }
            }
          }

          return result;
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "EventArg", new SNodePointer("r:3ff9f818-daab-4449-aa16-e1231523d3a3(org.iets3.core.expr.statemachines.editor)", "7740953487931608082")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.EventArg$Ph)) {
              final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.EventArg$Ph, _context.getModel(), EventArg_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    ListSequence.fromList(result).addElement(new GrammarCellsSubstituteMenuItem(_context) {
                      private SProperty myProperty = PROPS.name$MnvL;

                      public String getMatchingText(String pattern) {
                        return pattern;
                      }
                      @Override
                      public boolean canExecute(@NotNull String pattern) {
                        if ((pattern == null || pattern.length() == 0)) {
                          return false;
                        }
                        return GrammarCellsUtil.isValidPropertyValue(myProperty, expectedOutputConceptExactly, pattern);
                      }
                      @Override
                      public boolean canExecuteStrictly(@NotNull String pattern) {
                        return canExecute(pattern);
                      }

                      @Override
                      public SNode createNode(@NotNull String pattern) {
                        SNode newNode = SNodeFactoryOperations.createNewNode(expectedOutputConceptExactly, null);
                        SPropertyOperations.assign(newNode, PROPS.name$MnvL, GrammarCellsUtil.toInternalPropertyValue(myProperty, pattern));

                        return newNode;
                      }


                      @Override
                      public void select(@NotNull SNode newNode, @NotNull String pattern) {
                        SelectionUtil.selectLabelCellAnSetCaret(_context.getEditorContext(), newNode, "*" + CellIdManager.createPropertyId("name"), -1);
                      }

                      @Override
                      public SAbstractConcept getOutputConcept() {
                        return CONCEPTS.EventArg$Ph;
                      }
                    });
                  }
                }

              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where((it) -> it != null).toList();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());

          {
            final SConcept outputConcept = CONCEPTS.StatemachineVar$Qb;

            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConceptExactly))) {
              final SNode parentNode = _context.getParentNode();
              final SNode substitutedNode = _context.getCurrentTargetNode();
              for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(outputConcept, _context.getModel(), StatemachineVar_Editor.class, _context.getEditorContext())) {
                EditorContext editorContext = _context.getEditorContext();
                boolean applicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                if (applicable) {
                  ListSequence.fromList(result).addElement(new FlagSubstituteMenuItem(parentNode, _context.getCurrentTargetNode(), subconcept, "observable", _context, new DefaultFlagModelAccess(PROPS.observable$wgmr)) {
                    @Nullable
                    @Override
                    public String getDescriptionText(@NotNull String pattern) {
                      String originalText = super.getDescriptionText(pattern);
                      EditorContext editorContext = _context.getEditorContext();
                      return "make the variable observable";
                    }
                  });
                }
              }
            }
          }

          return result;
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "Parameter", new SNodePointer("r:3ff9f818-daab-4449-aa16-e1231523d3a3(org.iets3.core.expr.statemachines.editor)", "24388123200217600")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.Parameter$Is)) {
              final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.Parameter$Is, _context.getModel(), Parameter_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    ListSequence.fromList(result).addElement(new GrammarCellsSubstituteMenuItem(_context) {
                      private SProperty myProperty = PROPS.name$MnvL;

                      public String getMatchingText(String pattern) {
                        return pattern;
                      }
                      @Override
                      public boolean canExecute(@NotNull String pattern) {
                        if ((pattern == null || pattern.length() == 0)) {
                          return false;
                        }
                        return GrammarCellsUtil.isValidPropertyValue(myProperty, expectedOutputConceptExactly, pattern);
                      }
                      @Override
                      public boolean canExecuteStrictly(@NotNull String pattern) {
                        return canExecute(pattern);
                      }

                      @Override
                      public SNode createNode(@NotNull String pattern) {
                        SNode newNode = SNodeFactoryOperations.createNewNode(expectedOutputConceptExactly, null);
                        SPropertyOperations.assign(newNode, PROPS.name$MnvL, GrammarCellsUtil.toInternalPropertyValue(myProperty, pattern));

                        return newNode;
                      }


                      @Override
                      public void select(@NotNull SNode newNode, @NotNull String pattern) {
                        super.select(newNode, pattern);
                      }

                      @Override
                      public SAbstractConcept getOutputConcept() {
                        return CONCEPTS.Parameter$Is;
                      }
                    });
                  }
                }

              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where((it) -> it != null).toList();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());

          {
            final SConcept outputConcept = CONCEPTS.StatemachineQuery$4e;

            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConceptExactly))) {
              final SNode parentNode = _context.getParentNode();
              final SNode substitutedNode = _context.getCurrentTargetNode();
              for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(outputConcept, _context.getModel(), StatemachineQuery_Editor.class, _context.getEditorContext())) {
                EditorContext editorContext = _context.getEditorContext();
                boolean applicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                if (applicable) {
                  ListSequence.fromList(result).addElement(new FlagSubstituteMenuItem(parentNode, _context.getCurrentTargetNode(), subconcept, "observable", _context, new DefaultFlagModelAccess(PROPS.observable$4F$u)) {});
                }
              }
            }
          }

          return result;
        }
      }.query()));
    } finally {
      _context.getEditorMenuTrace().popTraceInfo();
    }

    return ListSequence.fromList(result).where((it) -> it != null).toList();
  }

  @Override
  protected List<TransformationMenuItem> doGetSideTransformActions(final TransformationMenuContext _context) {
    final List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());

    _context.getEditorMenuTrace().pushTraceInfo();
    _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("org.iets3.core.expr.statemachines.editor.GrammarActionsDescriptor.doGetSideTransformActions", null));
    try {
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "EventArg", new SNodePointer("r:3ff9f818-daab-4449-aa16-e1231523d3a3(org.iets3.core.expr.statemachines.editor)", "7740953487931608082")));
              try {
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where((it) -> it != null).toList();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "Parameter", new SNodePointer("r:3ff9f818-daab-4449-aa16-e1231523d3a3(org.iets3.core.expr.statemachines.editor)", "24388123200217600")));
              try {
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where((it) -> it != null).toList();
            }
          }.query(_context)));
        }
      }
    } finally {
      _context.getEditorMenuTrace().popTraceInfo();
    }

    return ListSequence.fromList(result).where((it) -> it != null).toList();
  }

  @Override
  public List<SubstituteAction> getConstantReplaceActions(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context, final List<IToken> elementsBefore, final List<IToken> elementsAfter) {
    final List<SubstituteAction> result = ListSequence.fromList(new ArrayList<SubstituteAction>());

    return ListSequence.fromList(result).where((it) -> it != null).toList();
  }

  @Override
  public List<IRule> getRules(final SModel contextModel) {
    final List<IRule> rules = ListSequence.fromList(new ArrayList<IRule>());

    final Set<SLanguage> visibleLanguages = GrammarCellsUtil.getVisibleLanguages(contextModel);


    return rules;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept StateMachine$He = MetaAdapterFactory.getConcept(0xcd87ddab6434448eL, 0xa0111e1c898de18eL, 0x7939418a3e285ca3L, "org.iets3.core.expr.statemachines.structure.StateMachine");
    /*package*/ static final SConcept EventArg$Ph = MetaAdapterFactory.getConcept(0xcd87ddab6434448eL, 0xa0111e1c898de18eL, 0x2b547b5bcdbceedL, "org.iets3.core.expr.statemachines.structure.EventArg");
    /*package*/ static final SConcept StatemachineVar$Qb = MetaAdapterFactory.getConcept(0xcd87ddab6434448eL, 0xa0111e1c898de18eL, 0x2b547b5bce0e114L, "org.iets3.core.expr.statemachines.structure.StatemachineVar");
    /*package*/ static final SConcept Parameter$Is = MetaAdapterFactory.getConcept(0xcd87ddab6434448eL, 0xa0111e1c898de18eL, 0x56a4de6c1661d6L, "org.iets3.core.expr.statemachines.structure.Parameter");
    /*package*/ static final SConcept StatemachineQuery$4e = MetaAdapterFactory.getConcept(0xcd87ddab6434448eL, 0xa0111e1c898de18eL, 0x4bc699a4aee114fbL, "org.iets3.core.expr.statemachines.structure.StatemachineQuery");
  }

  private static final class PROPS {
    /*package*/ static final SProperty isStrict$_qyl = MetaAdapterFactory.getProperty(0xcd87ddab6434448eL, 0xa0111e1c898de18eL, 0x7939418a3e285ca3L, 0xfb2bd50a7ef87f2L, "isStrict");
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty observable$wgmr = MetaAdapterFactory.getProperty(0xcd87ddab6434448eL, 0xa0111e1c898de18eL, 0x2b547b5bce0e114L, 0x30d6adb796942bf5L, "observable");
    /*package*/ static final SProperty observable$4F$u = MetaAdapterFactory.getProperty(0xcd87ddab6434448eL, 0xa0111e1c898de18eL, 0x4bc699a4aee114fbL, 0x30d6adb796942bf5L, "observable");
  }
}
