package org.iets3.core.expr.typetags.behavior;

/*Generated by MPS */

import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Map;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.HashMap;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.List;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.Objects;
import jetbrains.mps.typechecking.TypecheckingFacade;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class BaseTaggedTypeHelper {

  public static Tuples._2<SNode, Map<SAbstractConcept, SNode>> getComponents(SNode type) {
    Map<SAbstractConcept, SNode> tagMap = new HashMap<SAbstractConcept, SNode>();
    SNode baseType = null;

    if (SNodeOperations.isInstanceOf(type, CONCEPTS.TaggedType$O4)) {
      List<SNode> leftTags = SLinkOperations.getChildren(SNodeOperations.cast(type, CONCEPTS.TaggedType$O4), LINKS.tags$Lx_i);
      for (SNode value : ListSequence.fromList(leftTags)) {
        SAbstractConcept concept = SNodeOperations.getConcept(ITag__BehaviorDescriptor.getBaseTag_id1RcasK0UAlt.invoke(value));
        tagMap.put(ITag__BehaviorDescriptor.getGroupingTagConcept_idx_aN5M65iL.invoke(SNodeOperations.asSConcept(concept)), value);
      }
      baseType = SLinkOperations.getTarget(SNodeOperations.cast(type, CONCEPTS.TaggedType$O4), LINKS.baseType$z6Mz);
    } else {
      baseType = type;
    }

    return MultiTuple.<SNode,Map<SAbstractConcept, SNode>>from(baseType, tagMap);
  }

  public static Map<SAbstractConcept, SNode> fillOnDemand(Map<SAbstractConcept, SNode> map, Set<SAbstractConcept> keys) {
    for (SAbstractConcept key : SetSequence.fromSet(keys)) {
      if (!(map.containsKey(key))) {
        map.put(key, null);
      }
    }
    return map;
  }

  public static SNode combine(SNode left, SNode right, SNode operator) {
    Tuples._2<SNode, Map<SAbstractConcept, SNode>> leftComponents = getComponents(left);
    Tuples._2<SNode, Map<SAbstractConcept, SNode>> rightComponents = getComponents(right);
    SNode leftBaseType = leftComponents._0();
    SNode rightBaseType = rightComponents._0();
    Map<SAbstractConcept, SNode> leftTagMap = leftComponents._1();
    Map<SAbstractConcept, SNode> rightTagMap = rightComponents._1();

    Set<SAbstractConcept> keys = new HashSet<SAbstractConcept>();
    keys.addAll(leftTagMap.keySet());
    keys.addAll(rightTagMap.keySet());

    fillOnDemand(leftTagMap, keys);
    fillOnDemand(rightTagMap, keys);

    SNode baseOperationType = TypeChecker.getInstance().getRulesManager().getOperationType(operator, leftBaseType, rightBaseType);

    if (baseOperationType == null) {
      return createRuntimeErrorType_wyrhxu_a0a61a5();
    } else {
      SNode result = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x186a8ed9947750b6L, "org.iets3.core.expr.typetags.structure.TaggedType"));
      SLinkOperations.setTarget(result, LINKS.baseType$z6Mz, SNodeOperations.cast(baseOperationType, CONCEPTS.Type$WK));

      for (SAbstractConcept key : SetSequence.fromSet(keys)) {
        SNode leftTag = MapSequence.fromMap(leftTagMap).get(key);
        SNode rightTag = MapSequence.fromMap(rightTagMap).get(key);
        SNode combined = ITag__BehaviorDescriptor.combine_id4HxogODTmVB.invoke(SNodeOperations.asSConcept(key), leftTag, rightTag, operator);
        if (combined != null) {
          if (SNodeOperations.isInstanceOf(combined, CONCEPTS.ErrorTag$yj)) {
            return createRuntimeErrorType_wyrhxu_a0a0a3a3a0q0f(SPropertyOperations.getString(SNodeOperations.cast(combined, CONCEPTS.ErrorTag$yj), PROPS.description$dnEg));
          } else {
            ListSequence.fromList(SLinkOperations.getChildren(result, LINKS.tags$Lx_i)).addElement(combined);
          }
        }
      }

      if (ListSequence.fromList(SLinkOperations.getChildren(result, LINKS.tags$Lx_i)).isEmpty()) {
        return SLinkOperations.getTarget(result, LINKS.baseType$z6Mz);
      } else {
        return result;
      }
    }
  }

  public static boolean allTagsSubsumed(SNode sub, SNode sup, SAbstractConcept excluded) {
    Tuples._2<SNode, Map<SAbstractConcept, SNode>> subComponents = BaseTaggedTypeHelper.getComponents(sub);
    Tuples._2<SNode, Map<SAbstractConcept, SNode>> supComponents = BaseTaggedTypeHelper.getComponents(sup);
    SNode subBaseType = subComponents._0();
    SNode supBaseType = supComponents._0();
    Map<SAbstractConcept, SNode> subTagMap = subComponents._1();
    Map<SAbstractConcept, SNode> supTagMap = supComponents._1();

    Set<SAbstractConcept> keys = SetSequence.fromSet(new HashSet<SAbstractConcept>());
    SetSequence.fromSet(keys).addSequence(SetSequence.fromSet(subTagMap.keySet()));
    SetSequence.fromSet(keys).addSequence(SetSequence.fromSet(supTagMap.keySet()));

    BaseTaggedTypeHelper.fillOnDemand(subTagMap, keys);
    BaseTaggedTypeHelper.fillOnDemand(supTagMap, keys);

    for (SAbstractConcept key : SetSequence.fromSet(keys)) {
      if (excluded != null && Objects.equals(key, excluded)) {
        continue;
      }

      SNode subTag = MapSequence.fromMap(subTagMap).get(key);
      SNode supTag = MapSequence.fromMap(supTagMap).get(key);

      if (subTag == null) {
        subTag = ITag__BehaviorDescriptor.getDefault_id1WJTL5jvcNW.invoke(SNodeOperations.asSConcept(key));
      }
      if (supTag == null) {
        supTag = ITag__BehaviorDescriptor.getDefault_id1WJTL5jvcNW.invoke(SNodeOperations.asSConcept(key));
      }
      if (!((boolean) ITag__BehaviorDescriptor.subsumes_id1RcasK0V7Pl.invoke(SNodeOperations.asSConcept(key), subTag, supTag))) {
        return false;
      }
    }

    if (!(TypecheckingFacade.getFromContext().isSubtype(subBaseType, supBaseType))) {
      return false;
    }

    return true;
  }

  private static SNode createRuntimeErrorType_wyrhxu_a0a61a5() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RuntimeErrorType$3c);
    return n0.getResult();
  }
  private static SNode createRuntimeErrorType_wyrhxu_a0a0a3a3a0q0f(String p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RuntimeErrorType$3c);
    n0.setProperty(PROPS.errorText$leWQ, p0);
    return n0.getResult();
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept TaggedType$O4 = MetaAdapterFactory.getConcept(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x186a8ed9947750b6L, "org.iets3.core.expr.typetags.structure.TaggedType");
    /*package*/ static final SConcept Type$WK = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x670d5e92f854a614L, "org.iets3.core.expr.base.structure.Type");
    /*package*/ static final SConcept ErrorTag$yj = MetaAdapterFactory.getConcept(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x4b61610d29e00172L, "org.iets3.core.expr.typetags.structure.ErrorTag");
    /*package*/ static final SConcept RuntimeErrorType$3c = MetaAdapterFactory.getConcept(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x113f84956f9L, "jetbrains.mps.lang.typesystem.structure.RuntimeErrorType");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink tags$Lx_i = MetaAdapterFactory.getContainmentLink(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x71bf4701bdf46b3eL, 0x186a8ed9947750b7L, "tags");
    /*package*/ static final SContainmentLink baseType$z6Mz = MetaAdapterFactory.getContainmentLink(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x186a8ed9947750b6L, 0x186a8ed9947750b9L, "baseType");
  }

  private static final class PROPS {
    /*package*/ static final SProperty description$dnEg = MetaAdapterFactory.getProperty(0x5186c6ce428c4f09L, 0xa9df73d9e86c27d3L, 0x4b61610d29e00172L, 0x5f4a60cc7cac2147L, "description");
    /*package*/ static final SProperty errorText$leWQ = MetaAdapterFactory.getProperty(0x7a5dda6291404668L, 0xab76d5ed1746f2b2L, 0x113f84956f9L, 0x113f84956faL, "errorText");
  }
}
