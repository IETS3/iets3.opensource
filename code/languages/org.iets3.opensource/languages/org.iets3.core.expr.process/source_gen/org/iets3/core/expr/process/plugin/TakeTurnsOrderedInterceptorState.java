package org.iets3.core.expr.process.plugin;

/*Generated by MPS */

import java.math.BigInteger;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import org.pcollections.PVector;
import org.pcollections.Empty;
import java.util.Objects;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;

public class TakeTurnsOrderedInterceptorState extends AbstractTakeTurnsInterceptorState {

  private int pos = -1;
  private BigInteger lastCommandTime = null;

  public TakeTurnsOrderedInterceptorState(SNode intc, List parties) {
    super(intc, parties);
  }

  private TakeTurnsOrderedInterceptorState(SNode intc, List parties, int last, BigInteger lastTime) {
    super(intc, parties);
    this.pos = last;
    this.lastCommandTime = lastTime;
  }

  public TakeTurnsOrderedInterceptorState update(int newLast, BigInteger newTime) {
    return new TakeTurnsOrderedInterceptorState(this.myIntc, this.parties, newLast, newTime);
  }

  public int lastSender() {
    return this.pos;
  }

  public BigInteger lastCommandTime() {
    return this.lastCommandTime;
  }

  public boolean isFirstCommand() {
    return this.lastCommandTime == null;
  }

  public void removeParty(Object tobeRemoved) {
    PVector res = Empty.vector();
    for (Object p : parties) {
      if (!(Objects.equals(p, tobeRemoved))) {
        res = res.plus(p);
      }
    }
    this.parties = res;
  }

  public Tuples._2<Object, Integer> nextParty() {
    int lastIdx = this.lastSender();
    int nextIdx = lastIdx + 1;
    if (nextIdx < 0 || nextIdx >= parties.size()) {
      nextIdx = 0;
    }
    return MultiTuple.<Object,Integer>from(parties.get(nextIdx), nextIdx);
  }

  public Tuples._2<Object, Integer> skipParty() {
    int lastIdx = this.lastSender();
    int nextIdx = lastIdx + 2;
    if (nextIdx < 0 || nextIdx >= parties.size()) {
      nextIdx = 0;
    }
    return MultiTuple.<Object,Integer>from(parties.get(nextIdx), nextIdx);
  }


}
