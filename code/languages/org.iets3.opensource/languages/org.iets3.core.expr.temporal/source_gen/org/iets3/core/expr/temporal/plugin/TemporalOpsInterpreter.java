package org.iets3.core.expr.temporal.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import com.mbeddr.mpsutil.interpreter.rt.IContext;
import com.mbeddr.mpsutil.interpreter.rt.ICoverageAnalyzer;
import com.mbeddr.mpsutil.interpreter.rt.ComputationTrace;
import org.iets3.core.expr.temporal.runtime.TemporalValue;
import java.util.Set;
import java.time.LocalDate;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.iets3.core.expr.base.plugin.MessageValue;
import org.iets3.core.expr.temporal.runtime.TemporalOps;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class TemporalOpsInterpreter {
  public static Object perform(SNode left, SNode right, _FunctionTypes._return_P2_E0<? extends Object, ? super Object, ? super Object> binop, IContext ctx, ICoverageAnalyzer cov, ComputationTrace trace) {
    Object lv = ctx.getRootInterpreter().evaluate(left, ctx, cov, trace, false);
    if (!(lv instanceof TemporalValue)) {
      return null;
    }
    Object rv = ctx.getRootInterpreter().evaluate(right, ctx, cov, trace, false);
    if (rv instanceof TemporalValue) {
      return doWithTwoTemporals(left, ((TemporalValue) lv), right, ((TemporalValue) rv), binop, ctx, trace);
    } else {
      return doWithOneTemporal(left, ((TemporalValue) lv), right, rv, binop, ctx, trace);
    }
  }

  public static TemporalValue doWithTwoTemporals(SNode left, TemporalValue leftValue, SNode right, TemporalValue rightValue, _FunctionTypes._return_P2_E0<? extends Object, ? super Object, ? super Object> binop, IContext ctx, ComputationTrace trace) {
    Set<LocalDate> allIntervals = SetSequence.fromSet(new HashSet<LocalDate>());
    SetSequence.fromSet(allIntervals).addSequence(ListSequence.fromList(leftValue.intervals()));
    SetSequence.fromSet(allIntervals).addSequence(ListSequence.fromList(rightValue.intervals()));
    TemporalValue res = new TemporalValue();
    for (LocalDate i : ListSequence.fromList(SetSequence.fromSet(allIntervals).toList()).sort((it) -> it, true)) {
      Object leftSlice = leftValue.valueAt(i);
      Object rightSlice = rightValue.valueAt(i);
      if (leftSlice == null) {
        Object def = ctx.getEnvironment().get(SNodeOperations.asNode(CONCEPTS.DefaultSliceValueExpr$PH));
        if (def != null) {
          leftSlice = def;
        } else {
          throw new InvalidSlicingExcptionInterpreter(left, new MessageValue("no value for left arg at " + i), null, ctx, trace);
        }
      }
      if (rightSlice == null) {
        Object def = ctx.getEnvironment().get(SNodeOperations.asNode(CONCEPTS.DefaultSliceValueExpr$PH));
        if (def != null) {
          rightSlice = def;
        } else {
          throw new InvalidSlicingExcptionInterpreter(right, new MessageValue("no value for right arg at " + i), null, ctx, trace);
        }
      }
      res = res.slice(i, binop.invoke(leftSlice, rightSlice));
    }
    return TemporalOps.joinSlices(res);
  }


  public static TemporalValue doWithOneTemporal(SNode left, TemporalValue leftValue, SNode right, Object rightValue, _FunctionTypes._return_P2_E0<? extends Object, ? super Object, ? super Object> binop, IContext ctx, ComputationTrace trace) {
    Set<LocalDate> allIntervals = SetSequence.fromSet(new HashSet<LocalDate>());
    SetSequence.fromSet(allIntervals).addSequence(ListSequence.fromList(leftValue.intervals()));
    TemporalValue res = new TemporalValue();
    for (LocalDate i : ListSequence.fromList(SetSequence.fromSet(allIntervals).toList()).sort((it) -> it, true)) {
      Object leftSliceVal = leftValue.valueAt(i);
      if (leftSliceVal == null) {
        Object def = ctx.getEnvironment().get(SNodeOperations.asNode(CONCEPTS.DefaultSliceValueExpr$PH));
        if (def != null) {
          leftSliceVal = def;
        } else {
          throw new InvalidSlicingExcptionInterpreter(left, new MessageValue("no value for left arg at " + i), null, ctx, trace);
        }
      }
      res = res.slice(i, binop.invoke(leftSliceVal, rightValue));
    }
    return res;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept DefaultSliceValueExpr$PH = MetaAdapterFactory.getConcept(0x4621d3e3b8a34bbeL, 0xb7ac234b6e2d1d68L, 0x36e6662fc4a89f0dL, "org.iets3.core.expr.temporal.structure.DefaultSliceValueExpr");
  }
}
