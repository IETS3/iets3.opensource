package org.iets3.core.expr.temporal.structure;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.ConceptPresentationAspectBase;
import jetbrains.mps.smodel.runtime.ConceptPresentation;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.runtime.ConceptPresentationBuilder;

public class ConceptPresentationAspectImpl extends ConceptPresentationAspectBase {
  private ConceptPresentation props_AbstractTemporalOp;
  private ConceptPresentation props_AfterOp;
  private ConceptPresentation props_AllTemporalQuantifier;
  private ConceptPresentation props_AlwaysExpression;
  private ConceptPresentation props_AnyTemporalQuantifier;
  private ConceptPresentation props_BeforeOp;
  private ConceptPresentation props_BetweenOp;
  private ConceptPresentation props_DefaultSliceValueExpr;
  private ConceptPresentation props_FullOverlapExpr;
  private ConceptPresentation props_IHaveOptionalPartsInTemporalContext;
  private ConceptPresentation props_IProvideTemporalContext;
  private ConceptPresentation props_IntervalsOp;
  private ConceptPresentation props_MapSlicesOp;
  private ConceptPresentation props_MaskOp;
  private ConceptPresentation props_NoneTemporalQuantifier;
  private ConceptPresentation props_NumerOfSlices;
  private ConceptPresentation props_ReduceOp;
  private ConceptPresentation props_ReduceStrategy;
  private ConceptPresentation props_ReduceStrategyFirst;
  private ConceptPresentation props_ReduceStrategyLast;
  private ConceptPresentation props_ReduceStrategySum;
  private ConceptPresentation props_ReduceStrategyWeighted;
  private ConceptPresentation props_Slice;
  private ConceptPresentation props_SpreadValuesOp;
  private ConceptPresentation props_TemporalLiteral;
  private ConceptPresentation props_TemporalQuantifier;
  private ConceptPresentation props_TemporalType;
  private ConceptPresentation props_ValueAtOp;
  private ConceptPresentation props_WithSliceOp;

  @Override
  @Nullable
  public ConceptPresentation getDescriptor(SAbstractConcept c) {
    StructureAspectDescriptor structureDescriptor = (StructureAspectDescriptor) myLanguageRuntime.getAspect(jetbrains.mps.smodel.runtime.StructureAspectDescriptor.class);
    switch (structureDescriptor.internalIndex(c)) {
      case LanguageConceptSwitch.AbstractTemporalOp:
        if (props_AbstractTemporalOp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a base operation for operations on temporal values");
          props_AbstractTemporalOp = cpb.create();
        }
        return props_AbstractTemporalOp;
      case LanguageConceptSwitch.AfterOp:
        if (props_AfterOp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a value with all slices after the specified date");
          cpb.rawPresentation("after");
          props_AfterOp = cpb.create();
        }
        return props_AfterOp;
      case LanguageConceptSwitch.AllTemporalQuantifier:
        if (props_AllTemporalQuantifier == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("an all quantifier");
          cpb.rawPresentation("all");
          props_AllTemporalQuantifier = cpb.create();
        }
        return props_AllTemporalQuantifier;
      case LanguageConceptSwitch.AlwaysExpression:
        if (props_AlwaysExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a temporal value with one slice, starting at beginning of time");
          cpb.rawPresentation("always");
          props_AlwaysExpression = cpb.create();
        }
        return props_AlwaysExpression;
      case LanguageConceptSwitch.AnyTemporalQuantifier:
        if (props_AnyTemporalQuantifier == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("an any quantifier");
          cpb.rawPresentation("any");
          props_AnyTemporalQuantifier = cpb.create();
        }
        return props_AnyTemporalQuantifier;
      case LanguageConceptSwitch.BeforeOp:
        if (props_BeforeOp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a value with all slices before the specified date");
          cpb.rawPresentation("before");
          props_BeforeOp = cpb.create();
        }
        return props_BeforeOp;
      case LanguageConceptSwitch.BetweenOp:
        if (props_BetweenOp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a value with all slices between the specified dates, or in a range");
          cpb.rawPresentation("between");
          props_BetweenOp = cpb.create();
        }
        return props_BetweenOp;
      case LanguageConceptSwitch.DefaultSliceValueExpr:
        if (props_DefaultSliceValueExpr == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("inject a default value, if no slice covers the date");
          cpb.rawPresentation("with-default-value");
          props_DefaultSliceValueExpr = cpb.create();
        }
        return props_DefaultSliceValueExpr;
      case LanguageConceptSwitch.FullOverlapExpr:
        if (props_FullOverlapExpr == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("check if two temporal values overlap fully");
          cpb.rawPresentation("overlap-fully");
          props_FullOverlapExpr = cpb.create();
        }
        return props_FullOverlapExpr;
      case LanguageConceptSwitch.IHaveOptionalPartsInTemporalContext:
        if (props_IHaveOptionalPartsInTemporalContext == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_IHaveOptionalPartsInTemporalContext = cpb.create();
        }
        return props_IHaveOptionalPartsInTemporalContext;
      case LanguageConceptSwitch.IProvideTemporalContext:
        if (props_IProvideTemporalContext == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          props_IProvideTemporalContext = cpb.create();
        }
        return props_IProvideTemporalContext;
      case LanguageConceptSwitch.IntervalsOp:
        if (props_IntervalsOp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("get a list containing the time values of all slices");
          cpb.rawPresentation("intervals");
          props_IntervalsOp = cpb.create();
        }
        return props_IntervalsOp;
      case LanguageConceptSwitch.MapSlicesOp:
        if (props_MapSlicesOp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("create a temporal value with the same slices, but mapped values");
          cpb.rawPresentation("mapEach");
          props_MapSlicesOp = cpb.create();
        }
        return props_MapSlicesOp;
      case LanguageConceptSwitch.MaskOp:
        if (props_MaskOp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("mask the context with a TT<boolean>, else otherwise");
          cpb.rawPresentation("mask");
          props_MaskOp = cpb.create();
        }
        return props_MaskOp;
      case LanguageConceptSwitch.NoneTemporalQuantifier:
        if (props_NoneTemporalQuantifier == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a none quantifier");
          cpb.rawPresentation("none");
          props_NoneTemporalQuantifier = cpb.create();
        }
        return props_NoneTemporalQuantifier;
      case LanguageConceptSwitch.NumerOfSlices:
        if (props_NumerOfSlices == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("get the number of slices");
          cpb.rawPresentation("numberOfSlices");
          props_NumerOfSlices = cpb.create();
        }
        return props_NumerOfSlices;
      case LanguageConceptSwitch.ReduceOp:
        if (props_ReduceOp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("create a single value from a temporal value");
          cpb.rawPresentation("reduce");
          props_ReduceOp = cpb.create();
        }
        return props_ReduceOp;
      case LanguageConceptSwitch.ReduceStrategy:
        if (props_ReduceStrategy == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a base concept for reduce strategies");
          props_ReduceStrategy = cpb.create();
        }
        return props_ReduceStrategy;
      case LanguageConceptSwitch.ReduceStrategyFirst:
        if (props_ReduceStrategyFirst == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("reduce to the value from the first slice");
          cpb.rawPresentation("FIRST");
          props_ReduceStrategyFirst = cpb.create();
        }
        return props_ReduceStrategyFirst;
      case LanguageConceptSwitch.ReduceStrategyLast:
        if (props_ReduceStrategyLast == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("reduce to the value from the last slice");
          cpb.rawPresentation("LAST");
          props_ReduceStrategyLast = cpb.create();
        }
        return props_ReduceStrategyLast;
      case LanguageConceptSwitch.ReduceStrategySum:
        if (props_ReduceStrategySum == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("reduce to the sum of values of all slices");
          cpb.rawPresentation("SUM");
          props_ReduceStrategySum = cpb.create();
        }
        return props_ReduceStrategySum;
      case LanguageConceptSwitch.ReduceStrategyWeighted:
        if (props_ReduceStrategyWeighted == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("reduce to the average of values of all slices, weighted by slice duration");
          cpb.rawPresentation("WEIGHTED");
          props_ReduceStrategyWeighted = cpb.create();
        }
        return props_ReduceStrategyWeighted;
      case LanguageConceptSwitch.Slice:
        if (props_Slice == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a temporal value slice");
          cpb.rawPresentation("Slice");
          props_Slice = cpb.create();
        }
        return props_Slice;
      case LanguageConceptSwitch.SpreadValuesOp:
        if (props_SpreadValuesOp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("create a list of values from the temporal slices");
          cpb.rawPresentation("spreadValues");
          props_SpreadValuesOp = cpb.create();
        }
        return props_SpreadValuesOp;
      case LanguageConceptSwitch.TemporalLiteral:
        if (props_TemporalLiteral == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a temporal value");
          cpb.rawPresentation("TT");
          props_TemporalLiteral = cpb.create();
        }
        return props_TemporalLiteral;
      case LanguageConceptSwitch.TemporalQuantifier:
        if (props_TemporalQuantifier == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a base operation for temporal quantifiers");
          props_TemporalQuantifier = cpb.create();
        }
        return props_TemporalQuantifier;
      case LanguageConceptSwitch.TemporalType:
        if (props_TemporalType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a temporal type");
          cpb.rawPresentation("TT");
          props_TemporalType = cpb.create();
        }
        return props_TemporalType;
      case LanguageConceptSwitch.ValueAtOp:
        if (props_ValueAtOp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("get the value of the slice for the specified date");
          cpb.rawPresentation("valueAt");
          props_ValueAtOp = cpb.create();
        }
        return props_ValueAtOp;
      case LanguageConceptSwitch.WithSliceOp:
        if (props_WithSliceOp == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("create a new temporal value with an additional slice");
          cpb.rawPresentation("with");
          props_WithSliceOp = cpb.create();
        }
        return props_WithSliceOp;
    }
    return null;
  }
}
