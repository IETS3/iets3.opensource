package org.iets3.core.expr.temporal.structure;

/*Generated by MPS */

import jetbrains.mps.lang.smodel.LanguageConceptIndex;
import jetbrains.mps.lang.smodel.LanguageConceptIndexBuilder;
import jetbrains.mps.smodel.adapter.ids.SConceptId;
import org.jetbrains.mps.openapi.language.SAbstractConcept;

public final class LanguageConceptSwitch {
  private final LanguageConceptIndex myIndex;
  public static final int AbstractTemporalOp = 0;
  public static final int AfterOp = 1;
  public static final int AllTemporalQuantifier = 2;
  public static final int AlwaysExpression = 3;
  public static final int AnyTemporalQuantifier = 4;
  public static final int BeforeOp = 5;
  public static final int BetweenOp = 6;
  public static final int DefaultSliceValueExpr = 7;
  public static final int FullOverlapExpr = 8;
  public static final int IHaveOptionalPartsInTemporalContext = 9;
  public static final int IProvideTemporalContext = 10;
  public static final int IntervalsOp = 11;
  public static final int MapSlicesOp = 12;
  public static final int MaskOp = 13;
  public static final int NoneTemporalQuantifier = 14;
  public static final int NumerOfSlices = 15;
  public static final int ReduceOp = 16;
  public static final int ReduceStrategy = 17;
  public static final int ReduceStrategyFirst = 18;
  public static final int ReduceStrategyLast = 19;
  public static final int ReduceStrategySum = 20;
  public static final int ReduceStrategyWeighted = 21;
  public static final int Slice = 22;
  public static final int SpreadValuesOp = 23;
  public static final int TemporalLiteral = 24;
  public static final int TemporalQuantifier = 25;
  public static final int TemporalType = 26;
  public static final int ValueAtOp = 27;
  public static final int WithSliceOp = 28;

  public LanguageConceptSwitch() {
    LanguageConceptIndexBuilder builder = new LanguageConceptIndexBuilder(0x4621d3e3b8a34bbeL, 0xb7ac234b6e2d1d68L);
    builder.put(0x501c5b607b3200f0L, AbstractTemporalOp);
    builder.put(0x35ec8ca87a7640a3L, AfterOp);
    builder.put(0x7abe382d722eeba5L, AllTemporalQuantifier);
    builder.put(0x47d868c57984d344L, AlwaysExpression);
    builder.put(0x7abe382d722eeba6L, AnyTemporalQuantifier);
    builder.put(0x35ec8ca87a8bdaceL, BeforeOp);
    builder.put(0x35ec8ca87a8f2a7bL, BetweenOp);
    builder.put(0x36e6662fc4a89f0dL, DefaultSliceValueExpr);
    builder.put(0x72b77efdab190518L, FullOverlapExpr);
    builder.put(0x552efb055957730bL, IHaveOptionalPartsInTemporalContext);
    builder.put(0x2696a44e3c9d0038L, IProvideTemporalContext);
    builder.put(0x501c5b607b36a89fL, IntervalsOp);
    builder.put(0x6a0281468755b8caL, MapSlicesOp);
    builder.put(0x6a028146873c3bf6L, MaskOp);
    builder.put(0x7abe382d722eeba7L, NoneTemporalQuantifier);
    builder.put(0x501c5b607b3229e5L, NumerOfSlices);
    builder.put(0x1c9918267502c234L, ReduceOp);
    builder.put(0x1c9918267502c238L, ReduceStrategy);
    builder.put(0x1c9918267502c262L, ReduceStrategyFirst);
    builder.put(0x1c9918267502c23cL, ReduceStrategyLast);
    builder.put(0xf07b20cb21e68b5L, ReduceStrategySum);
    builder.put(0x65ea67912ce4aee9L, ReduceStrategyWeighted);
    builder.put(0x501c5b607b236a91L, Slice);
    builder.put(0x35ec8ca87a763ff3L, SpreadValuesOp);
    builder.put(0x501c5b607b236a8eL, TemporalLiteral);
    builder.put(0x7abe382d722d731bL, TemporalQuantifier);
    builder.put(0x501c5b607b212209L, TemporalType);
    builder.put(0x501c5b607b3a1ef2L, ValueAtOp);
    builder.put(0x6a028146874b5723L, WithSliceOp);
    myIndex = builder.seal();
  }

  /*package*/ int index(SConceptId cid) {
    return myIndex.index(cid);
  }

  public int index(SAbstractConcept concept) {
    return myIndex.index(concept);
  }
}
