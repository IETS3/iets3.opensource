package org.iets3.core.expr.base.behavior;

/*Generated by MPS */

import java.util.Set;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.annotations.NotNull;
import java.awt.Color;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import com.mbeddr.mpsutil.interpreter.behavior.ICanHaveTestCoverage__BehaviorDescriptor;
import java.util.Objects;
import org.jetbrains.mps.openapi.language.SLanguage;
import java.util.List;
import com.mbeddr.mpsutil.interpreter.rt.IEvaluator;
import java.math.BigInteger;
import java.math.BigDecimal;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;

/**
 * Complete non-static implementation of {@link org.iets3.core.expr.base.behavior.IDefaultCoverageAnalyzer }.
 */
public class DefaultCoverageAnalyzerBase implements IDefaultCoverageAnalyzer {
  public static class ConceptDataBase implements IDefaultCoverageAnalyzer.IConceptData {

    private Set<String> branches;
    private Set<String> visitedBranches;
    private boolean visitedAtAll = false;
    private SAbstractConcept concept;

    public ConceptDataBase(SAbstractConcept ccc) {
      concept = ccc;
    }

    @Override
    public void registerBranches(String[] branches) {
      if (this.branches == null) {
        this.branches = SetSequence.fromSet(new HashSet<String>());
        this.visitedBranches = SetSequence.fromSet(new HashSet<String>());
      }
      SetSequence.fromSet(this.branches).addSequence(Sequence.fromIterable(Sequence.fromArray(branches)));
    }

    @Override
    public SAbstractConcept concept() {
      return this.concept;
    }

    @Override
    public void visitBranch(@NotNull String branchID) {
      SetSequence.fromSet(this.visitedBranches).addElement(branchID);
      this.visitedAtAll = true;
    }

    @Override
    public boolean isComplete() {
      if (this.branches == null) {
        return visitedAtAll;
      }
      return SetSequence.fromSet(this.branches).all((it) -> SetSequence.fromSet(ConceptDataBase.this.visitedBranches).contains(it));
    }

    @Override
    public String status() {
      if (this.branches == null) {
        return (visitedAtAll ? IDefaultCoverageAnalyzer.COVERED : IDefaultCoverageAnalyzer.MISSING);
      }
      if (Sequence.fromIterable(unvisitedBranches()).isEmpty()) {
        return IDefaultCoverageAnalyzer.COVERED;
      }
      return IDefaultCoverageAnalyzer.PARTIAL + " Missing: " + unvisitedBranches();
    }

    @Override
    public Color color() {
      if (this.branches == null) {
        return (visitedAtAll ? IDefaultCoverageAnalyzer.COVERED_COLOR : IDefaultCoverageAnalyzer.MISSING_COLOR);
      }
      return IDefaultCoverageAnalyzer.PARTIAL_COLOR;
    }

    @Override
    public void visited() {
      visitedAtAll = true;
    }

    @Override
    public Iterable<String> unvisitedBranches() {
      return SetSequence.fromSet(this.branches).where((it) -> !(SetSequence.fromSet(ConceptDataBase.this.visitedBranches).contains(it)));
    }

    @Override
    public String toString() {
      StringBuffer sb = new StringBuffer();
      sb.append(this.concept.getName());
      if (!(this.visitedAtAll)) {
        sb.append(" not visited.");
      } else if (!(this.isComplete())) {
        sb.append(" missing " + unvisitedBranches());
      }
      return sb.toString();
    }
  }

  public static class ValueCoverageBase implements IDefaultCoverageAnalyzer.IValueCoverage {
    private String name;
    private Object value;
    private _FunctionTypes._return_P2_E0<? extends Boolean, ? super Object, ? super Object> decisionToStore;
    private _FunctionTypes._return_P1_E0<? extends Object, ? super Object> valueConverter;

    public ValueCoverageBase(String n, _FunctionTypes._return_P2_E0<? extends Boolean, ? super Object, ? super Object> predicate) {
      name = n;
      decisionToStore = predicate;
    }

    public ValueCoverageBase(String n, _FunctionTypes._return_P2_E0<? extends Boolean, ? super Object, ? super Object> pred, _FunctionTypes._return_P1_E0<? extends Object, ? super Object> vc) {
      name = n;
      decisionToStore = pred;
      valueConverter = vc;
    }

    @Override
    public boolean storeValueInsteadOfOldOne(Object newValue, Object oldValue) {
      return decisionToStore.invoke(newValue, oldValue);
    }

    @Override
    public Object valueToBeStored(Object newValue) {
      if (valueConverter != null) {
        return valueConverter.invoke(newValue);
      }
      return newValue;
    }

    @Override
    public void registerValue(Object newValue) {
      if (value == null) {
        value = valueToBeStored(newValue);
      } else {
        if (storeValueInsteadOfOldOne(newValue, value)) {
          value = valueToBeStored(newValue);
        }
      }
    }

    @Override
    public Tuples._2<String, Object> result() {
      return MultiTuple.<String,Object>from(this.name, this.value);
    }

    @Override
    public String toString() {
      Tuples._2<String, Object> r = result();
      return r._0() + ": " + r._1();
    }

    @Override
    public String getName() {
      return this.name;
    }
    @Override
    public Object getValue() {
      return this.value;
    }
  }

  public static class ValueStatisticsBase implements IDefaultCoverageAnalyzer.IValueStatistics {

    private Map<Object, IDefaultCoverageAnalyzer.IValueCoverage> values = MapSequence.fromMap(new HashMap<Object, IDefaultCoverageAnalyzer.IValueCoverage>());

    @Override
    public void newValue(String key, Object newValue) {
      IDefaultCoverageAnalyzer.IValueCoverage s = MapSequence.fromMap(values).get(key);
      if (s != null) {
        s.registerValue(newValue);
      }
    }

    @Override
    public void registerAnalyzer(IDefaultCoverageAnalyzer.IValueCoverage analyzer) {
      MapSequence.fromMap(values).put(analyzer.getName(), analyzer);
    }

    @Override
    public Iterable<IDefaultCoverageAnalyzer.IValueCoverage> getData() {
      return Sequence.fromIterable(MapSequence.fromMap(this.values).values()).ofType(IDefaultCoverageAnalyzer.IValueCoverage.class);
    }

    @Override
    public boolean isEmpty() {
      return MapSequence.fromMap(this.values).isEmpty();
    }
  }

  public class NodeCoverageBase implements IDefaultCoverageAnalyzer.INodeCoverage {

    private SNode node;
    private String status;

    public NodeCoverageBase(SNode node) {
      this.node = node;
    }

    public NodeCoverageBase(SNode node, String status) {
      this.node = node;
      this.status = status;
    }

    @Override
    public int totalVisitable() {
      Iterable<SNode> childrenForCoverage = getChildrenForCoverage();
      return Sequence.fromIterable(childrenForCoverage).select((it) -> {
        IDefaultCoverageAnalyzer.INodeCoverage childCoverage = getNodeCoverage(it);
        return childCoverage.totalVisitable() + 1;
      }).foldLeft(0, (Integer total, Integer it) -> total + it);
    }

    @NotNull
    protected IDefaultCoverageAnalyzer.INodeCoverage getNodeCoverage(@NotNull SNode node) {
      return getNodeCoverageEx(node);
    }

    @Override
    public int getCoverageRatio() {
      if (isEmptyString(this.status) || this.status.startsWith(IDefaultCoverageAnalyzer.MISSING)) {
        return 0;
      } else if (this.status.startsWith(IDefaultCoverageAnalyzer.COVERED)) {
        return 100;
      } else {
        int total = totalVisitable();
        int visited = ListSequence.fromList(SNodeOperations.getNodeDescendants(node, null, false, new SAbstractConcept[]{})).where((it) -> isNodeCovered(it) || isNodePartiallyCovered(it)).count();
        return (int) Math.floor((100.0 * visited) / total);
      }
    }

    protected boolean isNodeCovered(@NotNull SNode node) {
      return isNodeCoveredEx(node);
    }

    protected boolean isNodePartiallyCovered(@NotNull SNode node) {
      return isNodePartiallyCoveredEx(node);
    }

    private Iterable<SNode> getChildrenForCoverage() {
      Iterable<SNode> childrenForCoverage;
      if (SNodeOperations.isInstanceOf(node, CONCEPTS.ICanHaveTestCoverage$33)) {
        childrenForCoverage = ICanHaveTestCoverage__BehaviorDescriptor.getChildrenForCoverage_id5IKJrJHNCE8.invoke(SNodeOperations.cast(node, CONCEPTS.ICanHaveTestCoverage$33));
      } else {
        childrenForCoverage = SNodeOperations.getChildren(node);
      }
      return Sequence.fromIterable(childrenForCoverage).where((it) -> !(SNodeOperations.isInstanceOf(it, CONCEPTS.IEmpty$6_)) && !(SNodeOperations.isInstanceOf(it, CONCEPTS.IExcludeFromCoverage$z4)) && !(SNodeOperations.isInstanceOf(it, CONCEPTS.ElementDocumentation$BO)));
    }

    public void updateResultStatus() {
      this.status = IDefaultCoverageAnalyzer.COVERED;
      Sequence.fromIterable(getChildrenForCoverage()).visitAll((it) -> {
        IDefaultCoverageAnalyzer.INodeCoverage childCoverage = getNodeCoverage(it);
        if (!(Objects.equals(childCoverage.getStatus(), IDefaultCoverageAnalyzer.COVERED))) {
          NodeCoverageBase.this.status = IDefaultCoverageAnalyzer.PARTIAL;
        }
      });
    }

    @Override
    public String getStatus() {
      return this.status;
    }

    @Override
    public SNode getNode() {
      return this.node;
    }
  }

  private Set<String> visitedEvaluators = SetSequence.fromSet(new HashSet<String>());
  private Map<SAbstractConcept, IDefaultCoverageAnalyzer.IConceptData> visitedConcepts = MapSequence.fromMap(new HashMap<SAbstractConcept, IDefaultCoverageAnalyzer.IConceptData>());
  private Set<SLanguage> registeredLanguages = SetSequence.fromSet(new HashSet<SLanguage>());
  private Set<SAbstractConcept> ignoredConcepts = SetSequence.fromSet(new HashSet<SAbstractConcept>());
  private Set<SAbstractConcept> measuredConcepts = SetSequence.fromSet(new HashSet<SAbstractConcept>());
  private Map<SNode, IDefaultCoverageAnalyzer.INodeCoverage> visitedNodes = MapSequence.fromMap(new HashMap<SNode, IDefaultCoverageAnalyzer.INodeCoverage>());
  private IDefaultCoverageAnalyzer.IValueStatistics statistics = new ValueStatisticsBase();
  private Map<SNode, List<Object>> values = MapSequence.fromMap(new HashMap<SNode, List<Object>>());

  public DefaultCoverageAnalyzerBase() {
  }

  @Override
  public int ratioEx() {
    return 100 - ((int) (((float) Sequence.fromIterable(getMissingConceptsOrIncomplete()).count()) / ((float) Sequence.fromIterable(getAllConceptsStatus()).count()) * 100));
  }

  @Override
  public void visitedConcept(@NotNull SAbstractConcept ccc) {
    getConceptData(ccc).visited();
  }

  @NotNull
  private IDefaultCoverageAnalyzer.IConceptData getConceptData(@NotNull SAbstractConcept ccc) {
    IDefaultCoverageAnalyzer.IConceptData data = MapSequence.fromMap(visitedConcepts).get(ccc);
    if (data == null) {
      data = new ConceptDataBase(ccc);
      MapSequence.fromMap(visitedConcepts).put(ccc, data);
    }
    return data;
  }

  @Override
  public void visitedConceptBranch(@NotNull SAbstractConcept ccc, @NotNull String branchID) {
    IDefaultCoverageAnalyzer.IConceptData data = getConceptData(ccc);
    data.visitBranch(branchID);
  }

  @Override
  public void visitedEvaluator(@NotNull IEvaluator evaluator) {
    SetSequence.fromSet(visitedEvaluators).addElement(evaluator.getInfo().conceptName);
  }

  @Override
  public void registerBranches(@NotNull SAbstractConcept ccc, String[] branchIDs) {
    getConceptData(ccc).registerBranches(branchIDs);
  }

  @Override
  public void setupValueStatistics() {
    statistics.registerAnalyzer(new ValueCoverageBase("integer.min", (Object oldVal, Object newVal) -> ((BigInteger) oldVal).compareTo(((BigInteger) newVal)) < 0));
    statistics.registerAnalyzer(new ValueCoverageBase("integer.max", (Object newVal, Object oldVal) -> ((BigInteger) newVal).compareTo(((BigInteger) oldVal)) > 0));
    statistics.registerAnalyzer(new ValueCoverageBase("integer.zero", (Object newVal, Object oldVal) -> ((BigInteger) newVal).compareTo(BigInteger.ZERO) == 0, (Object val) -> true));
    statistics.registerAnalyzer(new ValueCoverageBase("integer.one", (Object newVal, Object oldVal) -> ((BigInteger) newVal).compareTo(BigInteger.ONE) == 0, (Object val) -> true));
    statistics.registerAnalyzer(new ValueCoverageBase("integer.minusOne", (Object newVal, Object oldVal) -> ((BigInteger) newVal).compareTo(new BigInteger("-1")) == 0, (Object val) -> true));

    statistics.registerAnalyzer(new ValueCoverageBase("decimal.min", (Object newVal, Object oldVal) -> ((BigDecimal) newVal).compareTo(((BigDecimal) oldVal)) < 0));
    statistics.registerAnalyzer(new ValueCoverageBase("decimal.max", (Object newVal, Object oldVal) -> ((BigDecimal) newVal).compareTo(((BigDecimal) oldVal)) > 0));
    statistics.registerAnalyzer(new ValueCoverageBase("decimal.zero", (Object newVal, Object oldVal) -> ((BigDecimal) newVal).compareTo(BigDecimal.ZERO) == 0, (Object val) -> true));
    statistics.registerAnalyzer(new ValueCoverageBase("decimal.one", (Object newVal, Object oldVal) -> ((BigDecimal) newVal).compareTo(BigDecimal.ONE) == 0, (Object val) -> true));
    statistics.registerAnalyzer(new ValueCoverageBase("decimal.minusOne", (Object newVal, Object oldVal) -> ((BigDecimal) newVal).compareTo(new BigDecimal("-1")) == 0, (Object val) -> true));
  }

  @Override
  public List<SAbstractConcept> getAllConcepts() {
    List<SAbstractConcept> res = ListSequence.fromList(new ArrayList<SAbstractConcept>());
    for (SLanguage l : SetSequence.fromSet(registeredLanguages)) {
      for (final SAbstractConcept c : Sequence.fromIterable(l.getConcepts())) {
        if (c.isAbstract()) {
          continue;
        }
        if (c instanceof SInterfaceConcept) {
          continue;
        }
        if (SetSequence.fromSet(ignoredConcepts).any((it) -> c.isSubConceptOf(it))) {
          continue;
        }
        ListSequence.fromList(res).addElement(c);
      }
    }
    return res;
  }

  @Override
  public Iterable<? extends IDefaultCoverageAnalyzer.IConceptData> getMissingConceptsOrIncomplete() {
    return Sequence.fromIterable(getAllConceptsStatus()).where((it) -> !(it.isComplete()));
  }

  @Override
  public Iterable<? extends IDefaultCoverageAnalyzer.IConceptData> getAllConceptsStatus() {
    return ListSequence.fromList(getAllConcepts()).select((it) -> {
      IDefaultCoverageAnalyzer.IConceptData ccc = getVisitedConcepts(it);
      if (ccc == null) {
        return new ConceptDataBase(it);
      }
      return ccc;
    });
  }
  protected IDefaultCoverageAnalyzer.IConceptData getVisitedConcepts(SAbstractConcept concept) {
    return MapSequence.fromMap(visitedConcepts).get(concept);
  }

  @Override
  public Set<SNode> getAllCoveredNodes() {
    return MapSequence.fromMap(visitedNodes).keySet();
  }

  @Override
  public boolean hasNodeCoverageEx(@NotNull SNode node) {
    return MapSequence.fromMap(visitedNodes).get(node) != null;
  }

  @NotNull
  @Override
  public IDefaultCoverageAnalyzer.INodeCoverage getNodeCoverageEx(@NotNull SNode node) {
    IDefaultCoverageAnalyzer.INodeCoverage coverageData = MapSequence.fromMap(visitedNodes).get(node);
    if (coverageData == null) {
      // if any descendant has been visited, deep node coverage should be updated
      if (ListSequence.fromList(SNodeOperations.getNodeDescendants(node, null, false, new SAbstractConcept[]{})).any((it) -> hasNodeCoverageEx(it))) {
        coverageData = new NodeCoverageBase(node);
        coverageData.updateResultStatus();
      } else {
        coverageData = new NodeCoverageBase(node, IDefaultCoverageAnalyzer.MISSING);
      }
      MapSequence.fromMap(visitedNodes).put(node, coverageData);
    }
    if (isEmptyString(coverageData.getStatus())) {
      coverageData.updateResultStatus();
    }
    return coverageData;
  }

  @Override
  public boolean isNodeCoveredEx(@NotNull SNode node) {
    return hasNodeCoverageEx(node) && getNodeCoverageEx(node).getStatus().startsWith(IDefaultCoverageAnalyzer.COVERED);
  }

  @Override
  public boolean isNodePartiallyCoveredEx(@NotNull SNode node) {
    return hasNodeCoverageEx(node) && getNodeCoverageEx(node).getStatus().startsWith(IDefaultCoverageAnalyzer.PARTIAL);
  }

  @Override
  public boolean isNodeNotCoveredEx(@NotNull SNode node) {
    return hasNodeCoverageEx(node) && getNodeCoverageEx(node).getStatus().startsWith(IDefaultCoverageAnalyzer.MISSING);
  }

  @Override
  public void visitNodeEx(@NotNull SNode node) {
    MapSequence.fromMap(visitedNodes).put(node, new NodeCoverageBase(node));
  }

  @Override
  public void registerLanguageEx(@NotNull SLanguage l) {
    SetSequence.fromSet(registeredLanguages).addElement(l);
  }

  @Override
  public void registerIgnoredConceptEx(@NotNull SAbstractConcept c) {
    SetSequence.fromSet(ignoredConcepts).addElement(c);
  }

  @Override
  public void registerMeasuredConceptEx(@NotNull SAbstractConcept c) {
    SetSequence.fromSet(measuredConcepts).addElement(c);
  }

  @Override
  public boolean isInInterestingContextEx(@NotNull SNode n) {
    if (isInterestingConceptEx(n)) {
      return true;
    }
    return ListSequence.fromList(SNodeOperations.getNodeAncestors(n, null, false)).any((it) -> isInterestingConceptEx(it));
  }

  @Override
  public boolean isInterestingConceptEx(@NotNull final SNode n) {
    SAbstractConcept c = SNodeOperations.getConcept(n);
    if (SetSequence.fromSet(measuredConcepts).contains(c)) {
      return true;
    }
    if (SetSequence.fromSet(measuredConcepts).any((it) -> SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.getConcept(n)), SNodeOperations.asSConcept(it)))) {
      return true;
    }
    return false;
  }

  @Override
  public IDefaultCoverageAnalyzer.IValueStatistics getValueStatisticsEx() {
    return statistics;
  }

  @Override
  public boolean isIgnoredEx(@NotNull final SNode n) {
    return SetSequence.fromSet(ignoredConcepts).contains(SNodeOperations.getConcept(n)) || SetSequence.fromSet(ignoredConcepts).any((it) -> SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(SNodeOperations.getConcept(n)), SNodeOperations.asSConcept(it)));
  }

  @Override
  public boolean hasDataEx() {
    return statistics != null && !(statistics.isEmpty());
  }

  @Nullable
  @Override
  public Object getValue(@NotNull SNode n) {
    List<Object> nodeValues = MapSequence.fromMap(values).get(n);
    if (nodeValues != null && ListSequence.fromList(nodeValues).isNotEmpty()) {
      return ListSequence.fromList(nodeValues).last();
    }
    return null;
  }

  @Nullable
  @Override
  public List<Object> getAllValues(@NotNull SNode n) {
    return MapSequence.fromMap(values).get(n);
  }

  @Override
  public void coverValue(@Nullable SNode interpretedNode, Object evaluatedValue) {
    if (interpretedNode == null) {
      return;
    }
    recordValueStatisticEx(evaluatedValue);

    List<Object> nodeValues = MapSequence.fromMap(values).get(interpretedNode);

    if (nodeValues == null) {
      nodeValues = ListSequence.fromList(new ArrayList<Object>());
      MapSequence.fromMap(values).put(interpretedNode, nodeValues);
    }

    ListSequence.fromList(nodeValues).addElement(evaluatedValue);

    visitNodeEx(interpretedNode);
    visitedConcept(SNodeOperations.getConcept(interpretedNode));
  }

  @Override
  public void recordValueStatisticEx(Object evaluatedValue) {
    if (evaluatedValue instanceof BigInteger) {
      statistics.newValue("integer.min", evaluatedValue);
      statistics.newValue("integer.minusOne", evaluatedValue);
      statistics.newValue("integer.zero", evaluatedValue);
      statistics.newValue("integer.one", evaluatedValue);
      statistics.newValue("integer.max", evaluatedValue);
    }
    if (evaluatedValue instanceof BigDecimal) {
      statistics.newValue("decimal.min", evaluatedValue);
      statistics.newValue("decimal.minusOne", evaluatedValue);
      statistics.newValue("decimal.zero", evaluatedValue);
      statistics.newValue("decimal.one", evaluatedValue);
      statistics.newValue("decimal.max", evaluatedValue);
    }
  }

  private static boolean isEmptyString(String str) {
    return str == null || str.isEmpty();
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept ICanHaveTestCoverage$33 = MetaAdapterFactory.getInterfaceConcept(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x5bb0bdbbedce7ccbL, "com.mbeddr.mpsutil.interpreter.structure.ICanHaveTestCoverage");
    /*package*/ static final SConcept ElementDocumentation$BO = MetaAdapterFactory.getConcept(0xd4280a54f6df4383L, 0xaa41d1b2bffa7eb1L, 0x3588b64556af217cL, "com.mbeddr.core.base.structure.ElementDocumentation");
    /*package*/ static final SInterfaceConcept IEmpty$6_ = MetaAdapterFactory.getInterfaceConcept(0xd4280a54f6df4383L, 0xaa41d1b2bffa7eb1L, 0xe900768cf47dcc3L, "com.mbeddr.core.base.structure.IEmpty");
    /*package*/ static final SInterfaceConcept IExcludeFromCoverage$z4 = MetaAdapterFactory.getInterfaceConcept(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x5bb0bdbbee2b138eL, "com.mbeddr.mpsutil.interpreter.structure.IExcludeFromCoverage");
  }
}
