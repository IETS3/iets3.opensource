package org.iets3.core.expr.base.plugin;

/*Generated by MPS */

import org.iets3.core.expr.base.shared.runtime.SharedInfHelper;
import java.math.RoundingMode;
import org.jetbrains.annotations.NotNull;
import java.math.BigDecimal;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Objects;
import org.iets3.core.expr.base.runtime.runtime.PTF;

public class InfHelper {
  public static final String NEGINF = "-∞";
  public static final String POSINF = "∞";

  /**
   * Default infinite precision corresponds to the decimal digits number of the double-precision
   */
  public static final int INF_PREC = SharedInfHelper.INF_PREC;
  /**
   * Default rounding mode applied when converting decimals with infinite/undefined precision to decimals with INF_PREC
   */
  public static final RoundingMode DEFAULT_ROUNDING = SharedInfHelper.DEFAULT_ROUNDING;


  @NotNull
  public static String negate(@NotNull String value) {
    if (value.equals(NEGINF)) {
      return POSINF;
    }
    if (value.equals(POSINF)) {
      return NEGINF;
    }
    if (value.startsWith("-")) {
      return value.substring(1);
    } else {
      return "-" + value;
    }
  }

  /**
   * 
   * @deprecated Use {@link org.iets3.core.expr.base.plugin.InfHelper#add(String, String) }
   */
  @Deprecated(forRemoval = true)
  public static String add(String v1, String v2, boolean skewLow) {
    return add(v1, v2);
  }
  @NotNull
  public static String add(@NotNull String left, @NotNull String right) throws NumberFormatException {
    if (left.equals(POSINF) || right.equals(POSINF)) {
      return POSINF;
    }
    if (left.equals(NEGINF) || right.equals(NEGINF)) {
      return NEGINF;
    }
    return toPlainString(asBigDecimal(left).add(asBigDecimal(right)));
  }

  /**
   * 
   * @deprecated Use {@link org.iets3.core.expr.base.plugin.InfHelper#sub(String, String) }
   */
  @Deprecated(forRemoval = true)
  public static String sub(String v1, String v2, boolean skewLow) {
    return sub(v1, v2);
  }
  @NotNull
  public static String sub(@NotNull String left, @NotNull String right) throws NumberFormatException {
    if (left.equals(POSINF) || right.equals(NEGINF)) {
      return POSINF;
    }
    if (left.equals(NEGINF) || right.equals(POSINF)) {
      return NEGINF;
    }
    BigDecimal subtract = asBigDecimal(left).subtract(asBigDecimal(right));
    return toPlainString(subtract);
  }

  /**
   * 
   * @deprecated Use {@link org.iets3.core.expr.base.plugin.InfHelper#mul(String, String) }
   */
  @Deprecated(forRemoval = true)
  public static String mul(String v1, String v2, boolean skewLow) {
    return mul(v1, v2);
  }
  @NotNull
  public static String mul(@NotNull String left, @NotNull String right) throws NumberFormatException {
    if (left.equals(POSINF)) {
      if (signum(right) >= 0) {
        return POSINF;
      } else {
        return NEGINF;
      }
    }
    if (left.equals(NEGINF)) {
      if (signum(right) >= 0) {
        return NEGINF;
      } else {
        return POSINF;
      }
    }
    if (right.equals(POSINF)) {
      if (signum(left) >= 0) {
        return POSINF;
      } else {
        return NEGINF;
      }
    }
    if (right.equals(NEGINF)) {
      if (signum(left) >= 0) {
        return NEGINF;
      } else {
        return POSINF;
      }
    }
    return toPlainString(asBigDecimal(left).multiply(asBigDecimal(right)));
  }


  public static int signum(@NotNull String value) throws NumberFormatException {
    if (value.equals(POSINF)) {
      return 1;
    }
    if (value.equals(NEGINF)) {
      return -1;
    }
    BigDecimal bd = asBigDecimal(value);
    return bd.signum();
  }

  /**
   * 
   * @deprecated Use {@link org.iets3.core.expr.base.plugin.InfHelper#div(String, String, RoundingMode) }
   */
  @Deprecated(forRemoval = true)
  public static String div(String v1, String v2, boolean skewLow, RoundingMode roundingMode) {
    return div(v1, v2, roundingMode);
  }
  @NotNull
  public static String div(@NotNull String left, @NotNull String right, @NotNull RoundingMode roundingMode) throws NumberFormatException {
    if (left.equals(POSINF) || right.equals(POSINF)) {
      return POSINF;
    }
    if (left.equals(NEGINF) || right.equals(NEGINF)) {
      return NEGINF;
    }
    BigDecimal v2dec = asBigDecimal(right);
    if (v2dec.compareTo(BigDecimal.ZERO) == 0) {
      if (signum(left) + signum(right) < 0) {
        return NEGINF;
      } else {
        return POSINF;
      }
    }
    return toPlainString(asBigDecimal(left).divide(v2dec, INF_PREC, roundingMode).stripTrailingZeros());
  }



  public static boolean less(@NotNull String left, @NotNull String right) throws NumberFormatException {
    if (left.equals(NEGINF) && right.equals(NEGINF)) {
      return false;
    }
    if (left.equals(POSINF) && right.equals(POSINF)) {
      return false;
    }
    if (left.equals(NEGINF)) {
      return true;
    }
    if (left.equals(POSINF)) {
      return false;
    }
    if (right.equals(POSINF)) {
      return true;
    }
    if (right.equals(NEGINF)) {
      return false;
    }
    return asBigDecimal(left).compareTo(asBigDecimal(right)) < 0;
  }

  public static boolean lessOrEq(@NotNull String left, @NotNull String right) throws NumberFormatException {
    if (left.equals(NEGINF) && right.equals(NEGINF)) {
      return true;
    }
    if (left.equals(POSINF) && right.equals(POSINF)) {
      return true;
    }
    if (left.equals(NEGINF)) {
      return true;
    }
    if (left.equals(POSINF)) {
      return false;
    }
    if (right.equals(POSINF)) {
      return true;
    }
    if (right.equals(NEGINF)) {
      return false;
    }
    return asBigDecimal(left).compareTo(asBigDecimal(right)) <= 0;
  }

  public static boolean greater(@NotNull String left, @NotNull String right) throws NumberFormatException {
    if (left.equals(NEGINF) && right.equals(NEGINF)) {
      return false;
    }
    if (left.equals(POSINF) && right.equals(POSINF)) {
      return false;
    }
    if (right.equals(POSINF)) {
      return false;
    }
    if (left.equals(NEGINF)) {
      return false;
    }
    if (left.equals(POSINF)) {
      return true;
    }
    if (right.equals(NEGINF)) {
      return true;
    }
    return asBigDecimal(left).compareTo(asBigDecimal(right)) > 0;
  }

  public static boolean greaterOrEqual(@NotNull String left, @NotNull String right) throws NumberFormatException {
    if (left.equals(NEGINF) && right.equals(NEGINF)) {
      return true;
    }
    if (left.equals(POSINF) && right.equals(POSINF)) {
      return true;
    }
    if (right.equals(POSINF)) {
      return false;
    }
    if (left.equals(NEGINF)) {
      return false;
    }
    if (left.equals(POSINF)) {
      return true;
    }
    if (right.equals(NEGINF)) {
      return true;
    }
    return asBigDecimal(left).compareTo(asBigDecimal(right)) >= 0;
  }

  public static boolean equals(@NotNull String left, @NotNull String right) throws NumberFormatException {
    if (left.equals(NEGINF) && right.equals(NEGINF)) {
      return true;
    }
    if (left.equals(POSINF) && right.equals(POSINF)) {
      return true;
    }
    if (left.equals(POSINF) || right.equals(POSINF)) {
      return false;
    }
    if (left.equals(NEGINF) || right.equals(NEGINF)) {
      return false;
    }
    return asBigDecimal(left).compareTo(asBigDecimal(right)) == 0;
  }

  @NotNull
  public static String min(@NotNull String left, @NotNull String right) throws NumberFormatException {
    if (left.equals(NEGINF) || right.equals(NEGINF)) {
      return NEGINF;
    }
    if (left.equals(POSINF)) {
      return right;
    }
    if (right.equals(POSINF)) {
      return left;
    }
    return toPlainString(asBigDecimal(left).min(asBigDecimal(right)));
  }

  @NotNull
  public static String min(Iterable<String> values) throws NumberFormatException {
    return Sequence.fromIterable(values).foldLeft(POSINF, (String min, String next) -> (less(next, min) ? next : min));
  }

  @NotNull
  public static String max(Iterable<String> values) throws NumberFormatException {
    return Sequence.fromIterable(values).foldLeft(NEGINF, (String min, String next) -> (greater(next, min) ? next : min));
  }

  public static int maxInt(Iterable<Integer> values) {
    return Sequence.fromIterable(values).foldLeft(0, (Integer max, Integer next) -> (next > max ? next : max));
  }

  @NotNull
  public static String max(@NotNull String left, @NotNull String right) throws NumberFormatException {
    if (left.equals(POSINF) || right.equals(POSINF)) {
      return POSINF;
    }
    if (left.equals(NEGINF)) {
      return right;
    }
    if (right.equals(NEGINF)) {
      return left;
    }
    return toPlainString(asBigDecimal(left).max(asBigDecimal(right)));
  }

  public static boolean isZero(@NotNull String value) {
    if (value.equals(POSINF) || value.equals(NEGINF)) {
      return false;
    }
    return asBigDecimal(value).compareTo(BigDecimal.ZERO) == 0;
  }

  public static int asInt_OrZero(@NotNull String value) {
    try {
      return Integer.valueOf(value).intValue();
    } catch (NumberFormatException nfe) {
      return 0;
    }
  }

  public static boolean isPosInf(@NotNull String value) {
    return Objects.equals(value, POSINF);
  }

  public static boolean isNegInf(@NotNull String value) {
    return Objects.equals(value, NEGINF);
  }

  @NotNull
  public static BigDecimal asBigDecimal(@NotNull String value) throws NumberFormatException {
    switch (value) {
      case POSINF:
        throw new NumberFormatException(POSINF);
      case NEGINF:
        throw new NumberFormatException(POSINF);
      default:
        if (PTF.useCommaInsteadOfDotForDecimals()) {
          value = value.replace(',', '.');
        }
        return new BigDecimal(value);
    }
  }

  @NotNull
  public static String toPlainString(@NotNull BigDecimal value) {
    String result = value.toPlainString();
    if (PTF.useCommaInsteadOfDotForDecimals()) {
      result = result.replace('.', ',');
    }
    return result;
  }
}
