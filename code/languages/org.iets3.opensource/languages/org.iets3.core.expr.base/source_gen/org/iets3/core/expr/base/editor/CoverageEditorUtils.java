package org.iets3.core.expr.base.editor;

/*Generated by MPS */

import java.awt.Color;
import com.intellij.ui.JBColor;
import org.jetbrains.mps.openapi.model.SNode;
import org.iets3.core.expr.base.behavior.IDefaultCoverageAnalyzer;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.mbeddr.mpsutil.interpreter.behavior.ICanHaveTestCoverage__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class CoverageEditorUtils {

  public static Color NOT_COVERED_BG_COLOR = new JBColor(new Color(255, 220, 220), new Color(255, 220, 220));
  public static Color COVERED_AND_NOT_INCLUDED_BG_COLOR = new JBColor(new Color(220, 220, 255), new Color(220, 220, 255));

  public static boolean isCoveredAndNotIncluded(SNode node) {
    if (IDefaultCoverageAnalyzer.isNodeCovered(node)) {
      SNode coverageWithScopeAncestor = SNodeOperations.getNodeAncestor(node, CONCEPTS.ICanHaveTestCoverage$33, false, false);
      if ((coverageWithScopeAncestor != null)) {
        int indexOfCoverageWithScopeAncestor = ListSequence.fromList(SNodeOperations.getNodeAncestors(node, null, true)).indexOf(coverageWithScopeAncestor);
        final Iterable<SNode> includedForCoverage = ICanHaveTestCoverage__BehaviorDescriptor.getChildrenForCoverage_id5IKJrJHNCE8.invoke(coverageWithScopeAncestor);
        // at least one ancestor is not included to the explicit coverage scope
        boolean isNotIncludedInCoverage = ListSequence.fromList(SNodeOperations.getNodeAncestors(node, null, true)).headListSequence(indexOfCoverageWithScopeAncestor).all((it) -> !(Sequence.fromIterable(includedForCoverage).contains(it)));
        if (isNotIncludedInCoverage) {
          return true;
        }
      }
    }
    return false;
  }

  public static boolean isNotCoveredAndHasNotCoveredAncestors(SNode node) {
    return IDefaultCoverageAnalyzer.isNodeNotCovered(node) && ListSequence.fromList(SNodeOperations.getNodeAncestors(node, null, false)).any((it) -> IDefaultCoverageAnalyzer.isNodeNotCovered(it));
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept ICanHaveTestCoverage$33 = MetaAdapterFactory.getInterfaceConcept(0x47f075a6558e4640L, 0xa6067ce0236c8023L, 0x5bb0bdbbedce7ccbL, "com.mbeddr.mpsutil.interpreter.structure.ICanHaveTestCoverage");
  }
}
