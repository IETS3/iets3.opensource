package org.iets3.core.expr.base.behavior;

/*Generated by MPS */

import java.awt.Color;
import com.intellij.ui.JBColor;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;
import jetbrains.mps.lang.structure.behavior.AbstractConceptDeclaration__BehaviorDescriptor;
import jetbrains.mps.lang.structure.behavior.LinkDeclaration__BehaviorDescriptor;
import jetbrains.mps.lang.structure.behavior.PropertyDeclaration__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.Collections;
import java.util.Map;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import org.jetbrains.mps.openapi.language.SLanguage;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;

public class StructuralCoverageAnalyzer {

  public static final String COVERED = "Covered.";
  public static final String MISSING = "Missing.";
  public static final String PARTIAL = "Partial.";

  public static final Color COVERED_COLOR = new JBColor(new Color(23, 191, 0), new Color(23, 191, 0));
  public static final Color MISSING_COLOR = JBColor.red;
  public static final Color PARTIAL_COLOR = new JBColor(new Color(237, 134, 0), new Color(237, 134, 0));


  public static class ExpressionStat {

    private SNode subject;

    public ExpressionStat(SNode subject) {
      this.subject = subject;
    }

    private SNode root() {
      return ListSequence.fromList(SNodeOperations.getNodeAncestors(subject, CONCEPTS.Expression$D_, true)).last();
    }

    public int size() {
      return ListSequence.fromList(SNodeOperations.getNodeDescendants(root(), null, true, new SAbstractConcept[]{})).count();
    }

    public int depth() {
      return ListSequence.fromList(SNodeOperations.getNodeAncestors(subject, CONCEPTS.Expression$D_, true)).count();
    }

    public int heterogeneity() {
      return ListSequence.fromList(SNodeOperations.getNodeDescendants(root(), null, true, new SAbstractConcept[]{})).select((it) -> SNodeOperations.getConcept(it)).distinct().count();
    }

    public int metric() {
      return heterogeneity() * depth();
    }

    @Override
    public String toString() {
      return "metric: " + metric();
    }

  }

  public static class StructureData {

    private Set<SNode> visitedLinks = SetSequence.fromSet(new HashSet<SNode>());
    private Set<SNode> visitedProperties = SetSequence.fromSet(new HashSet<SNode>());
    private List<ExpressionStat> occurences = ListSequence.fromList(new ArrayList<ExpressionStat>());
    private SAbstractConcept concept;
    private List<SAbstractConcept> allRelevantConcepts;
    private boolean trackProperties;

    public StructureData(SAbstractConcept ccc, List<SAbstractConcept> allRelevantConcepts, boolean trackProperties) {
      concept = ccc;
      this.allRelevantConcepts = allRelevantConcepts;
      this.trackProperties = trackProperties;
    }

    public SAbstractConcept concept() {
      return this.concept;
    }

    public Iterable<SNode> allLinks() {
      return ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getLinkDeclarations_idhEwILKK.invoke(SNodeOperations.asNode(this.concept))).where((it) -> ListSequence.fromList(allRelevantConcepts).contains(SNodeOperations.asSConcept(LinkDeclaration__BehaviorDescriptor.getConceptDeclaration_id7jb4LXpbWaP.invoke(it))));
    }

    public Iterable<SNode> allProperties() {
      return ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getPropertyDeclarations_idhEwILLM.invoke(SNodeOperations.asNode(this.concept))).where((it) -> ListSequence.fromList(allRelevantConcepts).contains(SNodeOperations.asSConcept(PropertyDeclaration__BehaviorDescriptor.getConceptDeclaration_id2OF3rgRewqT.invoke(it))));
    }

    public void foundLinkInstance(SNode link) {
      SetSequence.fromSet(this.visitedLinks).addElement(link);
    }

    public void foundPropertyInstance(SNode prop) {
      SetSequence.fromSet(this.visitedProperties).addElement(prop);
    }

    public boolean isComplete() {
      if (!(anInstanceHasBeenFound())) {
        return false;
      }
      if (Sequence.fromIterable(unvisitedLinks()).isNotEmpty()) {
        return false;
      }
      if (Sequence.fromIterable(unvisitedProperties()).isNotEmpty()) {
        return false;
      }

      return true;
    }

    private boolean anInstanceHasBeenFound() {
      return ListSequence.fromList(occurences).isNotEmpty();
    }

    public String status() {
      if (!(anInstanceHasBeenFound())) {
        return MISSING;
      }
      if (Sequence.fromIterable(unvisitedLinks()).isEmpty() && Sequence.fromIterable(unvisitedProperties()).isEmpty()) {
        return COVERED + " " + statsString();
      }
      return PARTIAL + " Missing: " + Sequence.fromIterable(unvisitedProperties()).select((it) -> SPropertyOperations.getString(it, PROPS.name$MnvL)).concat(Sequence.fromIterable(unvisitedLinks()).select((it) -> SPropertyOperations.getString(it, PROPS.name$MnvL)));
    }

    public String statsString() {
      return "N=" + testCount() + ", V=" + this.testVolume() + " H=" + this.minimumHeterogeneity() + ".." + this.maximumHeterogeneity();
    }

    public int testCount() {
      return ListSequence.fromList(this.occurences).count();
    }


    public Color color() {
      if (this.visitedLinks == null) {
        return (anInstanceHasBeenFound() ? COVERED_COLOR : MISSING_COLOR);
      }
      return PARTIAL_COLOR;
    }

    public void foundInstance(SNode instance) {
      ExpressionStat stat = new ExpressionStat(instance);
      ListSequence.fromList(this.occurences).addElement(stat);
    }

    public Iterable<SNode> unvisitedLinks() {
      return Sequence.fromIterable(allLinks()).where((it) -> !(SetSequence.fromSet(StructureData.this.visitedLinks).contains(it)));
    }

    public Iterable<SNode> unvisitedProperties() {
      if (!(trackProperties)) {
        return Sequence.fromIterable(Collections.<SNode>emptyList());
      }
      return Sequence.fromIterable(allProperties()).where((it) -> !(SetSequence.fromSet(StructureData.this.visitedProperties).contains(it)));
    }

    public int minimumHeterogeneity() {
      if (ListSequence.fromList(this.occurences).isEmpty()) {
        return -1;
      }
      return ListSequence.fromList(this.occurences).sort((it) -> it.heterogeneity(), true).first().heterogeneity();
    }

    public int maximumHeterogeneity() {
      if (ListSequence.fromList(this.occurences).isEmpty()) {
        return -1;
      }
      return ListSequence.fromList(this.occurences).sort((it) -> it.heterogeneity(), true).last().heterogeneity();
    }

    public int testVolume() {
      int vol = 0;
      for (ExpressionStat oc : ListSequence.fromList(this.occurences)) {
        vol += oc.metric();
      }
      return vol;
    }


    @Override
    public String toString() {
      StringBuffer sb = new StringBuffer();
      sb.append(this.concept.getName());
      if (!(anInstanceHasBeenFound())) {
        sb.append(" not visited.");
      } else if (!(this.isComplete())) {
        sb.append(" missing " + Sequence.fromIterable(unvisitedProperties()).concat(Sequence.fromIterable(unvisitedLinks())));
      }
      return sb.toString();
    }


  }



  private Map<SAbstractConcept, StructureData> visitedConcepts = MapSequence.fromMap(new HashMap<SAbstractConcept, StructureData>());
  private Set<SLanguage> registeredLanguages = SetSequence.fromSet(new HashSet<SLanguage>());
  private Set<SAbstractConcept> ignoredConcepts = SetSequence.fromSet(new HashSet<SAbstractConcept>());
  private boolean trackProperties;

  public void foundConceptInstance(SAbstractConcept ccc, SNode instance) {
    getData(ccc).foundInstance(instance);
  }

  private StructureData getData(SAbstractConcept ccc) {
    StructureData data = MapSequence.fromMap(visitedConcepts).get(ccc);
    if (data == null) {
      data = new StructureData(ccc, getAllRelevantConcepts(), trackProperties);
      MapSequence.fromMap(visitedConcepts).put(ccc, data);
    }
    return data;
  }

  public void foundLinkInstance(SAbstractConcept ccc, SNode link) {
    StructureData data = getData(ccc);
    data.foundLinkInstance(link);
  }

  public void foundPropertyInstance(SAbstractConcept ccc, SNode link) {
    StructureData data = getData(ccc);
    data.foundPropertyInstance(link);
  }


  public int ratio() {
    return 100 - ((int) (((float) Sequence.fromIterable(missingConceptsOrIncomplete()).count()) / ((float) Sequence.fromIterable(allConceptsStatus()).count()) * 100));
  }

  public List<SAbstractConcept> allResultsConcepts() {
    return ListSequence.fromList(getAllRelevantConcepts()).removeWhere((it) -> it.isAbstract() || it instanceof SInterfaceConcept);
  }

  public List<SAbstractConcept> getAllRelevantConcepts() {
    return SetSequence.fromSet(registeredLanguages).translate((it) -> ((Iterable<SAbstractConcept>) it.getConcepts())).where((final SAbstractConcept c) -> SetSequence.fromSet(ignoredConcepts).all((it) -> !(c.isSubConceptOf(it)))).toList();
  }

  public Iterable<StructureData> missingConceptsOrIncomplete() {
    return Sequence.fromIterable(allConceptsStatus()).where((it) -> !(it.isComplete()));
  }

  public Iterable<StructureData> allConceptsStatus() {
    final List<SAbstractConcept> allRelevantConcepts = getAllRelevantConcepts();
    return ListSequence.fromList(allResultsConcepts()).select((it) -> {
      StructureData ccc = MapSequence.fromMap(visitedConcepts).get(it);
      if (ccc == null) {
        MapSequence.fromMap(visitedConcepts).put(it, ccc = new StructureData(it, allRelevantConcepts, trackProperties));
      }
      return ccc;
    });
  }


  public void registerLanguage(SLanguage l) {
    SetSequence.fromSet(registeredLanguages).addElement(l);
  }

  public void registerIgnoredConcept(SAbstractConcept c) {
    SetSequence.fromSet(ignoredConcepts).addElement(c);
  }

  public void setTrackProperties(boolean trackProperties) {
    this.trackProperties = trackProperties;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Expression$D_ = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x670d5e92f854a047L, "org.iets3.core.expr.base.structure.Expression");
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }
}
