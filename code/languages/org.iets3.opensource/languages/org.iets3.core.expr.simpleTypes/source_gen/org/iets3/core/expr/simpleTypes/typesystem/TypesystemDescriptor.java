package org.iets3.core.expr.simpleTypes.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.BaseHelginsDescriptor;
import jetbrains.mps.lang.typesystem.runtime.InferenceRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.NonTypesystemRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.SubtypingRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.ComparisonRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.InequationReplacementRule_Runtime;
import jetbrains.mps.lang.typesystem.runtime.OverloadedOperationsTypesProvider;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.iets3.core.expr.simpleTypes.behavior.NumberType__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.iets3.core.expr.base.plugin.InfHelper;
import jetbrains.mps.typesystem.inference.SubtypingManager;
import org.iets3.core.expr.base.behavior.Type__BehaviorDescriptor;
import jetbrains.mps.errors.IRuleConflictWarningProducer;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.iets3.core.expr.base.runtime.runtime.PTF;
import jetbrains.mps.typesystem.inference.TypeChecker;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import java.math.RoundingMode;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class TypesystemDescriptor extends BaseHelginsDescriptor {
  public TypesystemDescriptor() {
    {
      InferenceRule_Runtime inferenceRule = new typeof_BooleanLiteral_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_BoundsExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_ConvertPrecisionNumberExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_InterpolExprWord_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_LimitExpressionExpression_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_NumberLiteral_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_OtherwiseLiteral_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_StringContainsTarget_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_StringEndsWithTarget_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_StringInterpolationExpr_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_StringLengthTarget_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_StringLiteral_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_StringStartsWithTarget_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_StringToIntTarget_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      InferenceRule_Runtime inferenceRule = new typeof_ToleranceExpr_InferenceRule();
      this.myInferenceRules.add(inferenceRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_ConvertPrecisionNumberExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_LimitExpressionExpression_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_NumberType_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      NonTypesystemRule_Runtime nonTypesystemRule = new check_OtherwiseLiteral_NonTypesystemRule();
      this.myNonTypesystemRules.add(nonTypesystemRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new superTypeOf_StringtypeWithConstraint_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new supertypeOf_IntegerType_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      SubtypingRule_Runtime subtypingRule = new supertypeOf_NumberTypeyx_SubtypingRule();
      this.mySubtypingRules.add(subtypingRule);
    }
    {
      ComparisonRule_Runtime comparisonRule = new compareNumberTypesAgain_ComparisonRule();
      this.myComparisonRules.add(comparisonRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new checkStringConstraint_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new replaceNumberTypes_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new replaceSomeWithBaseType_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new stringComparableWithstringTypeWithConstraint_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    {
      InequationReplacementRule_Runtime eliminationRule = new stringTypeWithConstraintComparableWithStringType_InequationReplacementRule();
      this.myInequationReplacementRules.add(eliminationRule);
    }
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_b(CONCEPTS.UnaryMinusExpression$Gz));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_b_0(CONCEPTS.MinusExpression$6z));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_c(CONCEPTS.MulExpression$iC));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_d(CONCEPTS.DivExpression$us));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a(CONCEPTS.BinaryLogicalExpression$W5));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a_0(CONCEPTS.PlusExpression$mx));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_b_1(CONCEPTS.BinaryComparisonExpression$7z));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_c_0(CONCEPTS.BinaryEqualityExpression$vt));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_d_0(CONCEPTS.BinaryEqualityExpression$vt));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_e(CONCEPTS.BinaryEqualityExpression$vt));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a_1(CONCEPTS.PlusExpression$mx));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_b_2(CONCEPTS.PlusExpression$mx));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_d_1(CONCEPTS.PlusExpression$mx));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_c_1(CONCEPTS.PlusExpression$mx));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_e_0(CONCEPTS.PlusExpression$mx));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_e_1(CONCEPTS.ModExpression$9c));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_f(CONCEPTS.ToleranceExpr$oO));
    this.myOverloadedOperationsTypesProviders.add(new CustomOverloadedOperationsTypesProvider_a_2(CONCEPTS.LogicalNotExpression$QD));
  }
  public static class CustomOverloadedOperationsTypesProvider_b extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_b(SAbstractConcept concept) {
      this.myLeftOperandType = createRealType_3ist9o_a0a0a1();
      this.myRightOperandType = createBaseConcept_3ist9o_a0b0a1();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)";
      this.myRuleNodeId = "3729977973605472502";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      if (!(SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.NumberType$n))) {
        return leftOperandType;
      }
      SNode nt = SNodeOperations.copyNode(SNodeOperations.cast(leftOperandType, CONCEPTS.NumberType$n));
      if ((boolean) NumberType__BehaviorDescriptor.isInfinity_id6NHlpK$DFV5.invoke(nt)) {
        return leftOperandType;
      }
      SPropertyOperations.assign(SLinkOperations.getTarget(nt, LINKS.range$RnOa), PROPS.min$7OOG, InfHelper.negate(SPropertyOperations.getString(SLinkOperations.getTarget(nt, LINKS.range$RnOa), PROPS.min$7OOG)));
      SPropertyOperations.assign(SLinkOperations.getTarget(nt, LINKS.range$RnOa), PROPS.max$7P3H, InfHelper.negate(SPropertyOperations.getString(SLinkOperations.getTarget(nt, LINKS.range$RnOa), PROPS.max$7P3H)));
      return nt;
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(leftOperandType, CONCEPTS.Type$WK));
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createRealType_3ist9o_a0a0a1() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
    private static SNode createBaseConcept_3ist9o_a0b0a1() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BaseConcept$gP);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_b_0 extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_b_0(SAbstractConcept concept) {
      this.myLeftOperandType = createRealType_3ist9o_a0a0a2();
      this.myRightOperandType = createRealType_3ist9o_a0b0a2();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)";
      this.myRuleNodeId = "3729977973607592751";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.NumberType$n) && SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.NumberType$n)) {
        SNode left = SNodeOperations.cast(leftOperandType, CONCEPTS.NumberType$n);
        SNode right = SNodeOperations.cast(rightOperandType, CONCEPTS.NumberType$n);
        SNode res = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x7211e50064d40ea8L, "org.iets3.core.expr.simpleTypes.structure.NumberType"));
        NumberType__BehaviorDescriptor.setRange_id6NHlpK$OKdB.invoke(res, InfHelper.sub(NumberType__BehaviorDescriptor.lowerBound_id19PglA20zCc.invoke(left), NumberType__BehaviorDescriptor.upperBound_id19PglA20_Su.invoke(right)), InfHelper.sub(NumberType__BehaviorDescriptor.upperBound_id19PglA20_Su.invoke(left), NumberType__BehaviorDescriptor.lowerBound_id19PglA20zCc.invoke(right)));
        NumberType__BehaviorDescriptor.setMaxPrecision_id7Wa2sv3Ko90.invoke(res, left, right);
        return res;
      }
      return PTF.computeSupertype(leftOperandType, rightOperandType, true, TypeChecker.getInstance().getSubtypingManager());

    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(leftOperandType, CONCEPTS.Type$WK)) && (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(rightOperandType, CONCEPTS.Type$WK));
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createRealType_3ist9o_a0a0a2() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
    private static SNode createRealType_3ist9o_a0b0a2() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_c extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_c(SAbstractConcept concept) {
      this.myLeftOperandType = createRealType_3ist9o_a0a0a3();
      this.myRightOperandType = createRealType_3ist9o_a0b0a3();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)";
      this.myRuleNodeId = "3729977973607621087";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.NumberType$n) && SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.NumberType$n)) {
        SNode left = SNodeOperations.cast(leftOperandType, CONCEPTS.NumberType$n);
        SNode right = SNodeOperations.cast(rightOperandType, CONCEPTS.NumberType$n);
        String ll = NumberType__BehaviorDescriptor.lowerBound_id19PglA20zCc.invoke(left);
        String rl = NumberType__BehaviorDescriptor.lowerBound_id19PglA20zCc.invoke(right);
        String lu = NumberType__BehaviorDescriptor.upperBound_id19PglA20_Su.invoke(left);
        String ru = NumberType__BehaviorDescriptor.upperBound_id19PglA20_Su.invoke(right);
        List<String> values = ListSequence.fromList(new ArrayList<String>());
        ListSequence.fromList(values).addElement(InfHelper.mul(ll, rl));
        ListSequence.fromList(values).addElement(InfHelper.mul(ll, ru));
        ListSequence.fromList(values).addElement(InfHelper.mul(lu, rl));
        ListSequence.fromList(values).addElement(InfHelper.mul(lu, ru));
        String min = InfHelper.min(values);
        String max = InfHelper.max(values);
        SNode res = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x7211e50064d40ea8L, "org.iets3.core.expr.simpleTypes.structure.NumberType"));
        NumberType__BehaviorDescriptor.setRange_id6NHlpK$OKdB.invoke(res, min, max);
        NumberType__BehaviorDescriptor.setSumPrecision_id7Wa2sv3MfsR.invoke(res, left, right);
        return res;
      }
      return PTF.computeSupertype(leftOperandType, rightOperandType, true, TypeChecker.getInstance().getSubtypingManager());

    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(leftOperandType, CONCEPTS.Type$WK)) && (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(rightOperandType, CONCEPTS.Type$WK));
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createRealType_3ist9o_a0a0a3() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
    private static SNode createRealType_3ist9o_a0b0a3() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_d extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_d(SAbstractConcept concept) {
      this.myLeftOperandType = createRealType_3ist9o_a0a0a4();
      this.myRightOperandType = createRealType_3ist9o_a0b0a4();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)";
      this.myRuleNodeId = "3729977973607624858";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.NumberType$n) && SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.NumberType$n)) {
        SNode left = SNodeOperations.cast(leftOperandType, CONCEPTS.NumberType$n);
        SNode right = SNodeOperations.cast(rightOperandType, CONCEPTS.NumberType$n);
        String ll = NumberType__BehaviorDescriptor.lowerBound_id19PglA20zCc.invoke(left);
        String rl = NumberType__BehaviorDescriptor.lowerBound_id19PglA20zCc.invoke(right);
        String lu = NumberType__BehaviorDescriptor.upperBound_id19PglA20_Su.invoke(left);
        String ru = NumberType__BehaviorDescriptor.upperBound_id19PglA20_Su.invoke(right);
        List<String> values = ListSequence.fromList(new ArrayList<String>());
        // TODO: add proper handling for ranges including zero limit (possibly using POSINF/NEGINF?)
        try {
          ListSequence.fromList(values).addElement(InfHelper.div(ll, rl, RoundingMode.CEILING));
          ListSequence.fromList(values).addElement(InfHelper.div(ll, rl, RoundingMode.FLOOR));
          ListSequence.fromList(values).addElement(InfHelper.div(ll, ru, RoundingMode.CEILING));
          ListSequence.fromList(values).addElement(InfHelper.div(ll, ru, RoundingMode.FLOOR));
          ListSequence.fromList(values).addElement(InfHelper.div(lu, rl, RoundingMode.CEILING));
          ListSequence.fromList(values).addElement(InfHelper.div(lu, rl, RoundingMode.FLOOR));
          ListSequence.fromList(values).addElement(InfHelper.div(lu, ru, RoundingMode.CEILING));
          ListSequence.fromList(values).addElement(InfHelper.div(lu, ru, RoundingMode.FLOOR));
        } catch (NumberFormatException e) {
        }
        String min = InfHelper.min(values);
        String max = InfHelper.max(values);
        SNode res = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x7211e50064d40ea8L, "org.iets3.core.expr.simpleTypes.structure.NumberType"));
        NumberType__BehaviorDescriptor.setRange_id6NHlpK$OKdB.invoke(res, min, max);
        NumberType__BehaviorDescriptor.setInfinitePrecision_id7Wa2sv3G6bK.invoke(res);
        return res;
      }
      return createRealType_3ist9o_a1a1e();
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(leftOperandType, CONCEPTS.Type$WK)) && (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(rightOperandType, CONCEPTS.Type$WK));
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createRealType_3ist9o_a0a0a4() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
    private static SNode createRealType_3ist9o_a0b0a4() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
    private static SNode createRealType_3ist9o_a1a1e() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_a extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_a(SAbstractConcept concept) {
      this.myLeftOperandType = createBooleanType_3ist9o_a0a0a5();
      this.myRightOperandType = createBooleanType_3ist9o_a0b0a5();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)";
      this.myRuleNodeId = "5115872837157383129";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return createBooleanType_3ist9o_a0a1f();
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(leftOperandType, CONCEPTS.Type$WK)) && (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(rightOperandType, CONCEPTS.Type$WK));
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createBooleanType_3ist9o_a0a0a5() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BooleanType$eL);
      return n0.getResult();
    }
    private static SNode createBooleanType_3ist9o_a0b0a5() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BooleanType$eL);
      return n0.getResult();
    }
    private static SNode createBooleanType_3ist9o_a0a1f() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BooleanType$eL);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_a_0 extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_a_0(SAbstractConcept concept) {
      this.myLeftOperandType = createRealType_3ist9o_a0a0a6();
      this.myRightOperandType = createRealType_3ist9o_a0b0a6();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)";
      this.myRuleNodeId = "5115872837157481442";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.NumberType$n) && SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.NumberType$n)) {
        SNode left = SNodeOperations.cast(leftOperandType, CONCEPTS.NumberType$n);
        SNode right = SNodeOperations.cast(rightOperandType, CONCEPTS.NumberType$n);
        SNode res = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x7211e50064d40ea8L, "org.iets3.core.expr.simpleTypes.structure.NumberType"));
        try {
          NumberType__BehaviorDescriptor.setRange_id6NHlpK$OKdB.invoke(res, InfHelper.add(NumberType__BehaviorDescriptor.lowerBound_id19PglA20zCc.invoke(left), NumberType__BehaviorDescriptor.lowerBound_id19PglA20zCc.invoke(right)), InfHelper.add(NumberType__BehaviorDescriptor.upperBound_id19PglA20_Su.invoke(left), NumberType__BehaviorDescriptor.upperBound_id19PglA20_Su.invoke(right)));
        } catch (NumberFormatException e) {
        }
        NumberType__BehaviorDescriptor.setMaxPrecision_id7Wa2sv3Ko90.invoke(res, left, right);
        return res;
      }
      return PTF.computeSupertype(leftOperandType, rightOperandType, true, TypeChecker.getInstance().getSubtypingManager());
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(leftOperandType, CONCEPTS.Type$WK)) && (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(rightOperandType, CONCEPTS.Type$WK));
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createRealType_3ist9o_a0a0a6() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
    private static SNode createRealType_3ist9o_a0b0a6() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_b_1 extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_b_1(SAbstractConcept concept) {
      this.myLeftOperandType = createRealType_3ist9o_a0a0a7();
      this.myRightOperandType = createRealType_3ist9o_a0b0a7();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)";
      this.myRuleNodeId = "553080662195561846";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return createBooleanType_3ist9o_a0a1h();
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(leftOperandType, CONCEPTS.Type$WK)) && (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(rightOperandType, CONCEPTS.Type$WK));
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createRealType_3ist9o_a0a0a7() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
    private static SNode createRealType_3ist9o_a0b0a7() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
    private static SNode createBooleanType_3ist9o_a0a1h() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BooleanType$eL);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_c_0 extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_c_0(SAbstractConcept concept) {
      this.myLeftOperandType = createRealType_3ist9o_a0a0a8();
      this.myRightOperandType = createRealType_3ist9o_a0b0a8();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)";
      this.myRuleNodeId = "553080662195562159";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return createBooleanType_3ist9o_a0a1i();
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(leftOperandType, CONCEPTS.Type$WK)) && (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(rightOperandType, CONCEPTS.Type$WK));
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createRealType_3ist9o_a0a0a8() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
    private static SNode createRealType_3ist9o_a0b0a8() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
    private static SNode createBooleanType_3ist9o_a0a1i() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BooleanType$eL);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_d_0 extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_d_0(SAbstractConcept concept) {
      this.myLeftOperandType = createBooleanType_3ist9o_a0a0a9();
      this.myRightOperandType = createBooleanType_3ist9o_a0b0a9();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)";
      this.myRuleNodeId = "553080662195562355";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return createBooleanType_3ist9o_a0a1j();
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(leftOperandType, CONCEPTS.Type$WK)) && (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(rightOperandType, CONCEPTS.Type$WK));
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createBooleanType_3ist9o_a0a0a9() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BooleanType$eL);
      return n0.getResult();
    }
    private static SNode createBooleanType_3ist9o_a0b0a9() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BooleanType$eL);
      return n0.getResult();
    }
    private static SNode createBooleanType_3ist9o_a0a1j() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BooleanType$eL);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_e extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_e(SAbstractConcept concept) {
      this.myLeftOperandType = createStringType_3ist9o_a0a0a01();
      this.myRightOperandType = createStringType_3ist9o_a0b0a01();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)";
      this.myRuleNodeId = "553080662195601397";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return createBooleanType_3ist9o_a0a1k();
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(leftOperandType, CONCEPTS.Type$WK)) && (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(rightOperandType, CONCEPTS.Type$WK));
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createStringType_3ist9o_a0a0a01() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.StringType$B3);
      return n0.getResult();
    }
    private static SNode createStringType_3ist9o_a0b0a01() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.StringType$B3);
      return n0.getResult();
    }
    private static SNode createBooleanType_3ist9o_a0a1k() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BooleanType$eL);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_a_1 extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_a_1(SAbstractConcept concept) {
      this.myLeftOperandType = createStringType_3ist9o_a0a0a11();
      this.myRightOperandType = createStringType_3ist9o_a0b0a11();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)";
      this.myRuleNodeId = "5764023819381570258";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return createStringType_3ist9o_a0a1l();
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(leftOperandType, CONCEPTS.Type$WK)) && (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(rightOperandType, CONCEPTS.Type$WK));
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createStringType_3ist9o_a0a0a11() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.StringType$B3);
      return n0.getResult();
    }
    private static SNode createStringType_3ist9o_a0b0a11() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.StringType$B3);
      return n0.getResult();
    }
    private static SNode createStringType_3ist9o_a0a1l() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.StringType$B3);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_b_2 extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_b_2(SAbstractConcept concept) {
      this.myLeftOperandType = createRealType_3ist9o_a0a0a21();
      this.myRightOperandType = createStringType_3ist9o_a0b0a21();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)";
      this.myRuleNodeId = "5764023819381571871";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return createStringType_3ist9o_a0a1m();
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(leftOperandType, CONCEPTS.Type$WK)) && (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(rightOperandType, CONCEPTS.Type$WK));
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createRealType_3ist9o_a0a0a21() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
    private static SNode createStringType_3ist9o_a0b0a21() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.StringType$B3);
      return n0.getResult();
    }
    private static SNode createStringType_3ist9o_a0a1m() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.StringType$B3);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_d_1 extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_d_1(SAbstractConcept concept) {
      this.myLeftOperandType = createStringType_3ist9o_a0a0a31();
      this.myRightOperandType = createBooleanType_3ist9o_a0b0a31();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)";
      this.myRuleNodeId = "5764023819381574192";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return createStringType_3ist9o_a0a1n();
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(leftOperandType, CONCEPTS.Type$WK)) && (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(rightOperandType, CONCEPTS.Type$WK));
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createStringType_3ist9o_a0a0a31() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.StringType$B3);
      return n0.getResult();
    }
    private static SNode createBooleanType_3ist9o_a0b0a31() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BooleanType$eL);
      return n0.getResult();
    }
    private static SNode createStringType_3ist9o_a0a1n() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.StringType$B3);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_c_1 extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_c_1(SAbstractConcept concept) {
      this.myLeftOperandType = createStringType_3ist9o_a0a0a41();
      this.myRightOperandType = createRealType_3ist9o_a0b0a41();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)";
      this.myRuleNodeId = "5764023819383190566";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return createStringType_3ist9o_a0a1o();
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(leftOperandType, CONCEPTS.Type$WK)) && (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(rightOperandType, CONCEPTS.Type$WK));
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createStringType_3ist9o_a0a0a41() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.StringType$B3);
      return n0.getResult();
    }
    private static SNode createRealType_3ist9o_a0b0a41() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
    private static SNode createStringType_3ist9o_a0a1o() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.StringType$B3);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_e_0 extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_e_0(SAbstractConcept concept) {
      this.myLeftOperandType = createBooleanType_3ist9o_a0a0a51();
      this.myRightOperandType = createStringType_3ist9o_a0b0a51();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)";
      this.myRuleNodeId = "5764023819383194280";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return createStringType_3ist9o_a0a1p();
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(leftOperandType, CONCEPTS.Type$WK)) && (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(rightOperandType, CONCEPTS.Type$WK));
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createBooleanType_3ist9o_a0a0a51() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BooleanType$eL);
      return n0.getResult();
    }
    private static SNode createStringType_3ist9o_a0b0a51() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.StringType$B3);
      return n0.getResult();
    }
    private static SNode createStringType_3ist9o_a0a1p() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.StringType$B3);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_e_1 extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_e_1(SAbstractConcept concept) {
      this.myLeftOperandType = createRealType_3ist9o_a0a0a61();
      this.myRightOperandType = createRealType_3ist9o_a0b0a61();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)";
      this.myRuleNodeId = "6044555027809920650";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      if (SNodeOperations.isInstanceOf(leftOperandType, CONCEPTS.NumberType$n) && SNodeOperations.isInstanceOf(rightOperandType, CONCEPTS.NumberType$n)) {
        SNode left = SNodeOperations.cast(leftOperandType, CONCEPTS.NumberType$n);
        SNode right = SNodeOperations.cast(rightOperandType, CONCEPTS.NumberType$n);
        String lu = NumberType__BehaviorDescriptor.upperBound_id19PglA20_Su.invoke(left);
        String ru = NumberType__BehaviorDescriptor.upperBound_id19PglA20_Su.invoke(right);
        SNode res = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x7211e50064d40ea8L, "org.iets3.core.expr.simpleTypes.structure.NumberType"));
        NumberType__BehaviorDescriptor.setRange_id6NHlpK$OKdB.invoke(res, "0", InfHelper.min(lu, ru));
        NumberType__BehaviorDescriptor.setPrecision_id19PglA21KtA.invoke(res, ((int) 0));
        return res;
      }
      return PTF.computeSupertype(leftOperandType, rightOperandType, true, TypeChecker.getInstance().getSubtypingManager());

    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(leftOperandType, CONCEPTS.Type$WK)) && (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(rightOperandType, CONCEPTS.Type$WK)) && (int) NumberType__BehaviorDescriptor.precision_id19PglA20ASE.invoke(SNodeOperations.cast(leftOperandType, CONCEPTS.NumberType$n)) == 0 && (int) NumberType__BehaviorDescriptor.precision_id19PglA20ASE.invoke(SNodeOperations.cast(rightOperandType, CONCEPTS.NumberType$n)) == 0;
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createRealType_3ist9o_a0a0a61() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
    private static SNode createRealType_3ist9o_a0b0a61() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_f extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_f(SAbstractConcept concept) {
      this.myLeftOperandType = createRealType_3ist9o_a0a0a71();
      this.myRightOperandType = createRealType_3ist9o_a0b0a71();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)";
      this.myRuleNodeId = "6723201605638978815";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return createRealType_3ist9o_a0a1r();
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createRealType_3ist9o_a0a0a71() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
    private static SNode createRealType_3ist9o_a0b0a71() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
    private static SNode createRealType_3ist9o_a0a1r() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
      return n0.getResult();
    }
  }
  public static class CustomOverloadedOperationsTypesProvider_a_2 extends OverloadedOperationsTypesProvider {
    public CustomOverloadedOperationsTypesProvider_a_2(SAbstractConcept concept) {
      this.myLeftOperandType = createBooleanType_3ist9o_a0a0a81();
      this.myRightOperandType = createBaseConcept_3ist9o_a0b0a81();
      this.myOperationConcept = concept;
      this.myLeftTypeIsExact = false;
      this.myRightTypeIsExact = false;
      this.myRightIsStrong = false;
      this.myLeftIsStrong = false;
      this.myRuleModelId = "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)";
      this.myRuleNodeId = "6776997824608165735";
    }
    public SNode getOperationType(SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return createBooleanType_3ist9o_a0a1s();
    }
    public boolean isApplicable(SubtypingManager subtypingManager, SNode operation, SNode leftOperandType, SNode rightOperandType) {
      return (boolean) Type__BehaviorDescriptor.notRequiresSpecialCapability_id7McqtXG$h_u.invoke(SNodeOperations.cast(leftOperandType, CONCEPTS.Type$WK));
    }
    @Override
    public void reportConflict(IRuleConflictWarningProducer producer) {
      producer.produceWarning(myRuleModelId, myRuleNodeId);
    }
    private static SNode createBooleanType_3ist9o_a0a0a81() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BooleanType$eL);
      return n0.getResult();
    }
    private static SNode createBaseConcept_3ist9o_a0b0a81() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BaseConcept$gP);
      return n0.getResult();
    }
    private static SNode createBooleanType_3ist9o_a0a1s() {
      SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.BooleanType$eL);
      return n0.getResult();
    }
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept UnaryMinusExpression$Gz = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cdddbbL, "org.iets3.core.expr.base.structure.UnaryMinusExpression");
    /*package*/ static final SConcept MinusExpression$6z = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cac5a5L, "org.iets3.core.expr.base.structure.MinusExpression");
    /*package*/ static final SConcept MulExpression$iC = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86c9a56fL, "org.iets3.core.expr.base.structure.MulExpression");
    /*package*/ static final SConcept DivExpression$us = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cac63bL, "org.iets3.core.expr.base.structure.DivExpression");
    /*package*/ static final SConcept BinaryLogicalExpression$W5 = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cbdbe7L, "org.iets3.core.expr.base.structure.BinaryLogicalExpression");
    /*package*/ static final SConcept PlusExpression$mx = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86c9a4f2L, "org.iets3.core.expr.base.structure.PlusExpression");
    /*package*/ static final SConcept BinaryComparisonExpression$7z = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cb4f93L, "org.iets3.core.expr.base.structure.BinaryComparisonExpression");
    /*package*/ static final SConcept BinaryEqualityExpression$vt = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cc6d99L, "org.iets3.core.expr.base.structure.BinaryEqualityExpression");
    /*package*/ static final SConcept ModExpression$9c = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x53e292c5b9d6ff5aL, "org.iets3.core.expr.base.structure.ModExpression");
    /*package*/ static final SConcept ToleranceExpr$oO = MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x40c926ee7894dcb2L, "org.iets3.core.expr.simpleTypes.structure.ToleranceExpr");
    /*package*/ static final SConcept LogicalNotExpression$QD = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cd0f6aL, "org.iets3.core.expr.base.structure.LogicalNotExpression");
    /*package*/ static final SConcept NumberType$n = MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x7211e50064d40ea8L, "org.iets3.core.expr.simpleTypes.structure.NumberType");
    /*package*/ static final SConcept Type$WK = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x670d5e92f854a614L, "org.iets3.core.expr.base.structure.Type");
    /*package*/ static final SConcept RealType$36 = MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x46ff3b3d86d0e74cL, "org.iets3.core.expr.simpleTypes.structure.RealType");
    /*package*/ static final SConcept BaseConcept$gP = MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept");
    /*package*/ static final SConcept BooleanType$eL = MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x670d5e92f854a617L, "org.iets3.core.expr.simpleTypes.structure.BooleanType");
    /*package*/ static final SConcept StringType$B3 = MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x46ff3b3d86d3edc7L, "org.iets3.core.expr.simpleTypes.structure.StringType");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink range$RnOa = MetaAdapterFactory.getContainmentLink(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x7211e50064d40ea8L, 0x127541598201af78L, "range");
  }

  private static final class PROPS {
    /*package*/ static final SProperty min$7OOG = MetaAdapterFactory.getProperty(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x127541598201af65L, 0x127541598201af6fL, "min");
    /*package*/ static final SProperty max$7P3H = MetaAdapterFactory.getProperty(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x127541598201af65L, 0x127541598201af70L, "max");
  }
}
