package org.iets3.core.expr.simpleTypes.structure;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.ConceptPresentationAspectBase;
import jetbrains.mps.smodel.runtime.ConceptPresentation;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.runtime.ConceptPresentationBuilder;

public class ConceptPresentationAspectImpl extends ConceptPresentationAspectBase {
  private ConceptPresentation props_AbstractStringDotTarget;
  private ConceptPresentation props_BooleanLiteral;
  private ConceptPresentation props_BooleanType;
  private ConceptPresentation props_BoundsExpression;
  private ConceptPresentation props_ConvertPrecisionNumberExpression;
  private ConceptPresentation props_FalseLiteral;
  private ConceptPresentation props_IntegerType;
  private ConceptPresentation props_InterpolExprWord;
  private ConceptPresentation props_LimitExpression;
  private ConceptPresentation props_NumberLiteral;
  private ConceptPresentation props_NumberPrecSpec;
  private ConceptPresentation props_NumberRangeSpec;
  private ConceptPresentation props_NumberType;
  private ConceptPresentation props_NumericType;
  private ConceptPresentation props_OtherwiseLiteral;
  private ConceptPresentation props_RealType;
  private ConceptPresentation props_RoundDownRoundingMode;
  private ConceptPresentation props_RoundHalfUpRoundingMode;
  private ConceptPresentation props_RoundUpRoundingMode;
  private ConceptPresentation props_RoundingMode;
  private ConceptPresentation props_StringContainsTarget;
  private ConceptPresentation props_StringEndsWithTarget;
  private ConceptPresentation props_StringInterpolationExpr;
  private ConceptPresentation props_StringLengthTarget;
  private ConceptPresentation props_StringLiteral;
  private ConceptPresentation props_StringStartsWithTarget;
  private ConceptPresentation props_StringToIntTarget;
  private ConceptPresentation props_StringType;
  private ConceptPresentation props_StringTypeWithConstraint;
  private ConceptPresentation props_ToleranceExpr;
  private ConceptPresentation props_TrueLiteral;
  private ConceptPresentation props_TruncateRoundingMode;

  @Override
  @Nullable
  public ConceptPresentation getDescriptor(SAbstractConcept c) {
    StructureAspectDescriptor structureDescriptor = (StructureAspectDescriptor) myLanguageRuntime.getAspect(jetbrains.mps.smodel.runtime.StructureAspectDescriptor.class);
    switch (structureDescriptor.internalIndex(c)) {
      case LanguageConceptSwitch.AbstractStringDotTarget:
        if (props_AbstractStringDotTarget == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a base operation for string operations");
          props_AbstractStringDotTarget = cpb.create();
        }
        return props_AbstractStringDotTarget;
      case LanguageConceptSwitch.BooleanLiteral:
        if (props_BooleanLiteral == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a base literal for booleans");
          props_BooleanLiteral = cpb.create();
        }
        return props_BooleanLiteral;
      case LanguageConceptSwitch.BooleanType:
        if (props_BooleanType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a type for truth values of logic and Boolean algebra");
          cpb.rawPresentation("boolean");
          props_BooleanType = cpb.create();
        }
        return props_BooleanType;
      case LanguageConceptSwitch.BoundsExpression:
        if (props_BoundsExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x43bbe28185be6134L);
          cpb.deprecateAggregation(0x418c655fa20799b2L, "expr_old");
          cpb.shortDesc("limit a number within min/max bounds");
          cpb.rawPresentation("bounds");
          props_BoundsExpression = cpb.create();
        }
        return props_BoundsExpression;
      case LanguageConceptSwitch.ConvertPrecisionNumberExpression:
        if (props_ConvertPrecisionNumberExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x7a79f2f908510101L);
          cpb.deprecateAggregation(0x7a79f2f908510151L, "expr_old");
          cpb.shortDesc("change the precision of a number (rounding, truncating)");
          cpb.rawPresentation("precision");
          props_ConvertPrecisionNumberExpression = cpb.create();
        }
        return props_ConvertPrecisionNumberExpression;
      case LanguageConceptSwitch.FalseLiteral:
        if (props_FalseLiteral == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a false literal");
          cpb.rawPresentation("false");
          props_FalseLiteral = cpb.create();
        }
        return props_FalseLiteral;
      case LanguageConceptSwitch.IntegerType:
        if (props_IntegerType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a numeric type corresponding to number[-inf|inf]{0}");
          cpb.rawPresentation("int");
          props_IntegerType = cpb.create();
        }
        return props_IntegerType;
      case LanguageConceptSwitch.InterpolExprWord:
        if (props_InterpolExprWord == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x73194702f11928e2L);
          cpb.deprecateAggregation(0x73194702f11928e3L, "expr_old");
          cpb.shortDesc("embed an expression into an interpolated string");
          cpb.rawPresentation("$(");
          props_InterpolExprWord = cpb.create();
        }
        return props_InterpolExprWord;
      case LanguageConceptSwitch.LimitExpression:
        if (props_LimitExpression == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x418c655fa20799acL);
          cpb.deprecateAggregation(0x418c655fa2079a40L, "type_old");
          cpb.deprecateAggregation(0x418c655fa20799b2L, "expr_old");
          cpb.shortDesc("limit a value to the bounds given by the specified numeric type");
          cpb.rawPresentation("limit");
          props_LimitExpression = cpb.create();
        }
        return props_LimitExpression;
      case LanguageConceptSwitch.NumberLiteral:
        if (props_NumberLiteral == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a number literal");
          cpb.rawPresentation("NumberLiteral");
          props_NumberLiteral = cpb.create();
        }
        return props_NumberLiteral;
      case LanguageConceptSwitch.NumberPrecSpec:
        if (props_NumberPrecSpec == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a specification of a number's precision (digits behind dot)");
          cpb.rawPresentation("NumberPrecSpec");
          props_NumberPrecSpec = cpb.create();
        }
        return props_NumberPrecSpec;
      case LanguageConceptSwitch.NumberRangeSpec:
        if (props_NumberRangeSpec == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("specify a number's range");
          cpb.rawPresentation("NumberRangeSpec");
          props_NumberRangeSpec = cpb.create();
        }
        return props_NumberRangeSpec;
      case LanguageConceptSwitch.NumberType:
        if (props_NumberType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a number type with an optional precision and range");
          cpb.rawPresentation("number");
          props_NumberType = cpb.create();
        }
        return props_NumberType;
      case LanguageConceptSwitch.NumericType:
        if (props_NumericType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a base type for numeric types");
          props_NumericType = cpb.create();
        }
        return props_NumericType;
      case LanguageConceptSwitch.OtherwiseLiteral:
        if (props_OtherwiseLiteral == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("equal to true, but used to represent default case");
          cpb.rawPresentation("otherwise");
          props_OtherwiseLiteral = cpb.create();
        }
        return props_OtherwiseLiteral;
      case LanguageConceptSwitch.RealType:
        if (props_RealType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a numeric type corresponding to number[-inf|inf]{9}");
          cpb.rawPresentation("real");
          props_RealType = cpb.create();
        }
        return props_RealType;
      case LanguageConceptSwitch.RoundDownRoundingMode:
        if (props_RoundDownRoundingMode == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("round down");
          cpb.rawPresentation("round down");
          props_RoundDownRoundingMode = cpb.create();
        }
        return props_RoundDownRoundingMode;
      case LanguageConceptSwitch.RoundHalfUpRoundingMode:
        if (props_RoundHalfUpRoundingMode == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a mathematical rounding mode");
          cpb.rawPresentation("round half up");
          props_RoundHalfUpRoundingMode = cpb.create();
        }
        return props_RoundHalfUpRoundingMode;
      case LanguageConceptSwitch.RoundUpRoundingMode:
        if (props_RoundUpRoundingMode == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("round up");
          cpb.rawPresentation("round up");
          props_RoundUpRoundingMode = cpb.create();
        }
        return props_RoundUpRoundingMode;
      case LanguageConceptSwitch.RoundingMode:
        if (props_RoundingMode == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a base concept for rounding modes");
          props_RoundingMode = cpb.create();
        }
        return props_RoundingMode;
      case LanguageConceptSwitch.StringContainsTarget:
        if (props_StringContainsTarget == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("check if the string contains a substring");
          cpb.rawPresentation("contains");
          props_StringContainsTarget = cpb.create();
        }
        return props_StringContainsTarget;
      case LanguageConceptSwitch.StringEndsWithTarget:
        if (props_StringEndsWithTarget == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("check if the string ends with an expression");
          cpb.rawPresentation("endsWith");
          props_StringEndsWithTarget = cpb.create();
        }
        return props_StringEndsWithTarget;
      case LanguageConceptSwitch.StringInterpolationExpr:
        if (props_StringInterpolationExpr == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a string with embeddable $(expressions)");
          cpb.rawPresentation("'''");
          props_StringInterpolationExpr = cpb.create();
        }
        return props_StringInterpolationExpr;
      case LanguageConceptSwitch.StringLengthTarget:
        if (props_StringLengthTarget == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("get the length of the string");
          cpb.rawPresentation("length");
          props_StringLengthTarget = cpb.create();
        }
        return props_StringLengthTarget;
      case LanguageConceptSwitch.StringLiteral:
        if (props_StringLiteral == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a string literal");
          cpb.rawPresentation("\"");
          props_StringLiteral = cpb.create();
        }
        return props_StringLiteral;
      case LanguageConceptSwitch.StringStartsWithTarget:
        if (props_StringStartsWithTarget == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("check that the string starts with an expression");
          cpb.rawPresentation("startsWith");
          props_StringStartsWithTarget = cpb.create();
        }
        return props_StringStartsWithTarget;
      case LanguageConceptSwitch.StringToIntTarget:
        if (props_StringToIntTarget == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("convert a string to an integer");
          cpb.rawPresentation("toInt");
          props_StringToIntTarget = cpb.create();
        }
        return props_StringToIntTarget;
      case LanguageConceptSwitch.StringType:
        if (props_StringType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a sequence of characters type");
          cpb.rawPresentation("string");
          props_StringType = cpb.create();
        }
        return props_StringType;
      case LanguageConceptSwitch.StringTypeWithConstraint:
        if (props_StringTypeWithConstraint == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a sequence of characters type with a constraint");
          cpb.rawPresentation("string");
          props_StringTypeWithConstraint = cpb.create();
        }
        return props_StringTypeWithConstraint;
      case LanguageConceptSwitch.ToleranceExpr:
        if (props_ToleranceExpr == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a tolerance");
          cpb.rawPresentation("Â±");
          props_ToleranceExpr = cpb.create();
        }
        return props_ToleranceExpr;
      case LanguageConceptSwitch.TrueLiteral:
        if (props_TrueLiteral == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("a true literal");
          cpb.rawPresentation("true");
          props_TrueLiteral = cpb.create();
        }
        return props_TrueLiteral;
      case LanguageConceptSwitch.TruncateRoundingMode:
        if (props_TruncateRoundingMode == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("chop off the decimal portion");
          cpb.rawPresentation("truncate");
          props_TruncateRoundingMode = cpb.create();
        }
        return props_TruncateRoundingMode;
    }
    return null;
  }
}
