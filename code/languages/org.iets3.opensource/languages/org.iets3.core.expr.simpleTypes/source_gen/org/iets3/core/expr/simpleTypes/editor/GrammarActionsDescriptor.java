package org.iets3.core.expr.simpleTypes.editor;

/*Generated by MPS */

import com.mbeddr.mpsutil.grammarcells.runtime.AbstractGrammarActionDescriptor;
import com.mbeddr.mpsutil.grammarcells.runtime.IGrammarActionsDescriptor;
import java.util.List;
import jetbrains.mps.openapi.editor.menus.substitute.SubstituteMenuItem;
import jetbrains.mps.openapi.editor.menus.substitute.SubstituteMenuContext;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.lang.editor.menus.EditorMenuDescriptorBase;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.SNodePointer;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import com.mbeddr.mpsutil.grammarcells.runtime.GrammarCellsUtil;
import org.jetbrains.mps.openapi.language.SConcept;
import com.mbeddr.mpsutil.grammarcells.runtime.menu.GrammarCellsSubstituteMenuItem;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.action.SNodeFactoryOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.openapi.editor.EditorContext;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.lang.editor.menus.substitute.DefaultSubstituteMenuLookup;
import jetbrains.mps.smodel.language.LanguageRegistry;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.lang.editor.menus.substitute.ReferenceScopeSubstituteMenuItem;
import de.slisson.mps.reflection.runtime.ReflectionUtil;
import jetbrains.mps.lang.editor.menus.substitute.SubstituteMenuItemWrapper;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.action.NodeFactoryManager;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuItem;
import jetbrains.mps.openapi.editor.menus.transformation.TransformationMenuContext;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import com.mbeddr.mpsutil.grammarcells.runtime.StringOrSequenceQuery;
import org.iets3.core.expr.base.runtime.runtime.PTF;
import com.mbeddr.mpsutil.grammarcells.runtime.MultiTextActionItem;
import jetbrains.mps.lang.editor.menus.transformation.MenuLocations;
import com.mbeddr.mpsutil.grammarcells.runtime.EditorHierachyCache;
import com.mbeddr.mpsutil.grammarcells.runtime.Parser;
import jetbrains.mps.smodel.constraints.ConstraintsCanBeFacade;
import jetbrains.mps.core.aspects.constraints.rules.kinds.ContainmentContext;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.editor.runtime.selection.SelectionUtil;
import com.mbeddr.mpsutil.grammarcells.runtime.SavedCaretPosition;
import jetbrains.mps.openapi.editor.cells.SubstituteAction;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.smodel.action.NodeSubstituteActionsFactoryContext;
import com.mbeddr.mpsutil.grammarcells.runtime.IToken;
import com.mbeddr.mpsutil.grammarcells.runtime.IRule;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.Set;
import org.jetbrains.mps.openapi.language.SLanguage;
import com.mbeddr.mpsutil.grammarcells.runtime.AbstractRule;
import com.mbeddr.mpsutil.grammarcells.runtime.ISymbol;
import com.mbeddr.mpsutil.grammarcells.runtime.PropertySymbol;
import com.mbeddr.mpsutil.grammarcells.runtime.ConstantSymbol;
import com.mbeddr.mpsutil.grammarcells.runtime.ChildSymbol;
import org.iets3.core.expr.base.behavior.BinaryExpression__BehaviorDescriptor;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class GrammarActionsDescriptor extends AbstractGrammarActionDescriptor implements IGrammarActionsDescriptor {

  public static final GrammarActionsDescriptor INSTANCE = new GrammarActionsDescriptor();

  @Override
  public List<SubstituteMenuItem> getActions(final SubstituteMenuContext _context, final SAbstractConcept expectedOutputConceptExactly) {
    final List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());

    _context.getEditorMenuTrace().pushTraceInfo();
    _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("org.iets3.core.expr.simpleTypes.editor.GrammarActionsDescriptor.getActions", null));
    try {
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "NumberLiteral", new SNodePointer("r:6d94c93d-1ff8-4e1f-8fca-b92e9d42f070(org.iets3.core.expr.simpleTypes.editor)", "1984422498400674775")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.NumberLiteral$wE)) {
              final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

              for (SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.NumberLiteral$wE, _context.getModel(), NumberLiteral_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);
                  if (isApplicable) {
                    ListSequence.fromList(result).addElement(new GrammarCellsSubstituteMenuItem(_context) {
                      private SProperty myProperty = PROPS.value$iWTK;

                      public String getMatchingText(String pattern) {
                        return pattern;
                      }
                      @Override
                      public boolean canExecute(@NotNull String pattern) {
                        if ((pattern == null || pattern.length() == 0)) {
                          return false;
                        }
                        return GrammarCellsUtil.isValidPropertyValue(myProperty, expectedOutputConceptExactly, pattern);
                      }
                      @Override
                      public boolean canExecuteStrictly(@NotNull String pattern) {
                        return canExecute(pattern);
                      }

                      @Override
                      public SNode createNode(@NotNull String pattern) {
                        SNode newNode = SNodeFactoryOperations.createNewNode(expectedOutputConceptExactly, null);
                        SPropertyOperations.assign(newNode, PROPS.value$iWTK, GrammarCellsUtil.toInternalPropertyValue(myProperty, pattern));

                        new Object() {
                          public void postProcess(SNode node, EditorContext editorContext, SNode parentNode) {
                            SNode parent = editorContext.getSelectedNode().getParent();
                            if (SNodeOperations.isInstanceOf(parent, CONCEPTS.UnaryMinusExpression$Gz)) {
                              SNode negLit = SNodeOperations.copyNode(node);
                              SPropertyOperations.assign(negLit, PROPS.value$iWTK, "-" + SPropertyOperations.getString(negLit, PROPS.value$iWTK));
                              SNodeOperations.replaceWithAnother(parent, negLit);
                            }
                          }
                        }.postProcess(newNode, _context.getEditorContext(), _context.getParentNode());
                        return newNode;
                      }


                      @Override
                      public void select(@NotNull SNode newNode, @NotNull String pattern) {
                        super.select(newNode, pattern);
                      }

                      @Override
                      public SAbstractConcept getOutputConcept() {
                        return CONCEPTS.NumberLiteral$wE;
                      }
                    });
                  }
                }

              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where((it) -> it != null).toList();
        }
      }.query()));
      ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
        public Iterable<SubstituteMenuItem> query() {
          List<SubstituteMenuItem> result = ListSequence.fromList(new ArrayList<SubstituteMenuItem>());
          _context.getEditorMenuTrace().pushTraceInfo();
          _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "ToleranceExpr", new SNodePointer("r:6d94c93d-1ff8-4e1f-8fca-b92e9d42f070(org.iets3.core.expr.simpleTypes.editor)", "4668305294413329126")));
          try {
            if (SConceptOperations.isExactly(SNodeOperations.asSConcept(expectedOutputConceptExactly), CONCEPTS.ToleranceExpr$oO)) {
              final SAbstractConcept wrappedConcept = CONCEPTS.Expression$D_;
              for (final SConcept subconcept : ListSequence.fromList(GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.ToleranceExpr$oO, _context.getModel(), ToleranceExpr_Editor.class, _context.getEditorContext()))) {
                final SConcept outputConcept = ((SConcept) subconcept);

                final SAbstractConcept expectedOutputConcept = GrammarCellsUtil.getExpectedOutputConcept(_context, expectedOutputConceptExactly);

                boolean wrapRequired = !(SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept)));
                if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(outputConcept), SNodeOperations.asSConcept(expectedOutputConcept)) && wrapRequired) {

                  final SContainmentLink aggregation = LINKS.value$i_DL;

                  boolean isApplicable = GrammarCellsUtil.canBeChild(subconcept, _context);


                  if (isApplicable) {
                    // get all available actions
                    List<SubstituteMenuItem> actions = _context.withLink(LINKS.value$i_DL).createItems(new DefaultSubstituteMenuLookup(LanguageRegistry.getInstance(_context.getEditorContext().getRepository()), wrappedConcept));
                    // Filter based on grammar.rule conditions
                    List<SubstituteMenuItem> wrappedActions = ListSequence.fromList(actions).where(new _FunctionTypes._return_P1_E0<Boolean, SubstituteMenuItem>() {
                      public Boolean invoke(SubstituteMenuItem it) {
                        // Need to check constraints again for concrete type
                        boolean isApplicable = GrammarCellsUtil.canBeChildForSubstitute(subconcept, _context, it.getOutputConcept(), aggregation);
                        final SAbstractConcept wrappedConcept = it.getOutputConcept();
                        if (SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(wrappedConcept), SNodeOperations.asSConcept(expectedOutputConcept))) {
                          return false;
                        }
                        final EditorContext editorContext = _context.getEditorContext();
                        final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                        return isApplicable;
                      }
                    }).toList();

                    // Create wrapper objects for items
                    wrappedActions = ListSequence.fromList(wrappedActions).select((final SubstituteMenuItem it) -> {
                      final SNode smartReferent = ((it instanceof ReferenceScopeSubstituteMenuItem) ? ((SNode) ReflectionUtil.readField(ReferenceScopeSubstituteMenuItem.class, ((ReferenceScopeSubstituteMenuItem) it), "myReferent")) : null);

                      SubstituteMenuItem wrapper = new SubstituteMenuItemWrapper(it) {
                        private SNode wrappedNode;
                        @Override
                        public SNode createNode(@NotNull String pattern) {
                          SNode nodeToWrap = super.createNode(pattern);
                          wrappedNode = nodeToWrap;
                          // use setupNode after setting wrapped element to allow access to the wrapped element in node factories
                          SNode wrapper = SConceptOperations.createNewNode(SNodeOperations.asInstanceConcept(outputConcept));
                          SLinkOperations.setTarget(wrapper, LINKS.value$i_DL, SNodeOperations.cast(nodeToWrap, CONCEPTS.Expression$D_));
                          NodeFactoryManager.setupNode(outputConcept, wrapper, _context.getCurrentTargetNode(), _context.getParentNode(), _context.getModel());

                          return wrapper;
                        }
                        @Override
                        public String getDescriptionText(@NotNull String pattern) {
                          String description = it.getDescriptionText(pattern);
                          return ((description != null && description.length() > 0) ? description : it.getOutputConcept().getName());
                        }
                        @Override
                        public SAbstractConcept getOutputConcept() {
                          return outputConcept;
                        }

                        @Override
                        public void select(@NotNull SNode createdNode, @NotNull String pattern) {
                          GrammarCellsSubstituteMenuItem.select(_context.getEditorContext().getEditorComponent(), createdNode);
                        }
                      };
                      return wrapper;
                    }).toList();

                    ListSequence.fromList(result).addSequence(ListSequence.fromList(wrappedActions));
                  }

                }
              }
            }
          } finally {
            _context.getEditorMenuTrace().popTraceInfo();
          }
          return ListSequence.fromList(result).where((it) -> it != null).toList();
        }
      }.query()));
    } finally {
      _context.getEditorMenuTrace().popTraceInfo();
    }

    return ListSequence.fromList(result).where((it) -> it != null).toList();
  }

  @Override
  protected List<TransformationMenuItem> doGetSideTransformActions(final TransformationMenuContext _context) {
    final List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());

    _context.getEditorMenuTrace().pushTraceInfo();
    _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("org.iets3.core.expr.simpleTypes.editor.GrammarActionsDescriptor.doGetSideTransformActions", null));
    try {
      {
        final EditorContext editorContext = _context.getEditorContext();
        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedBefore = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        ListSequence.fromList(redirectedBefore).addElement(MultiTuple.<TransformationMenuContext,_FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>from((SNodeOperations.isInstanceOf(((SNode) _context.getNode()), CONCEPTS.StringType$B3) ? _context : null), ((_FunctionTypes._return_P1_E0<Boolean, TransformationMenuContext>) (TransformationMenuContext parentContext) -> {
          final SNode sourceNode = parentContext.getNode();
          return true;
        })));

        List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> redirectedAfter = ListSequence.fromList(new ArrayList<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>>());
        new Object() {
          public void withRedirectedContext(final TransformationMenuContext _context) {
            if (_context == null) {
              return;
            }
            final SNode sourceNode = _context.getNode();
            EditorContext editorContext = _context.getEditorContext();
            if (SNodeOperations.isInstanceOf(sourceNode, CONCEPTS.StringType$B3)) {
              final Iterable<String> matchingTexts = new StringOrSequenceQuery() {
                public Object queryStringOrSequence() {
                  return "with constraint";
                }
              }.query();
              final boolean isApplicable = new Object() {
                public boolean query() {
                  return PTF.useStringConstraints();
                }
              }.query();

              if (isApplicable && Sequence.fromIterable(matchingTexts).isNotEmpty()) {
                ListSequence.fromList(result).addElement(new MultiTextActionItem(matchingTexts, _context) {
                  @Override
                  public void execute(@NotNull String pattern) {
                    doSubstitute(pattern);
                  }
                  public SNode doSubstitute(@NotNull String pattern) {
                    SNode node = _context.getNode();
                    SNode newNode = createStringTypeWithConstraint_vcvxr4_a0b0a1a();
                    return SNodeOperations.replaceWithAnother(node, newNode);
                  }
                  @Override
                  public String getShortDescriptionText(@NotNull String pattern) {
                    String originalText = super.getShortDescriptionText(pattern);
                    SNode node = _context.getNode();
                    EditorContext editorContext = _context.getEditorContext();
                    return "add a constraint";
                  }

                  @Override
                  public SAbstractConcept getOutputConcept() {
                    return CONCEPTS.StringType$B3;
                  }
                });
              }
            }
          }
          public void withRedirectedContext(List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> beforeContexts, List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> afterContexts) {

            List<Tuples._2<TransformationMenuContext, _FunctionTypes._return_P1_E0<? extends Boolean, ? super TransformationMenuContext>>> contexts = (_context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM ? afterContexts : beforeContexts);
            contexts = ListSequence.fromList(contexts).where((it) -> it != null).toList();

            for (int validIndex = 0; validIndex < ListSequence.fromList(contexts).count(); validIndex++) {
              TransformationMenuContext redirectedContext = ListSequence.fromList(contexts).getElement(validIndex)._0();
              if (redirectedContext == null) {
                continue;
              }

              boolean anyBeforeVisible = false;
              for (int i = 0; i < validIndex; i++) {
                anyBeforeVisible = anyBeforeVisible || ListSequence.fromList(contexts).getElement(i)._1().invoke(redirectedContext);
              }
              if (anyBeforeVisible) {
                continue;
              }

              if (!(EditorHierachyCache.getInstance().isActiveEditor(StringType_Editor.class, redirectedContext.getNode().getConcept(), GrammarCellsUtil.getSelectionHints(_context.getEditorContext())))) {
                continue;
              }

              withRedirectedContext(redirectedContext);
              break;
            }
          }
        }.withRedirectedContext(redirectedBefore, redirectedAfter);
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "NumberLiteral", new SNodePointer("r:6d94c93d-1ff8-4e1f-8fca-b92e9d42f070(org.iets3.core.expr.simpleTypes.editor)", "1984422498400674775")));
              try {
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where((it) -> it != null).toList();
            }
          }.query(_context)));
        }
      }
      {
        boolean sideEnabled = false;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM;
        sideEnabled |= _context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM;
        if (sideEnabled) {
          ListSequence.fromList(result).addSequence(Sequence.fromIterable(new Object() {
            public Iterable<TransformationMenuItem> query(final TransformationMenuContext _context) {
              List<TransformationMenuItem> result = ListSequence.fromList(new ArrayList<TransformationMenuItem>());
              _context.getEditorMenuTrace().pushTraceInfo();
              _context.getEditorMenuTrace().setDescriptor(new EditorMenuDescriptorBase("grammar.wrap in " + "ToleranceExpr", new SNodePointer("r:6d94c93d-1ff8-4e1f-8fca-b92e9d42f070(org.iets3.core.expr.simpleTypes.editor)", "4668305294413329126")));
              try {
                if (_context.getMenuLocation() == MenuLocations.RIGHT_SIDE_TRANSFORM) {
                  final SNode sourceNode = new Parser(_context.getModel()).isEndOf(_context.getNode(), _context.getMenuLocation() == MenuLocations.LEFT_SIDE_TRANSFORM, CONCEPTS.Expression$D_, null);
                  final EditorContext editorContext = _context.getEditorContext();

                  if (sourceNode != null) {
                    final SAbstractConcept sourceNodeConcept = SNodeOperations.getConcept(sourceNode);
                    SContainmentLink link = sourceNode.getContainmentLink();
                    final SAbstractConcept expectedConcept = (link == null ? null : link.getTargetConcept());
                    for (final SAbstractConcept subconcept : GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.ToleranceExpr$oO, _context.getModel(), ToleranceExpr_Editor.class, _context.getEditorContext())) {
                      boolean wrapperAllowed = expectedConcept == null || SConceptOperations.isSubConceptOf(SNodeOperations.asSConcept(subconcept), SNodeOperations.asSConcept(expectedConcept));
                      if (wrapperAllowed) {
                        final Iterable<String> matchingText = new Object() {
                          public Iterable<String> query(SNode wrappedNode) {
                            return new StringOrSequenceQuery() {
                              public Object queryStringOrSequence() {
                                return "+/-";
                              }
                            }.query();
                          }
                        }.query(sourceNode);
                        if (Sequence.fromIterable(matchingText).isNotEmpty()) {
                          boolean sideTransformationEnabled = ConstraintsCanBeFacade.checkCanBeParent(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          sideTransformationEnabled &= GrammarCellsUtil.canBeAncestor(SNodeOperations.getParent(sourceNode), subconcept, sourceNode.getContainmentLink());
                          sideTransformationEnabled &= ConstraintsCanBeFacade.checkCanBeChild(new ContainmentContext.Builder().parentNode(SNodeOperations.getParent(sourceNode)).childConcept(subconcept).link(sourceNode.getContainmentLink()).build()).isEmpty();
                          if (sideTransformationEnabled) {
                            ListSequence.fromList(result).addSequence(Sequence.fromIterable(new MultiTextActionItem(matchingText, _context) {

                              @Override
                              public void execute(@NotNull String pattern) {
                                doSubstitute(_context.getEditorContext(), pattern);
                              }
                              protected SNode doSubstitute(@Nullable EditorContext editorContext, String pattern) {
                                String matchingText = getMatchingText(pattern);
                                SNode wrapper = SNodeOperations.cast(SNodeFactoryOperations.createNewNode(subconcept, null), CONCEPTS.ToleranceExpr$oO);
                                SNodeOperations.replaceWithAnother(sourceNode, wrapper);
                                SLinkOperations.setTarget(wrapper, LINKS.value$i_DL, SNodeOperations.cast(sourceNode, CONCEPTS.Expression$D_));


                                SNode newChild = ListSequence.fromList(SNodeOperations.getChildren(wrapper)).findFirst((it) -> it != sourceNode);
                                editorContext.flushEvents();
                                if (newChild == null) {
                                  GrammarCellsUtil.selectCellWithText(editorContext, wrapper, matchingText);
                                } else {
                                  SelectionUtil.selectNode(editorContext, newChild);
                                }

                                SavedCaretPosition caretPosition = new SavedCaretPosition(editorContext);
                                caretPosition.save();
                                Parser parser = new Parser(editorContext.getModel());
                                SNode rebalanced = parser.rebalanceIfRequired(parser.findRootExpression(wrapper));
                                if (rebalanced != null) {
                                  editorContext.flushEvents();
                                  caretPosition.restore();
                                }
                                return newChild;
                              }
                              public SAbstractConcept getOutputConcept() {
                                return subconcept;
                              }
                            }.getMultipleOrSingleAction(false)));
                            addSideTransformRemoval(_context);
                          }
                        }
                      }
                    }
                  }
                }
              } finally {
                _context.getEditorMenuTrace().popTraceInfo();
              }
              return ListSequence.fromList(result).where((it) -> it != null).toList();
            }
          }.query(_context)));
        }
      }
    } finally {
      _context.getEditorMenuTrace().popTraceInfo();
    }

    return ListSequence.fromList(result).where((it) -> it != null).toList();
  }

  @Override
  public List<SubstituteAction> getConstantReplaceActions(final IOperationContext operationContext, final NodeSubstituteActionsFactoryContext _context, final List<IToken> elementsBefore, final List<IToken> elementsAfter) {
    final List<SubstituteAction> result = ListSequence.fromList(new ArrayList<SubstituteAction>());

    return ListSequence.fromList(result).where((it) -> it != null).toList();
  }

  @Override
  public List<IRule> getRules(final SModel contextModel) {
    final List<IRule> rules = ListSequence.fromList(new ArrayList<IRule>());

    final Set<SLanguage> visibleLanguages = GrammarCellsUtil.getVisibleLanguages(contextModel);

    {
      final List<SConcept> subconcepts = GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.NumberLiteral$wE, visibleLanguages);
      for (final SAbstractConcept subconcept : subconcepts) {
        ListSequence.fromList(rules).addElement(new AbstractRule() {
          private List<ISymbol> symbols = ListSequence.fromList(new ArrayList<ISymbol>());
          {
            ListSequence.fromList(symbols).addElement(new PropertySymbol(CONCEPTS.NumberLiteral$wE, PROPS.value$iWTK));
            symbols = ListSequence.fromList(symbols).where((it) -> it != null).toList();
          }
          @Override
          public List<ISymbol> getSymbols() {
            return symbols;
          }
          @Override
          public SAbstractConcept getOutputConcept() {
            return subconcept;
          }
          @Override
          public SAbstractConcept getDefinedForConcept() {
            return CONCEPTS.NumberLiteral$wE;
          }
          @Override
          public String toString() {
            return subconcept.getName();
          }
        });
      }
    }
    {
      final List<SConcept> subconcepts = GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.StringLiteral$By, visibleLanguages);
      for (final SAbstractConcept subconcept : subconcepts) {
        ListSequence.fromList(rules).addElement(new AbstractRule() {
          private List<ISymbol> symbols = ListSequence.fromList(new ArrayList<ISymbol>());
          {
            ListSequence.fromList(symbols).addElement(new ConstantSymbol("\""));
            ListSequence.fromList(symbols).addElement(new PropertySymbol(CONCEPTS.StringLiteral$By, PROPS.value$zwlK));
            ListSequence.fromList(symbols).addElement(new ConstantSymbol("\""));
            symbols = ListSequence.fromList(symbols).where((it) -> it != null).toList();
          }
          @Override
          public List<ISymbol> getSymbols() {
            return symbols;
          }
          @Override
          public SAbstractConcept getOutputConcept() {
            return subconcept;
          }
          @Override
          public SAbstractConcept getDefinedForConcept() {
            return CONCEPTS.StringLiteral$By;
          }
          @Override
          public String toString() {
            return subconcept.getName();
          }
        });
      }
    }
    {
      final List<SConcept> subconcepts = GrammarCellsUtil.getVisibleSubconceptsNonAbstract(CONCEPTS.ToleranceExpr$oO, visibleLanguages);
      for (final SAbstractConcept subconcept : subconcepts) {
        ListSequence.fromList(rules).addElement(new AbstractRule() {
          private List<ISymbol> symbols = ListSequence.fromList(new ArrayList<ISymbol>());
          {
            ListSequence.fromList(symbols).addElement(new ChildSymbol(LINKS.value$i_DL));
            ListSequence.fromList(symbols).addElement(new ConstantSymbol("Â±"));
            ListSequence.fromList(symbols).addElement(new ChildSymbol(LINKS.tolerance$PHxg));
            symbols = ListSequence.fromList(symbols).where((it) -> it != null).toList();
          }
          @Override
          public List<ISymbol> getSymbols() {
            return symbols;
          }
          @Override
          public SAbstractConcept getOutputConcept() {
            return subconcept;
          }
          @Override
          public SAbstractConcept getDefinedForConcept() {
            return CONCEPTS.ToleranceExpr$oO;
          }
          @Override
          public String toString() {
            return subconcept.getName();
          }
          @Override
          public int getPriority() {
            return (int) BinaryExpression__BehaviorDescriptor.priority_id4rZeNQ6MpZB.invoke(SNodeOperations.asSConcept(CONCEPTS.BinaryEqualityExpression$vt)) + 50;
          }
        });
      }
    }

    return rules;
  }
  private static SNode createStringTypeWithConstraint_vcvxr4_a0b0a1a() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.StringTypeWithConstraint$H$);
    n0.forChild(LINKS.constraint$vrqk).init(CONCEPTS.StringLiteralRegexp$SX);
    return n0.getResult();
  }

  private static final class PROPS {
    /*package*/ static final SProperty value$iWTK = MetaAdapterFactory.getProperty(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x46ff3b3d86d0e6daL, 0x46ff3b3d86d0e6ddL, "value");
    /*package*/ static final SProperty value$zwlK = MetaAdapterFactory.getProperty(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x46ff3b3d86d3edc8L, 0x46ff3b3d86d3edcbL, "value");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept UnaryMinusExpression$Gz = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cdddbbL, "org.iets3.core.expr.base.structure.UnaryMinusExpression");
    /*package*/ static final SConcept NumberLiteral$wE = MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x46ff3b3d86d0e6daL, "org.iets3.core.expr.simpleTypes.structure.NumberLiteral");
    /*package*/ static final SConcept Expression$D_ = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x670d5e92f854a047L, "org.iets3.core.expr.base.structure.Expression");
    /*package*/ static final SConcept ToleranceExpr$oO = MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x40c926ee7894dcb2L, "org.iets3.core.expr.simpleTypes.structure.ToleranceExpr");
    /*package*/ static final SConcept StringType$B3 = MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x46ff3b3d86d3edc7L, "org.iets3.core.expr.simpleTypes.structure.StringType");
    /*package*/ static final SConcept StringLiteral$By = MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x46ff3b3d86d3edc8L, "org.iets3.core.expr.simpleTypes.structure.StringLiteral");
    /*package*/ static final SConcept BinaryEqualityExpression$vt = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cc6d99L, "org.iets3.core.expr.base.structure.BinaryEqualityExpression");
    /*package*/ static final SConcept StringTypeWithConstraint$H$ = MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x2875f33f196375acL, "org.iets3.core.expr.simpleTypes.structure.StringTypeWithConstraint");
    /*package*/ static final SConcept StringLiteralRegexp$SX = MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11174a0992dL, "jetbrains.mps.baseLanguage.regexp.structure.StringLiteralRegexp");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink value$i_DL = MetaAdapterFactory.getContainmentLink(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x40c926ee7894dcb2L, 0x40c926ee7894e283L, "value");
    /*package*/ static final SContainmentLink tolerance$PHxg = MetaAdapterFactory.getContainmentLink(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x40c926ee7894dcb2L, 0x40c926ee7894e56eL, "tolerance");
    /*package*/ static final SContainmentLink constraint$vrqk = MetaAdapterFactory.getContainmentLink(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x2875f33f196375acL, 0x7bc831dc1ebdc4aeL, "constraint");
  }
}
