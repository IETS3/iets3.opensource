package org.iets3.core.expr.simpleTypes.typesystem;

/*Generated by MPS */

import jetbrains.mps.lang.typesystem.runtime.AbstractInequationReplacementRule_Runtime;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.typesystem.inference.EquationInfo;
import jetbrains.mps.typesystem.inference.TypeCheckingContext;
import jetbrains.mps.lang.typesystem.runtime.IsApplicable2Status;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.baseLanguage.regexp.behavior.Regexp__BehaviorDescriptor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.ArrayList;
import jetbrains.mps.errors.messageTargets.MessageTarget;
import jetbrains.mps.errors.messageTargets.NodeMessageTarget;
import jetbrains.mps.errors.IErrorReporter;
import jetbrains.mps.lang.typesystem.runtime.HUtil;
import jetbrains.mps.lang.typesystem.runtime.IsApplicableStatus;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SProperty;

public class checkStringConstraint_InequationReplacementRule extends AbstractInequationReplacementRule_Runtime {
  public checkStringConstraint_InequationReplacementRule() {
  }
  public void processInequation(final SNode subtype, final SNode supertype, final EquationInfo equationInfo, final TypeCheckingContext typeCheckingContext, IsApplicable2Status status, final boolean inequalityIsWeak, final boolean inequalityIsLessThan) {
    if ((SLinkOperations.getTarget(supertype, LINKS.constraint$vrqk) == null) || !((boolean) Regexp__BehaviorDescriptor.isValid_id48bMILtL4il.invoke(SLinkOperations.getTarget(supertype, LINKS.constraint$vrqk)))) {
      return;
    }
    {
      final SNode literalRegex = SLinkOperations.getTarget(subtype, LINKS.constraint$vrqk);
      if (SNodeOperations.isInstanceOf(literalRegex, CONCEPTS.StringLiteralRegexp$SX)) {
        String value = SPropertyOperations.getString(literalRegex, PROPS.text$VShT);
        String regex = Regexp__BehaviorDescriptor.getString_idhMuDF1A.invoke(SLinkOperations.getTarget(supertype, LINKS.constraint$vrqk), new ArrayList<SNode>());
        try {
          if (!(value.matches(regex))) {
            {
              final MessageTarget errorTarget = new NodeMessageTarget();
              IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(equationInfo.getNodeWithError(), String.format("The string doesn't match the regular expression: %s", regex), "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)", "4405049877528611672", null, errorTarget);
              HUtil.addAdditionalRuleIdsFromInfo(_reporter_2309309498, equationInfo);
            }
          }
        } catch (Exception e) {
          {
            final MessageTarget errorTarget = new NodeMessageTarget();
            IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(equationInfo.getNodeWithError(), "Error evaluation constraint:" + e.getMessage(), "r:050f6d52-a81b-4b31-9a1c-531c1a04708e(org.iets3.core.expr.simpleTypes.typesystem)", "4735327607201789309", null, errorTarget);
            HUtil.addAdditionalRuleIdsFromInfo(_reporter_2309309498, equationInfo);
          }
          // Nothing to do here. The regex is invalid
        }
      }
    }
  }
  public boolean checkInequation(final SNode subtype, final SNode supertype, final EquationInfo equationInfo, IsApplicable2Status status, final boolean inequalityIsWeak, final boolean inequalityIsLessThan) {
    boolean result_14532009 = true;
    if ((SLinkOperations.getTarget(supertype, LINKS.constraint$vrqk) == null) || !((boolean) Regexp__BehaviorDescriptor.isValid_id48bMILtL4il.invoke(SLinkOperations.getTarget(supertype, LINKS.constraint$vrqk)))) {
      return result_14532009;
    }
    {
      final SNode literalRegex = SLinkOperations.getTarget(subtype, LINKS.constraint$vrqk);
      if (SNodeOperations.isInstanceOf(literalRegex, CONCEPTS.StringLiteralRegexp$SX)) {
        String value = SPropertyOperations.getString(literalRegex, PROPS.text$VShT);
        String regex = Regexp__BehaviorDescriptor.getString_idhMuDF1A.invoke(SLinkOperations.getTarget(supertype, LINKS.constraint$vrqk), new ArrayList<SNode>());
        try {
          if (!(value.matches(regex))) {
            result_14532009 = false;
          }
        } catch (Exception e) {
          result_14532009 = false;
          // Nothing to do here. The regex is invalid
        }
      }
    }
    return result_14532009;
  }
  public boolean isWeak() {
    return true;
  }
  public IsApplicableStatus isApplicableSubtypeAndPattern(SNode node) {
    return new IsApplicableStatus(node.getConcept().isSubConceptOf(getApplicableSubtypeConcept()), null);
  }
  public IsApplicableStatus isApplicableSupertypeAndPattern(SNode node) {
    return new IsApplicableStatus(node.getConcept().isSubConceptOf(getApplicableSupertypeConcept()), null);
  }

  public SAbstractConcept getApplicableSubtypeConcept() {
    return CONCEPTS.StringTypeWithConstraint$H$;
  }
  public SAbstractConcept getApplicableSupertypeConcept() {
    return CONCEPTS.StringTypeWithConstraint$H$;
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink constraint$vrqk = MetaAdapterFactory.getContainmentLink(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x2875f33f196375acL, 0x7bc831dc1ebdc4aeL, "constraint");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept StringLiteralRegexp$SX = MetaAdapterFactory.getConcept(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11174a0992dL, "jetbrains.mps.baseLanguage.regexp.structure.StringLiteralRegexp");
    /*package*/ static final SConcept StringTypeWithConstraint$H$ = MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x2875f33f196375acL, "org.iets3.core.expr.simpleTypes.structure.StringTypeWithConstraint");
  }

  private static final class PROPS {
    /*package*/ static final SProperty text$VShT = MetaAdapterFactory.getProperty(0xdaafa647f1f74b0bL, 0xb09669cd7c8408c0L, 0x11174a0992dL, 0x11174a0b84fL, "text");
  }
}
