package org.iets3.analysis.base.plugin;

/*Generated by MPS */

import java.util.function.Supplier;
import java.time.format.DateTimeFormatter;
import com.intellij.util.Consumer;
import org.jetbrains.mps.openapi.model.SNode;
import java.time.LocalDateTime;
import org.iets3.analysis.base.behavior.ISolvable__BehaviorDescriptor;
import org.iets3.analysis.base.behavior.AbstractSolverTask__BehaviorDescriptor;
import org.apache.commons.lang3.StringUtils;
import java.util.List;
import org.iets3.core.base.behavior.IResult;
import java.util.Collections;

public class SolverTaskCreator implements Supplier<ITask> {
  private static DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd.MM.yyyy HH:mm:ss");
  private final Consumer<ISolvableTaskStatus> statusUpdater;
  private final SNode solvable;
  private final java.util.function.Consumer<SNode> solverTaskCallback;

  public SolverTaskCreator(Consumer<ISolvableTaskStatus> statusUpdater, SNode solvable, java.util.function.Consumer<SNode> solverTaskCallback) {
    this.statusUpdater = statusUpdater;
    this.solvable = solvable;
    this.solverTaskCallback = solverTaskCallback;
  }

  @Override
  public ITask get() {
    return makeSolverTask(statusUpdater, solvable, solverTaskCallback);
  }

  @Deprecated
  public ITask create() {
    return get();
  }

  /**
   * Return a Supplier which triggers the SolverTask provided by ISolvable.
   * 
   * @param statusUpdater updates UI statis
   * @param solvable has computation
   * @param solverTaskCallback informed after SolverTask could be successfully created
   * @return the wrapped SolverTask (might be a dummy if error occurred)
   */
  private static SolverTaskWrapper makeSolverTask(final Consumer<ISolvableTaskStatus> statusUpdater, final SNode solvable, final java.util.function.Consumer<SNode> solverTaskCallback) {

    SolverTaskWrapper runnableSolverTask;
    try {
      runnableSolverTask = createSolverTask(solvable);
      solverTaskCallback.accept(runnableSolverTask.solverTask());
    } catch (Throwable e) {
      e.printStackTrace();
      statusUpdater.consume(ISolvableTaskStatus.Failure);
      String errorMsg = "Task Creation failed " + LocalDateTime.now().format(formatter);
      return makeErrorWrapper(null, solvable, errorMsg);
    }
    return runnableSolverTask;
  }


  /**
   * Create a SolverTask from an ISolvable, or a dummy SolverTaskWrapper if the SolverTask could not be generated.
   * 
   * @param solvable solvable
   * @return a wrapped SolverTask (either an actual one or a dummy on error during creation)
   */
  private static SolverTaskWrapper createSolverTask(final SNode solvable) {
    SNode st = ISolvable__BehaviorDescriptor.createSolverTask_id4pkidg67Lgb.invoke(solvable);
    AbstractSolverTask__BehaviorDescriptor.finishAndCleanup_id7rOSrvnHe0i.invoke(st);

    final String errorMessage = errorMessage(st);
    if (StringUtils.isNotBlank(errorMessage)) {
      // Error case
      return makeErrorWrapper(st, solvable, errorMessage);
    }

    // No error, thus we may the solverTask (on some executor)
    return new SolverTaskWrapper(st, ISolvable__BehaviorDescriptor.nodeForDebuggerAndErrorMessage_id6MbsW86o$bl.invoke(solvable));
  }

  private static SolverTaskWrapper makeErrorWrapper(SNode st, final SNode solvable, final String errorMessage) {
    return new SolverTaskWrapper(st, ISolvable__BehaviorDescriptor.nodeForDebuggerAndErrorMessage_id6MbsW86o$bl.invoke(solvable)) {
      public List<IResult> run() {
        return Collections.<IResult>singletonList(IResult.make(IResult.MessageType.Error, errorMessage, Collections.singletonList(solvable), null));
      }
    };
  }

  private static String errorMessage(SNode st) {
    if (st == null) {
      return "No Solver Task was created " + LocalDateTime.now().format(formatter);
    } else if (AbstractSolverTask__BehaviorDescriptor.getWarning_id7rOSrvnH60y.invoke(st) != null) {
      return AbstractSolverTask__BehaviorDescriptor.getWarning_id7rOSrvnH60y.invoke(st);
    }
    return null;
  }
}
