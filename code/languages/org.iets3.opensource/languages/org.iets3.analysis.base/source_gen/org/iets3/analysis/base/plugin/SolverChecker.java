package org.iets3.analysis.base.plugin;

/*Generated by MPS */

import jetbrains.mps.nodeEditor.checking.BaseEditorChecker;
import java.util.Map;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.WeakHashMap;
import java.util.Objects;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.nodeEditor.checking.UpdateResult;
import jetbrains.mps.util.Cancellable;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Set;
import jetbrains.mps.nodeEditor.EditorMessage;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.Collection;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.nodeEditor.HighlighterMessage;
import org.jetbrains.mps.openapi.model.SNodeReference;
import jetbrains.mps.errors.item.NodeReportItemBase;
import jetbrains.mps.errors.MessageStatus;
import org.iets3.core.base.behavior.IResult;

/**
 * Provides update information for the UI Highlighter
 */
public class SolverChecker extends BaseEditorChecker {

  private Map<EditorComponent, Long> changeCounts = MapSequence.fromMap(new WeakHashMap<EditorComponent, Long>());


  @Override
  public synchronized boolean needsUpdate(EditorComponent component) {
    return !(Objects.equals(AsyncSolverTaskExecutor.changeCount(), MapSequence.fromMap(changeCounts).get(component)));
  }


  @NotNull
  @Override
  public UpdateResult update(EditorComponent component, boolean b, boolean b1, Cancellable cancellable) {
    SNode castedNode = component.getEditedNode();

    Set<EditorMessage> totalHighlighterMessages = SetSequence.fromSet(new HashSet<EditorMessage>());
    long changeCount;
    Collection<MessageUI> messages;

    {
      Tuples._2<Long, Collection<MessageUI>> _tmp_e3btoh_g0h = AsyncSolverTaskExecutor.nodesMessages(castedNode);
      changeCount = _tmp_e3btoh_g0h._0();
      messages = _tmp_e3btoh_g0h._1();
    }
    MapSequence.fromMap(changeCounts).put(component, changeCount);
    SetSequence.fromSet(totalHighlighterMessages).addSequence(CollectionSequence.fromCollection(messages).where((it) -> it.node != null && it.type != null).select((it) -> toHighlighterMessage(it)));

    return new UpdateResult.Completed(true, totalHighlighterMessages);
  }

  private HighlighterMessage toHighlighterMessage(MessageUI message) {
    SNodeReference reference = message.node.getReference();
    String msg = (message == null ? "" : message.message);
    NodeReportItemBase base = new SolverReportItem(toMessageStatus((message != null ? message.type : null)), reference, msg);
    return new HighlighterMessage(this, base, message.node);
  }

  private MessageStatus toMessageStatus(IResult.MessageType type) {
    switch (type) {
      case Timeout:
        return MessageStatus.ERROR;
      case Error:
        return MessageStatus.ERROR;
      case OK:
        return MessageStatus.OK;
      case Warning:
        return MessageStatus.WARNING;
      case Info:
        return MessageStatus.OK;
      default:
        return MessageStatus.OK;
    }
  }
}
