package org.iets3.analysis.base.plugin;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.time.format.DateTimeFormatter;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Collections;
import java.util.WeakHashMap;
import java.util.List;
import com.intellij.util.Consumer;
import java.util.LinkedList;
import java.util.concurrent.CompletableFuture;
import org.iets3.core.base.behavior.IResult;
import java.util.function.Supplier;
import java.time.Duration;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import java.util.Collection;
import java.util.Optional;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.apache.commons.lang3.StringUtils;
import java.util.concurrent.TimeoutException;
import java.time.LocalDateTime;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.Callable;
import org.jetbrains.mps.openapi.module.SRepository;

public class AsyncSolverTaskExecutor {
  private static final Logger LOG = Logger.getLogger(AsyncSolverTaskExecutor.class);
  private static final ExecutorService executorPhase1 = Executors.newSingleThreadScheduledExecutor(threadFactory());
  private static final ExecutorService executorPhase2 = Executors.newSingleThreadScheduledExecutor(threadFactory());

  private static DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd.MM.yyyy HH:mm:ss");
  /**
   * Queue solver results which have been obtained asynchronously in order to propagate to the UI
   */
  private static MessageBuffer messageBuffer = new MessageBuffer();
  /**
   * Any node should have at most only one queued task which is kept track of here.
   */
  private static Map<SNode, CancelableSupplier<?>> nodeToQueuedTask = Collections.synchronizedMap(new WeakHashMap<SNode, CancelableSupplier<?>>());

  protected static final List<Consumer<TaskEntity>> taskChangeListeners = Collections.synchronizedList(new LinkedList<Consumer<TaskEntity>>());

  /**
   * UI-COmponents can register here to obtain status updates of running tasks
   * 
   * @param listener accepts TaskEntity
   */
  public static void addTaskChangeListener(Consumer<TaskEntity> listener) {
    taskChangeListeners.add(listener);
  }

  public static void removeTaskChangeListener(Consumer<TaskEntity> listener) {
    taskChangeListeners.remove(listener);
  }

  /**
   * Creates a Consumer of a TaskEntity which passes it on to all listeners
   * 
   * @return Consumer
   */
  private static Consumer<TaskEntity> observationConsumer() {
    return (final TaskEntity ta) -> taskChangeListeners.forEach((Consumer<TaskEntity> listener) -> listener.consume(ta));
  }
  /**
   * Run runnableSolverTask in async mode.
   * 
   * @param forWho the node for which this is run
   * @param runnableSolverTask A Callable providng IResult
   * @param statusUpdater informs UI of status updates
   * @param timeout defines max run time
   * @param messaging sould errors be highlighted
   * @return result of callable 
   */
  public static CompletableFuture<List<IResult>> submit(final SNode forWho, final Supplier<List<IResult>> runnableSolverTask, final Consumer<ISolvableTaskStatus> statusUpdater, final Duration timeout, final boolean messaging) {
    return CompletableFuture.supplyAsync(() -> CollectionSequence.fromCollection(AsyncSolverTaskExecutor.runSolverTask(readAccess(forWho), statusUpdater, runnableSolverTask, messaging, forWho, timeout)).toList(), executorPhase2);
  }

  public static CompletableFuture<List<IResult>> submitISolvable(final SNode solvable, Duration timeout, boolean messaging) {
    return submitISolvable(solvable, timeout, messaging, writeAccess(solvable), readAccess(solvable));
  }

  /**
   * Run the computation behind an ISolvable in async mode.
   * 
   * @param solvable the item for which something can be computed
   * @param solverTaskCallback is called after the SolverTask is created for side effects
   * @param timeout max run time
   * @param messaging sould errors be highlighted
   * @return a list of results originating from the computation
   */
  public static CompletableFuture<List<IResult>> submitISolvable(final SNode solvable, java.util.function.Consumer<SNode> solverTaskCallback, Duration timeout, boolean messaging) {
    return submitISolvable(solvable, solverTaskCallback, timeout, messaging, writeAccess(solvable), readAccess(solvable));
  }

  public static CompletableFuture<List<IResult>> submitISolvable(final SNode solvable, Duration timeout, boolean messaging, IExecEnv<ITask> solverCreationEnv, IExecEnv<Collection<IResult>> solverRunEnv) {

    return submitISolvable(solvable, new java.util.function.Consumer<SNode>() {
      @Override
      public void accept(SNode p1) {
      }
    }, timeout, messaging, solverCreationEnv, solverRunEnv);
  }

  /**
   * Run the computation behind an ISolvable in async mode.
   * 
   * @param solvable the item for which something can be computed
   * @param solverTaskCallback is called after the SolverTask is created for side effects
   * @param timeout max run time
   * @param messaging sould errors be highlighted
   * @param solverCreationEnv Around-Environment where SolverTask creation is run
   * @return a list of results originating from the computation
   */
  public synchronized static CompletableFuture<List<IResult>> submitISolvable(final SNode solvable, java.util.function.Consumer<SNode> solverTaskCallback, final Duration timeout, final boolean messaging, final IExecEnv<ITask> solverCreationEnv, final IExecEnv<Collection<IResult>> solverRunEnv) {
    final Consumer<ISolvableTaskStatus> statusUpdater = AsyncSolverTaskExecutor.makeStatusUpdater(solvable);
    CancelableSupplier<ITask> solvableJob = AsyncSolverTaskExecutor.wrapSolvable(solvable, solverTaskCallback, statusUpdater);

    // Any other task before is set cancelled as the current solvable is more recent.
    cancelPriorInactiveTask(solvable, solvableJob);

    // Phase1 creates the solver task
    CompletableFuture<ITask> phase1 = scheduleTaskCreation(solverCreationEnv, solvableJob);

    // Phase2 runs the solverTask
    return phase1.thenApplyAsync((ITask task) -> CollectionSequence.fromCollection(runSolverTask(solverRunEnv, statusUpdater, task, messaging, solvable, timeout)).toList(), executorPhase2);
  }

  private static void cancelPriorInactiveTask(final SNode solvable, CancelableSupplier<ITask> solvableJob) {
    Optional.ofNullable(nodeToQueuedTask.put(solvable, solvableJob)).ifPresent((CancelableSupplier<?> priorTask) -> priorTask.cancel());
  }

  private static CompletableFuture<ITask> scheduleTaskCreation(final IExecEnv<ITask> env, final CancelableSupplier<ITask> solvableJob) {
    return CompletableFuture.supplyAsync(() -> env.runWithin(solvableJob), executorPhase1);
  }

  private static CancelableSupplier<ITask> wrapSolvable(final SNode solvable, java.util.function.Consumer<SNode> solverTaskCallback, Consumer<ISolvableTaskStatus> statusUpdater) {

    // The two nested Suppliers encapsulate the creation of a SolverTask and then its execution
    return new CancelableSupplier<ITask>(new SolverTaskCreator(statusUpdater, solvable, solverTaskCallback), statusUpdater, CancelledTask.instance());
  }


  private static void addResultsToMessageBuffer(final Collection<IResult> results, final SNode forWho) {
    final Wrappers._T<List<MessageUI>> messages = new Wrappers._T<List<MessageUI>>(Collections.emptyList());
    if (CollectionSequence.fromCollection(results).isNotEmpty() && SNodeOperations.getModel(forWho) != null) {
      SNodeOperations.getModel(forWho).getRepository().getModelAccess().runReadAction(() -> messages.value = CollectionSequence.fromCollection(results).where((it) -> !(it.isOk())).translate((it) -> messageOf(it)).toList());
    }
    messageBuffer.add(messages.value);
  }

  public static Tuples._2<Long, Collection<MessageUI>> nodesMessages(SNode node) {
    return messageBuffer.nodesMessages(node);
  }

  public static long changeCount() {
    return messageBuffer.changeCount();
  }

  private static void ifFailureThenUpdateStatus(final Consumer<ISolvableTaskStatus> statusUpdater, Collection<IResult> iresult) {
    Optional<IResult> timeoutResult = iresult.stream().filter((IResult r) -> r.messageType().equals(IResult.MessageType.Timeout)).findAny();
    if (timeoutResult.isPresent()) {
      statusUpdater.consume(ISolvableTaskStatus.Timeout);
    }
    Optional<IResult> errorResult = iresult.stream().filter((IResult r) -> r.messageType().equals(IResult.MessageType.Error)).findAny();
    if (errorResult.isPresent()) {
      statusUpdater.consume(ISolvableTaskStatus.Failure);
    }
  }

  private static Optional<IResult> handleExplicitThrowable(Throwable t, final Consumer<ISolvableTaskStatus> statusUpdater, final SNode forWho, Duration timeout) {
    if (t != null) {
      String msg = (!(StringUtils.isBlank(t.getMessage())) ? t.getMessage() : (t instanceof TimeoutException ? "Timed out of " + timeout + " exceeded at " + LocalDateTime.now().format(formatter) : "Unknown"));
      if (t instanceof TimeoutException) {
        statusUpdater.consume(ISolvableTaskStatus.Timeout);
      } else {
        statusUpdater.consume(ISolvableTaskStatus.Failure);
      }
      IResult errorResult = IResult.make(IResult.MessageType.Error, "Exception: " + msg, Sequence.<SNode>singleton(forWho), null);
      if (LOG.isInfoLevel()) {
        LOG.info(msg, t);
      }
      return Optional.of(errorResult);
    }
    return Optional.empty();
  }

  public static Consumer<ISolvableTaskStatus> makeStatusUpdater(final SNode solvable) {
    final Consumer<TaskEntity> obervationConsumer = observationConsumer();
    final LocalDateTime now = LocalDateTime.now();
    return (ISolvableTaskStatus status) -> {
      TaskEntity taskEntity = TaskEntity.fromISolvable(solvable, status, now);
      taskEntity.setTimeStamp(LocalDateTime.now());
      obervationConsumer.consume(taskEntity);
    };
  }


  private static Collection<IResult> runSolverTask(IExecEnv<Collection<IResult>> solverRunEnv, final Consumer<ISolvableTaskStatus> statusUpdater, final Supplier<? extends Collection<IResult>> runnableSolverTask, boolean messaging, SNode solvable, Duration timeout) {
    try {
      statusUpdater.consume(ISolvableTaskStatus.Running);
      Collection<IResult> results = solverRunEnv.runWithin(() -> runnableSolverTask.get());
      statusUpdater.consume(ISolvableTaskStatus.Done);
      AsyncSolverTaskExecutor.ifFailureThenUpdateStatus(statusUpdater, results);
      if (messaging) {
        AsyncSolverTaskExecutor.addResultsToMessageBuffer(results, solvable);
      }
      return results;
    } catch (Throwable t) {
      t.printStackTrace();
      Optional<IResult> exceptionResult = AsyncSolverTaskExecutor.handleExplicitThrowable(t, statusUpdater, solvable, timeout);
      if (!(exceptionResult.isEmpty()) && messaging) {
        messageBuffer.add(AsyncSolverTaskExecutor.messageOf(exceptionResult.get()));
      }
    }
    return Collections.emptyList();
  }


  private static List<MessageUI> messageOf(final IResult iresult) {
    return Sequence.fromIterable((Sequence.fromIterable(iresult.targetNodes()).select((it) -> {
      String errorMessage = ((String) iresult.getErrorMessage());
      return new MessageUI(iresult.messageType(), it, errorMessage);
    }))).toList();
  }

  private static ThreadFactory threadFactory() {
    return new ThreadFactory() {
      @Override
      public Thread newThread(Runnable p1) {
        Thread newThread = new Thread(p1);
        newThread.setPriority(Thread.MIN_PRIORITY);
        newThread.setDaemon(true);
        return newThread;
      }
    };
  }

  public interface IExecEnv<T> {
    T runWithin(Callable<T> executionCode);
  }

  public static <Y> IExecEnv<Y> makeWriteAcccessEnv(final SRepository repository) {
    return new IExecEnv<Y>() {
      @Override
      public Y runWithin(Callable<Y> executionCode) {
        return AsyncUtil.callWithWriteAction(executionCode, repository);
      }
    };
  }

  public static <Y> IExecEnv<Y> makeReadAcccessEnv(final SRepository repository) {
    return new IExecEnv<Y>() {
      @Override
      public Y runWithin(Callable<Y> executionCode) {
        return AsyncUtil.callWithReadAction(executionCode, repository);
      }
    };
  }


  private static IExecEnv<Collection<IResult>> readAccess(final SNode forWho) {
    IExecEnv<Collection<IResult>> solverRunEnv = AsyncSolverTaskExecutor.<Collection<IResult>>makeReadAcccessEnv(forWho.getModel().getRepository());

    return solverRunEnv;
  }

  private static IExecEnv<ITask> writeAccess(final SNode solvable) {
    return AsyncSolverTaskExecutor.<ITask>makeWriteAcccessEnv(solvable.getModel().getRepository());
  }
}
