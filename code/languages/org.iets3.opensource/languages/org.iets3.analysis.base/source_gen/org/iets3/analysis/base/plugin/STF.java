package org.iets3.analysis.base.plugin;

/*Generated by MPS */

import jetbrains.mps.logging.Logger;
import java.util.Comparator;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.structure.ExtensionPoint;
import java.util.Optional;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.Collections;
import java.util.HashSet;
import com.google.common.collect.Sets;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import com.google.common.collect.Lists;
import java.util.Set;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SProperty;

public class STF {
  private static final Logger LOG = Logger.getLogger(STF.class);

  /**
   * The more specialized (more subconcept) the greater the concept is considered, the more to the right
   * in a sorted list it can be found
   */
  private static Comparator<SAbstractConcept> conceptsComp = (a, b) -> {
    if (a.equals(b)) {
      return 0;
    }
    return (a.isSubConceptOf(b) ? 1 : -1);
  };

  public static SNode createSolverTask(final SNode n, final String name) {
    try {

      List<SortableSolverTaskFactory> sortableSTFs = Sequence.fromIterable(new ExtensionPoint<SolverTaskFactory>("org.iets3.analysis.base.solverfactories").getObjects()).select((stf) -> new SortableSolverTaskFactory(conceptRepresentative(stf, n), stf)).where((it) -> it.concept != null).toList();

      Optional<SortableSolverTaskFactory> stfMaybe = sortableSTFs.stream().max((p1, p2) -> p1.compareTo(p2));

      return stfMaybe.map((sstf) -> sstf.stf.createSolverTask(n, name)).orElseGet(() -> handleMissingSTF(n));
    } catch (TaskCreationException ex) {
      return createErrorTask(ex);
    }
  }

  private static SNode handleMissingSTF(SNode n) {
    String msg = "STF ERROR: No SolverTaskFactory found for concept " + SNodeOperations.getConcept(n);
    if (LOG.isErrorLevel()) {
      LOG.error(msg);
    }
    return createErrorSolverTask_vsy_a2a5(Collections.singleton(createErrorMessage_vsy_a0a0a0c0f(msg)));
  }

  private static SAbstractConcept conceptRepresentative(SolverTaskFactory stf, SNode n) {
    return mostSpecializedConcept(relevantConceptsForSTF(superConceptsOf(n), stf));
  }

  private static HashSet<SAbstractConcept> superConceptsOf(SNode n) {
    final HashSet<SAbstractConcept> superConceptsAll = Sets.newHashSet(SConceptOperations.getAllSuperConcepts((SNodeOperations.getConcept(n)), false));
    SetSequence.fromSet(superConceptsAll).addElement(SNodeOperations.getConcept(n));
    return superConceptsAll;
  }

  private static SAbstractConcept mostSpecializedConcept(Iterable<SAbstractConcept> applicableConcepts) {
    return Lists.newArrayList(applicableConcepts).stream().max(conceptsComp).orElse(null);
  }

  private static Sets.SetView<SAbstractConcept> relevantConceptsForSTF(Set<SAbstractConcept> superConceptsAll, SolverTaskFactory it) {
    return Sets.intersection(superConceptsAll, Sets.newHashSet(it.applicableConcepts()));
  }

  public static SNode createErrorTask(TaskCreationException ex) {
    SNode errorTask = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xdb8bd0353f5141d8L, 0x8fed954c202d18beL, 0xf5136bc1ff76858L, "org.iets3.analysis.base.structure.ErrorSolverTask"));
    ListSequence.fromList(SLinkOperations.getChildren(errorTask, LINKS.errors$rx2e)).addSequence(Sequence.fromIterable(ex.getMessages()).select((it) -> createErrorMessage_vsy_a0a0a0a0b0p(it)));
    return errorTask;
  }

  /**
   * 
   * @deprecated 
   */
  @Deprecated
  public static boolean areFactoriesAvailable() {
    ExtensionPoint<SolverTaskFactory> ep = new ExtensionPoint<SolverTaskFactory>("org.iets3.analysis.base.solverfactories");
    return Sequence.fromIterable(ep.getObjects()).count() > 0;
  }

  private static class SortableSolverTaskFactory implements Comparable<SortableSolverTaskFactory> {

    public final SolverTaskFactory stf;
    public final SAbstractConcept concept;

    public SortableSolverTaskFactory(SAbstractConcept concept, SolverTaskFactory stf) {
      this.concept = concept;
      this.stf = stf;
    }

    /**
     * First the priority decides, then
     * the more specialized (more subconcept). The greater the concept is considered, the more to the right
     * in a sorted list it can be found
     * 
     * 
     * @param other  
     * @return  
     */
    @Override
    public int compareTo(SortableSolverTaskFactory other) {
      return (this.stf.priority() < other.stf.priority() ? -1 : (this.stf.priority() > other.stf.priority() ? 1 : conceptsComp.compare(this.concept, other.concept)));
    }
  }
  private static SNode createErrorSolverTask_vsy_a2a5(Iterable<? extends SNode> p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.ErrorSolverTask$wO);
    n0.forChild(LINKS.errors$rx2e).initNodeList(p0, CONCEPTS.ErrorMessage$zn);
    return n0.getResult();
  }
  private static SNode createErrorMessage_vsy_a0a0a0c0f(String p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.ErrorMessage$zn);
    n0.setProperty(PROPS.msg$2JDK, p0);
    return n0.getResult();
  }
  private static SNode createErrorMessage_vsy_a0a0a0a0b0p(String p0) {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.ErrorMessage$zn);
    n0.setProperty(PROPS.msg$2JDK, p0);
    return n0.getResult();
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink errors$rx2e = MetaAdapterFactory.getContainmentLink(0xdb8bd0353f5141d8L, 0x8fed954c202d18beL, 0xf5136bc1ff76858L, 0xf5136bc1ff78cfeL, "errors");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept ErrorSolverTask$wO = MetaAdapterFactory.getConcept(0xdb8bd0353f5141d8L, 0x8fed954c202d18beL, 0xf5136bc1ff76858L, "org.iets3.analysis.base.structure.ErrorSolverTask");
    /*package*/ static final SConcept ErrorMessage$zn = MetaAdapterFactory.getConcept(0xdb8bd0353f5141d8L, 0x8fed954c202d18beL, 0xf5136bc1ff78cdbL, "org.iets3.analysis.base.structure.ErrorMessage");
  }

  private static final class PROPS {
    /*package*/ static final SProperty msg$2JDK = MetaAdapterFactory.getProperty(0xdb8bd0353f5141d8L, 0x8fed954c202d18beL, 0xf5136bc1ff78cdbL, 0xf5136bc1ff78cdcL, "msg");
  }
}
