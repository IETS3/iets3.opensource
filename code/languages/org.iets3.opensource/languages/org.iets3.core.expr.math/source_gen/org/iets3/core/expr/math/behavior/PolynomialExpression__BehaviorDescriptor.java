package org.iets3.core.expr.math.behavior;

/*Generated by MPS */

import jetbrains.mps.core.aspects.behaviour.BaseBHDescriptor;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.core.aspects.behaviour.api.SMethod;
import java.util.List;
import org.iets3.core.expr.math.plugin.PolynomialExpressionPart;
import jetbrains.mps.core.aspects.behaviour.SMethodBuilder;
import jetbrains.mps.core.aspects.behaviour.SJavaCompoundTypeImpl;
import jetbrains.mps.core.aspects.behaviour.AccessPrivileges;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Arrays;
import org.jetbrains.annotations.NotNull;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.LinkedList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.iets3.core.expr.simpleTypes.behavior.NumberLiteral__BehaviorDescriptor;
import java.util.Deque;
import jetbrains.mps.internal.collections.runtime.LinkedListSequence;
import org.iets3.core.expr.math.plugin.PolynomialExpressionUtil;
import jetbrains.mps.core.aspects.behaviour.api.SConstructor;
import org.jetbrains.annotations.Nullable;
import jetbrains.mps.core.aspects.behaviour.api.BHMethodNotFoundException;
import jetbrains.mps.smodel.builder.SNodeBuilder;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SConcept;

public final class PolynomialExpression__BehaviorDescriptor extends BaseBHDescriptor {
  private static final SAbstractConcept CONCEPT = MetaAdapterFactory.getConcept(0x6fadc44e69c24a4aL, 0x9d167ebf5f8d3ba0L, 0x3a00468f8b639e38L, "org.iets3.core.expr.math.structure.PolynomialExpression");

  public static final SMethod<List<PolynomialExpressionPart>> partsOfPolynomial_id3iWt5egBKW6 = new SMethodBuilder<List<PolynomialExpressionPart>>(new SJavaCompoundTypeImpl(List.class)).name("partsOfPolynomial").modifiers(0, AccessPrivileges.PUBLIC).concept(CONCEPT).baseMethodId(3800040087851306758L).languageId(0x9d167ebf5f8d3ba0L, 0x6fadc44e69c24a4aL).build2();
  /*package*/ static final SMethod<Boolean> minusBefore_id4wFKMWZf6e2 = new SMethodBuilder<Boolean>(new SJavaCompoundTypeImpl(Boolean.TYPE)).name("minusBefore").modifiers(0, AccessPrivileges.PRIVATE).concept(CONCEPT).baseMethodId(5200464802421171074L).languageId(0x9d167ebf5f8d3ba0L, 0x6fadc44e69c24a4aL).build2(SMethodBuilder.createJavaParameter((Class<List<SNode>>) ((Class) Object.class), ""), SMethodBuilder.createJavaParameter(Integer.TYPE, ""));
  public static final SMethod<List<SNode>> polynomFlattened_id3C0hCYbWgi0 = new SMethodBuilder<List<SNode>>(new SJavaCompoundTypeImpl((Class<List<SNode>>) ((Class) Object.class))).name("polynomFlattened").modifiers(0, AccessPrivileges.PUBLIC).concept(CONCEPT).baseMethodId(4179418036541916288L).languageId(0x9d167ebf5f8d3ba0L, 0x6fadc44e69c24a4aL).build2();

  private static final List<SMethod<?>> BH_METHODS = Arrays.<SMethod<?>>asList(partsOfPolynomial_id3iWt5egBKW6, minusBefore_id4wFKMWZf6e2, polynomFlattened_id3C0hCYbWgi0);

  private static void ___init___(@NotNull SNode __thisNode__) {
    SLinkOperations.setTarget(ListSequence.fromList(SLinkOperations.getChildren(__thisNode__, LINKS.args$8wKH)).getElement(0), LINKS.type$8xXf, createRealType_5d574i_a0a0a0());
  }

  /*package*/ static List<PolynomialExpressionPart> partsOfPolynomial_id3iWt5egBKW6(@NotNull SNode __thisNode__) {
    List<PolynomialExpressionPart> result = new LinkedList<PolynomialExpressionPart>();
    List<SNode> polynomFlattened = PolynomialExpression__BehaviorDescriptor.polynomFlattened_id3C0hCYbWgi0.invoke(__thisNode__);

    for (int i = 0; i < ListSequence.fromList(polynomFlattened).count(); i++) {
      {
        final SNode mulExpression = ListSequence.fromList(polynomFlattened).getElement(i);
        if (SNodeOperations.isInstanceOf(mulExpression, CONCEPTS.MulExpression$iC)) {
          Double coefficient = Double.valueOf(NumberLiteral__BehaviorDescriptor.valueWithDotInsteadOfComma_id2oUyrt$QPvb.invoke(SNodeOperations.cast(SLinkOperations.getTarget(mulExpression, LINKS.left$zxUa), CONCEPTS.NumberLiteral$wE)));
          Integer exponent = Integer.valueOf(NumberLiteral__BehaviorDescriptor.valueWithDotInsteadOfComma_id2oUyrt$QPvb.invoke(SNodeOperations.cast(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(mulExpression, LINKS.right$zBjx), CONCEPTS.PowerExpression$l7), LINKS.exponent$uVP8), CONCEPTS.NumberLiteral$wE)));
          Double adjustedCoefficient = (((boolean) PolynomialExpression__BehaviorDescriptor.minusBefore_id4wFKMWZf6e2.invokeSpecial(__thisNode__, polynomFlattened, ((int) i))) ? -coefficient : coefficient);
          result.add(new PolynomialExpressionPart(exponent, adjustedCoefficient));
        }
      }
    }
    return result;
  }
  /*package*/ static boolean minusBefore_id4wFKMWZf6e2(@NotNull SNode __thisNode__, List<SNode> expressions, int i) {
    return i > 0 && SNodeOperations.isInstanceOf(ListSequence.fromList(expressions).getElement(i), CONCEPTS.MinusExpression$6z);
  }
  /*package*/ static List<SNode> polynomFlattened_id3C0hCYbWgi0(@NotNull final SNode __thisNode__) {
    Deque<SNode> result = LinkedListSequence.fromLinkedList(new LinkedList<SNode>());
    PolynomialExpressionUtil.polynomAsFlattendList(SLinkOperations.getTarget(__thisNode__, LINKS.expression$T2aj), result);
    return LinkedListSequence.fromLinkedListNew(result).select((it) -> PolynomialExpressionUtil.mapToPowerExpressions(it, ListSequence.fromList(SLinkOperations.getChildren(__thisNode__, LINKS.args$8wKH)).first())).toList();
  }

  /*package*/ PolynomialExpression__BehaviorDescriptor() {
  }

  @Override
  protected void initNode(@NotNull SNode node, @NotNull SConstructor constructor, @Nullable Object[] parameters) {
    ___init___(node);
  }

  @Override
  protected <T> T invokeSpecial0(@NotNull SNode node, @NotNull SMethod<T> method, @Nullable Object[] parameters) {
    int methodIndex = BH_METHODS.indexOf(method);
    if (methodIndex < 0) {
      throw new BHMethodNotFoundException(this, method);
    }
    switch (methodIndex) {
      case 0:
        return (T) ((List<PolynomialExpressionPart>) partsOfPolynomial_id3iWt5egBKW6(node));
      case 1:
        return (T) ((Boolean) minusBefore_id4wFKMWZf6e2(node, (List<SNode>) parameters[0], ((int) (Integer) parameters[1])));
      case 2:
        return (T) ((List<SNode>) polynomFlattened_id3C0hCYbWgi0(node));
      default:
        throw new BHMethodNotFoundException(this, method);
    }
  }

  @Override
  protected <T> T invokeSpecial0(@NotNull SAbstractConcept concept, @NotNull SMethod<T> method, @Nullable Object[] parameters) {
    int methodIndex = BH_METHODS.indexOf(method);
    if (methodIndex < 0) {
      throw new BHMethodNotFoundException(this, method);
    }
    switch (methodIndex) {
      default:
        throw new BHMethodNotFoundException(this, method);
    }
  }

  @NotNull
  @Override
  public List<SMethod<?>> getDeclaredMethods() {
    return BH_METHODS;
  }

  @NotNull
  @Override
  public SAbstractConcept getConcept() {
    return CONCEPT;
  }
  private static SNode createRealType_5d574i_a0a0a0() {
    SNodeBuilder n0 = new SNodeBuilder().init(CONCEPTS.RealType$36);
    return n0.getResult();
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink args$8wKH = MetaAdapterFactory.getContainmentLink(0x9464fa065ab9409bL, 0x927464ab29588457L, 0x68d69d36ba520706L, 0x68d69d36ba520707L, "args");
    /*package*/ static final SContainmentLink type$8xXf = MetaAdapterFactory.getContainmentLink(0x9464fa065ab9409bL, 0x927464ab29588457L, 0x68d69d36ba520709L, 0x68d69d36ba52070cL, "type");
    /*package*/ static final SContainmentLink left$zxUa = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86c99c15L, 0x46ff3b3d86c99c16L, "left");
    /*package*/ static final SContainmentLink right$zBjx = MetaAdapterFactory.getContainmentLink(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86c99c15L, 0x46ff3b3d86c99c18L, "right");
    /*package*/ static final SContainmentLink exponent$uVP8 = MetaAdapterFactory.getContainmentLink(0x6fadc44e69c24a4aL, 0x9d167ebf5f8d3ba0L, 0x449e19d04e9c6144L, 0x46c15b39e5605f2fL, "exponent");
    /*package*/ static final SContainmentLink expression$T2aj = MetaAdapterFactory.getContainmentLink(0x9464fa065ab9409bL, 0x927464ab29588457L, 0x68d69d36ba520706L, 0x68d69d36ba520b43L, "expression");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept MulExpression$iC = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86c9a56fL, "org.iets3.core.expr.base.structure.MulExpression");
    /*package*/ static final SConcept NumberLiteral$wE = MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x46ff3b3d86d0e6daL, "org.iets3.core.expr.simpleTypes.structure.NumberLiteral");
    /*package*/ static final SConcept PowerExpression$l7 = MetaAdapterFactory.getConcept(0x6fadc44e69c24a4aL, 0x9d167ebf5f8d3ba0L, 0x449e19d04e9c6144L, "org.iets3.core.expr.math.structure.PowerExpression");
    /*package*/ static final SConcept MinusExpression$6z = MetaAdapterFactory.getConcept(0xcfaa4966b7d54b69L, 0xb66a309a6e1a7290L, 0x46ff3b3d86cac5a5L, "org.iets3.core.expr.base.structure.MinusExpression");
    /*package*/ static final SConcept RealType$36 = MetaAdapterFactory.getConcept(0x6b277d9ad52d416fL, 0xa2091919bd737f50L, 0x46ff3b3d86d0e74cL, "org.iets3.core.expr.simpleTypes.structure.RealType");
  }
}
