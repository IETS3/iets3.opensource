package org.iets3.core.expr.lambda.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import com.mbeddr.mpsutil.interpreter.rt.IContext;
import com.mbeddr.mpsutil.interpreter.rt.ICoverageAnalyzer;
import java.util.List;
import com.mbeddr.mpsutil.interpreter.rt.ComputationTrace;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;

public class ComposedFunction extends ExecutableValue {

  public static SNode MONADVAL = SConceptOperations.createNewNode(MetaAdapterFactory.getConcept(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x10802efe25aL, "jetbrains.mps.lang.core.structure.BaseConcept"));

  private ExecutableValue left;
  private ExecutableValue right;
  private SNode compose;

  public ComposedFunction(SNode comp, ExecutableValue l, ExecutableValue r, IContext ctx, ICoverageAnalyzer coverage) {
    left = l;
    right = r;
    compose = comp;
  }

  @Override
  public String toString() {
    return left.toString() + " :(): " + right.toString();
  }

  @Override
  public Object executeEvaluated(List<Object> evaluatedArgs, IContext context, ICoverageAnalyzer coverage, ComputationTrace contextTrace, boolean stopOnStop) {
    ComputationTrace ttt = contextTrace.newChild(this.compose, true, ":():");
    Object resOfFirst = right.executeEvaluated(evaluatedArgs, context, coverage, ttt, false);
    List<Object> args = ListSequence.fromList(new ArrayList<Object>());
    ListSequence.fromList(args).addElement(resOfFirst);
    return left.executeEvaluated(args, context, coverage, ttt, false);
  }

  @Override
  public ExecutableValue copy(IContext ctx, ICoverageAnalyzer coverage) {
    ComposedFunction copy = new ComposedFunction(this.compose, this.left, this.right, ctx, coverage);
    ListSequence.fromList(copy.boundValues).addSequence(ListSequence.fromList(this.boundValues));
    return copy;
  }
}
