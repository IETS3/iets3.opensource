package org.iets3.variability.artifacts.baseline.plugin;

/*Generated by MPS */

import java.util.Optional;
import jetbrains.mps.project.AbstractModule;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.project.MPSProject;
import jetbrains.mps.extapi.persistence.CopyNotSupportedException;
import java.util.function.Consumer;
import java.util.List;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import java.util.Objects;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import org.iets3.variability.artifacts.baseline.behavior.IVariantBaselineConfigItem__BehaviorDescriptor;
import org.iets3.variability.artifacts.base.plugin.IArtifactAlgorithms;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import org.iets3.variability.artifacts.base.behavior.IVariabilityAwareArtifact__BehaviorDescriptor;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class VariantBaselineUtil {

  public static Optional<AbstractModule> cloneThenFilter(final SNode hpi, MPSProject project, String virtualFolder, AbstractModule module, String suffix) throws CopyNotSupportedException {
    // ensure that module is correctly persisted as moduleCloner operates on the file system
    module.save();

    // clone module
    ModuleClonerFacade moduleCloner = new ModuleClonerFacade(project, virtualFolder, module, suffix);
    Optional<AbstractModule> clonedModule = moduleCloner.copyClone();

    // do variability filtering
    clonedModule.ifPresent(new Consumer<AbstractModule>() {
      public void accept(AbstractModule module) {
        run(hpi, module);
      }
    });
    return clonedModule;
  }

  private static void run(final SNode hpi, AbstractModule clonedModule) {
    List<SModel> models = clonedModule.getModels();
    List<SModel> allModels = models;
    Iterable<SNode> hundredPercentConfigs = ListSequence.fromList(allModels).translate((it) -> SModelOperations.nodes(it, CONCEPTS.VariantBaselineConfig$KI));

    // find config item in cloned module
    assert Sequence.fromIterable(hundredPercentConfigs).count() <= 1 : "Only one " + CONCEPTS.IVariantBaselineConfigItem$SB.getName() + " in module allowed.";
    if (Sequence.fromIterable(hundredPercentConfigs).isEmpty()) {
      return;
    }
    SNode hundredPercentConfig = Sequence.fromIterable(hundredPercentConfigs).first();
    SNode hpiInClone = ListSequence.fromList(SLinkOperations.getChildren(hundredPercentConfig, LINKS.items$dN3Z)).findFirst((it) -> Objects.equals(it.getNodeId(), hpi.getNodeId()));
    assert hpiInClone != null : "Could not find config " + BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(hpi) + " in cloned module.";

    filterVariability(hpiInClone, allModels);

    IVariantBaselineConfigItem__BehaviorDescriptor.postprocess_id1xsXReQTuZ$.invoke(hpi, allModels);
  }

  private static void filterVariability(SNode baselineItem, List<SModel> allModels) {
    IArtifactAlgorithms.instance().filterInstantiator().filterInPlace(IVariantBaselineConfigItem__BehaviorDescriptor.filteringParameters_id5bEmt06_eiH.invoke(baselineItem));
    removeUnconsideredArtifacts(allModels);
  }

  private static void removeUnconsideredArtifacts(List<SModel> allModels) {
    removeRemainingVariabilityAwareArtifacts(allModels);

    removeVariabilityModels(allModels);

    removeAnyVariantBaselineConfigs(allModels);
  }

  private static void removeAnyVariantBaselineConfigs(List<SModel> allModels) {
    ListSequence.fromList(allModels).translate((it) -> SModelOperations.nodes(it, CONCEPTS.VariantBaselineConfig$KI)).visitAll((it) -> SNodeOperations.deleteNode(it));
  }

  private static void removeVariabilityModels(List<SModel> allModels) {
    ListSequence.fromList(allModels).translate((it) -> SModelOperations.nodes(it, CONCEPTS.IVariabilityContainer$Cw)).visitAll((it) -> SNodeOperations.deleteNode(it));
  }

  private static void removeRemainingVariabilityAwareArtifacts(List<SModel> allModels) {
    ListSequence.fromList(allModels).translate((model) -> SModelOperations.nodes(model, CONCEPTS.IVariabilityAwareArtifact$qo)).visitAll((ivaa) -> SNodeOperations.deleteNode(IVariabilityAwareArtifact__BehaviorDescriptor.artifactRoot_id3q2wVeorTKs.invoke(ivaa)));
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept VariantBaselineConfig$KI = MetaAdapterFactory.getConcept(0xbad8e421fc944104L, 0x8c1e6fc9d2dccf07L, 0x4eccec556ce7dcfeL, "org.iets3.variability.artifacts.baseline.structure.VariantBaselineConfig");
    /*package*/ static final SInterfaceConcept IVariantBaselineConfigItem$SB = MetaAdapterFactory.getInterfaceConcept(0xbad8e421fc944104L, 0x8c1e6fc9d2dccf07L, 0x4ca06df4e4c16866L, "org.iets3.variability.artifacts.baseline.structure.IVariantBaselineConfigItem");
    /*package*/ static final SInterfaceConcept IVariabilityContainer$Cw = MetaAdapterFactory.getInterfaceConcept(0x9b66c5c938bf4315L, 0xa96f9f4e212c69cbL, 0x2094847e8426ce97L, "org.iets3.variability.base.structure.IVariabilityContainer");
    /*package*/ static final SInterfaceConcept IVariabilityAwareArtifact$qo = MetaAdapterFactory.getInterfaceConcept(0xf08835038eaa4bc8L, 0x8846eb63220ab1ddL, 0x716b3738b4b28e4bL, "org.iets3.variability.artifacts.base.structure.IVariabilityAwareArtifact");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink items$dN3Z = MetaAdapterFactory.getContainmentLink(0xbad8e421fc944104L, 0x8c1e6fc9d2dccf07L, 0x4eccec556ce7dcfeL, 0x4eccec556d16be85L, "items");
  }
}
