package org.iets3.core.trace.plugin;

/*Generated by MPS */

import java.util.List;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Objects;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.iets3.core.trace.behavior.ITrace__BehaviorDescriptor;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.structure.behavior.AbstractConceptDeclaration__BehaviorDescriptor;
import jetbrains.mps.ide.findusages.model.SearchResults;
import jetbrains.mps.ide.findusages.view.FindUtils;
import jetbrains.mps.progress.EmptyProgressMonitor;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import org.jetbrains.mps.openapi.language.SInterfaceConcept;

public class GenericTraceHelper {

  public static List<SNode> findTraceResult(Iterable<SNode> elemsInScope, final SNode traceKind, final SNode from, final SNode to) {
    Iterable<SNode> foundITraces = findElements(elemsInScope);
    if ((traceKind != null)) {
      // pre-filter for kind
      foundITraces = Sequence.fromIterable(foundITraces).where((it) -> Objects.equals(SNodeOperations.getConcept(SLinkOperations.getTarget(it, LINKS.traceKind$_UHM)), SNodeOperations.getConcept(traceKind)));
    }
    if (from != null) {
      // prefilter for source
      foundITraces = Sequence.fromIterable(foundITraces).where((it) -> SNodeOperations.getConcept(ITrace__BehaviorDescriptor.getTraceSource_id7qN5a9Pfhlm.invoke(it)).isSubConceptOf(SNodeOperations.asSConcept(from)));
    }
    if (to != null) {
      // prefilter for targets
      foundITraces = Sequence.fromIterable(foundITraces).where((it) -> {
        return Sequence.fromIterable(SLinkOperations.collect(SLinkOperations.getChildren(it, LINKS.traceTarget$A1Zh), LINKS.traceTarget$Q_qM)).where(new _FunctionTypes._return_P1_E0<Boolean, SNode>() {
          public Boolean invoke(SNode it) {
            return SNodeOperations.getConcept(it).isSubConceptOf(SNodeOperations.asSConcept(to));
          }
        }).isNotEmpty();
      });
    }
    return Sequence.fromIterable(foundITraces).toList();
  }

  public static List<SNode> findDefaultTraces(Iterable<SNode> elemsInScope) {
    return findTraceResult(elemsInScope, null, null, null);
  }

  public static List<SNode> findTracesOfKind(Iterable<SNode> elemsInScope, SNode kind) {
    return findTraceResult(elemsInScope, kind, null, null);
  }

  public static List<SNode> findTracesTo(Iterable<SNode> elemsInScope, SNode to) {
    return findTraceResult(elemsInScope, null, null, to);
  }

  public static List<SNode> findTracesToWithKind(Iterable<SNode> elemsInScope, SNode to, SNode kind) {
    return findTraceResult(elemsInScope, kind, null, to);
  }

  public static List<SNode> findTracesFrom(Iterable<SNode> elemsInScope, SNode from) {
    return findTraceResult(elemsInScope, null, from, null);
  }

  public static List<SNode> findTracesFromWithKind(Iterable<SNode> elemsInScope, SNode from, SNode kind) {
    return findTraceResult(elemsInScope, kind, from, null);
  }

  public static List<SNode> findTracesFromToWithKind(Iterable<SNode> elemsInScope, SNode from, SNode to, SNode kind) {
    return findTraceResult(elemsInScope, kind, from, to);
  }

  public static List<SNode> findTracesFromTo(Iterable<SNode> elemsInScope, SNode from, SNode to) {
    return findTraceResult(elemsInScope, null, from, to);
  }

  private static Iterable<SNode> findElements(Iterable<SNode> s) {
    return ((Iterable<SNode>) Sequence.fromIterable(s).where((it) -> SNodeOperations.isInstanceOf(it, CONCEPTS.ITrace$ef)));
  }


  public static Iterable<SNode> getUntracedElements(Iterable<SNode> elemsInScope, SNode conceptOfElement, SNode kind) {
    List<SNode> resultList = Sequence.fromIterable(getAllUntracedElements(elemsInScope, conceptOfElement)).toList();
    if ((kind != null)) {
      ListSequence.fromList(resultList).addSequence(ListSequence.fromList(Sequence.fromIterable(getElementsWithoutTracekind(elemsInScope, kind)).toList()));
    }
    return resultList;
  }

  public static Iterable<SNode> getAllUntracedElements(Iterable<SNode> elemsInScope, final SNode conceptOfElement) {
    return Sequence.fromIterable(elemsInScope).where((it) -> (boolean) AbstractConceptDeclaration__BehaviorDescriptor.isSubconceptOf_id73yVtVlWOga.invoke(SNodeOperations.asNode(SNodeOperations.getConcept(it)), conceptOfElement)).where((it) -> {
      SearchResults results = FindUtils.getSearchResults(new EmptyProgressMonitor(), it, null, "org.iets3.core.trace.findUsages.FindTraces_Finder");
      return results.getSearchResults2().isEmpty();
    });
  }

  public static Iterable<SNode> getElementsWithoutTracekind(Iterable<SNode> elemsInScope, final SNode kind) {
    Iterable<SNode> filteredTraces = ListSequence.fromList(findDefaultTraces(elemsInScope)).where((it) -> !(Objects.equals(SNodeOperations.getConcept(SLinkOperations.getTarget(it, LINKS.traceKind$_UHM)), SNodeOperations.getConcept(kind))));
    Iterable<SNode> tracedElements = SLinkOperations.collect(SLinkOperations.collectMany(filteredTraces, LINKS.traceTarget$A1Zh), LINKS.traceTarget$Q_qM);

    return tracedElements;
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink traceKind$_UHM = MetaAdapterFactory.getContainmentLink(0x7d21cc4b4c2441dbL, 0x98688af4a7f3eba9L, 0x1d637a1db4e6503fL, 0x1d637a1db4e65040L, "traceKind");
    /*package*/ static final SContainmentLink traceTarget$A1Zh = MetaAdapterFactory.getContainmentLink(0x7d21cc4b4c2441dbL, 0x98688af4a7f3eba9L, 0x1d637a1db4e6503fL, 0x1d637a1db4e6504aL, "traceTarget");
    /*package*/ static final SReferenceLink traceTarget$Q_qM = MetaAdapterFactory.getReferenceLink(0x7d21cc4b4c2441dbL, 0x98688af4a7f3eba9L, 0x1d637a1db4e71b4cL, 0x1d637a1db4e71b4dL, "traceTarget");
  }

  private static final class CONCEPTS {
    /*package*/ static final SInterfaceConcept ITrace$ef = MetaAdapterFactory.getInterfaceConcept(0x7d21cc4b4c2441dbL, 0x98688af4a7f3eba9L, 0x1d637a1db4e6503fL, "org.iets3.core.trace.structure.ITrace");
  }
}
